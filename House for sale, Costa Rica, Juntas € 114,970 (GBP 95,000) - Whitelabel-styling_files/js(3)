/**
 * mlpushmenu.js v1.0.0
 * http://www.codrops.com
 *
 * Licensed under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
 * 
 * Copyright 2013, Codrops
 * http://www.codrops.com
 */
; (function (window) {
	'use strict';

	function extend( a, b ) {
		for( var key in b ) { 
			if( b.hasOwnProperty( key ) ) {
				a[key] = b[key];
			}
		}
		return a;
	}

	// taken from https://github.com/inuyaksa/jquery.nicescroll/blob/master/jquery.nicescroll.js
	function hasParent( e, id ) {
		if (!e) return false;
		var el = e.target||e.srcElement||e||false;
		while (el && el.id != id) {
			el = el.parentNode||false;
		}
		return (el!==false);
	}

	// returns the depth of the element "e" relative to element with id=id
	// for this calculation only parents with classname = waypoint are considered
	function getLevelDepth( e, id, waypoint, cnt ) {
		cnt = cnt || 0;
		if ( e.id.indexOf( id ) >= 0 ) return cnt;
		if( $(e).hasClass(waypoint) ) {
			++cnt;
		}
		return e.parentNode && getLevelDepth( e.parentNode, id, waypoint, cnt );
	}

	// http://coveroverflow.com/a/11381730/989439
	function mobilecheck() {
		var check = false;
		(function(a){if(/(android|ipad|playbook|silk|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(a)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0,4)))check = true})(navigator.userAgent||navigator.vendor||window.opera);
		return check;
	}

	// returns the closest element to 'e' that has class "classname"
	function closest( e, classname ) {
		if ($(e).hasClass(classname)) {
			return e;
		}
		return e.parentNode && closest( e.parentNode, classname );
	}

	function mlPushMenu( el, trigger, options ) {	
		this.el = el;
		this.trigger = trigger;
		this.options = extend( this.defaults, options );
		// support 3d transforms
		this.support = Modernizr.csstransforms3d;
		if( this.support ) {
			this._init();
		}
	}

	mlPushMenu.prototype = {
		defaults : {
			// overlap: there will be a gap between open levels
			// cover: the open levels will be on top of any previous open level
			type : 'overlap', // overlap || cover
			// space between each overlaped level
			levelSpacing : 40,
			// classname for the element (if any) that when clicked closes the current level
			backClass : 'mp-back'
		},
		_init : function() {
			// if menu is open or not
			this.open = false;
			// level depth
			this.level = 0;
			// the moving wrapper
			this.wrapper = document.getElementById( 'container-pusher' );
			// the mp-level elements
			this.levels = Array.prototype.slice.call( this.el.querySelectorAll( 'div.mp-level' ) );
			// save the depth of each of these mp-level elements
			var self = this;
			this.levels.forEach( function( el, i ) { el.setAttribute( 'data-level', getLevelDepth( el, self.el.id, 'mp-level' ) ); } );
			// the menu items
			this.menuItems = Array.prototype.slice.call( this.el.querySelectorAll( 'li' ) );
			// if type == "cover" these will serve as hooks to move back to the previous level
			this.levelBack = Array.prototype.slice.call( this.el.querySelectorAll( '.' + this.options.backClass ) );
			// event type (if mobile use touch events)
			this.eventtype = mobilecheck() ? 'touchstart' : 'click';
			// add the class mp-overlap or mp-cover to the main element depending on options.type
			$(this.el).addClass('mp-' + this.options.type);
			// set timer for screen resize purposes
			this.resizeTimer = 0;
			// initialize / bind the necessary events
			this._initEvents();
		},
		_initEvents : function() {
			var self = this;

			// the menu should close if clicking somewhere on the body
			var bodyClickFn = function( el ) {
				self._resetMenu();
				el.removeEventListener( self.eventtype, bodyClickFn );
			};

			// open (or close) the menu
			this.trigger.addEventListener( this.eventtype, function( ev ) {
				ev.stopPropagation();
				ev.preventDefault();
				if( self.open ) {
					self._resetMenu();
				}
				else {
					self._openMenu();
					// the menu should close if clicking somewhere on the body (excluding clicks on the menu)
					document.addEventListener( self.eventtype, function( ev ) {
						if( self.open && !hasParent( ev.target, self.el.id ) ) {
							bodyClickFn( this );
						}
					} );
				}
			} );

			// opening a sub level menu
			this.menuItems.forEach(function (el, i) {
				// check if it has a sub level
				var subLevel = el.querySelector( 'div.mp-level' );
				if (subLevel) {
					if (el.querySelector('.mp-menu-item_content') != undefined) {
						el.querySelector('.mp-menu-item_content').addEventListener(self.eventtype, function (ev) {
							ev.preventDefault();
							var level = closest( el, 'mp-level' ).getAttribute( 'data-level' );
							if( self.level <= level ) {
								ev.stopPropagation();
								$(closest(el, 'mp-level')).addClass('mp-level-overlay');
								self._openMenu( subLevel );
							}
						} );
					}
				}
			} );

			// closing the sub levels :
			// by clicking on the visible part of the level element
			this.levels.forEach( function( el, i ) {
				el.addEventListener( self.eventtype, function( ev ) {
					ev.stopPropagation();
					var level = el.getAttribute( 'data-level' );
					if( self.level > level ) {
						self.level = level;
						self._closeMenu();
					}
				} );
			} );

			// by clicking on a specific element
			this.levelBack.forEach( function( el, i ) {
				el.addEventListener( self.eventtype, function( ev ) {
					ev.preventDefault();
					var level = closest( el, 'mp-level' ).getAttribute( 'data-level' );
					if( self.level <= level ) {
						ev.stopPropagation();
						self.level = closest( el, 'mp-level' ).getAttribute( 'data-level' ) - 1;
						self.level === 0 ? self._resetMenu() : self._closeMenu();
					}
				} );
			});

			window.onresize = function (ev) {
				if (self.open) {
					clearTimeout(self.resizeTimer);
					self.resizeTimer = setTimeout(function () {
						if (self._getCurrentViewportWidth() > 1024) {
							self._resetMenu();
						}
					}, 500);
				} else {
					clearTimeout(self.resizeTimer);
				}
			};
			
		},
		_openMenu : function( subLevel ) {
			// increment level depth
			++this.level;

			// move the main wrapper
			var levelFactor = ( this.level - 1 ) * this.options.levelSpacing,
				translateVal = this.options.type === 'overlap' ? this.el.offsetWidth + levelFactor : this.el.offsetWidth;
			
			this._setTransform( 'translate3d(' + translateVal + 'px,0,0)' );

			if( subLevel ) {
				// reset transform for sublevel
				this._setTransform( '', subLevel );
				// need to reset the translate value for the level menus that have the same level depth and are not open
				for( var i = 0, len = this.levels.length; i < len; ++i ) {
					var levelEl = this.levels[i];
					if( levelEl != subLevel && !$(levelEl).hasClass('mp-level-open' ) ) {
						this._setTransform( 'translate3d(-100%,0,0) translate3d(' + -1*levelFactor + 'px,0,0)', levelEl );
					}
				}
			}
			// add class mp-pushed to main wrapper if opening the first time
			if( this.level === 1 ) {
				$(this.wrapper).addClass('mp-pushed');
				this.open = true;
			}
			// add class mp-level-open to the opening level element
			$(subLevel || this.levels[0]).addClass('mp-level-open');
		},
		// close the menu
		_resetMenu : function() {
			this._setTransform('translate3d(0,0,0)');
			this.level = 0;
			// remove class mp-pushed from main wrapper
			$(this.wrapper).removeClass('mp-pushed');
			this._toggleLevels();
			this.open = false;
		},
		// close sub menus
		_closeMenu : function() {
			var translateVal = this.options.type === 'overlap' ? this.el.offsetWidth + ( this.level - 1 ) * this.options.levelSpacing : this.el.offsetWidth;
			this._setTransform( 'translate3d(' + translateVal + 'px,0,0)' );
			this._toggleLevels();
		},
		// translate the el
		_setTransform : function( val, el ) {
			el = el || this.wrapper;
			el.style.WebkitTransform = val;
			el.style.MozTransform = val;
			el.style.transform = val;
		},
		// removes classes mp-level-open from closing levels
		_toggleLevels : function() {
			for( var i = 0, len = this.levels.length; i < len; ++i ) {
				var levelEl = this.levels[i];
				if (levelEl.getAttribute('data-level') >= this.level + 1) {
					$(levelEl).removeClass('mp-level-open mp-level-overlay');
				}
				else if( Number( levelEl.getAttribute( 'data-level' ) ) == this.level ) {
					$(levelEl).removeClass('mp-level-overlay');
				}
			}
		},
		_getCurrentViewportWidth: function() {
			return window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
		}
	}

	// add to global namespace
	window.mlPushMenu = mlPushMenu;

} )( window );
/**
* Cookie plugin
*
* Copyright (c) 2006 Klaus Hartl (stilbuero.de)
* Dual licensed under the MIT and GPL licenses:
* http://www.opensource.org/licenses/mit-license.php
* http://www.gnu.org/licenses/gpl.html
*
*/

/**
* Create a cookie with the given name and value and other optional parameters.
*
* @example $.cookie('the_cookie', 'the_value');
* @desc Set the value of a cookie.
* @example $.cookie('the_cookie', 'the_value', { expires: 7, path: '/', domain: 'jquery.com', secure: true });
* @desc Create a cookie with all available options.
* @example $.cookie('the_cookie', 'the_value');
* @desc Create a session cookie.
* @example $.cookie('the_cookie', null);
* @desc Delete a cookie by passing null as value. Keep in mind that you have to use the same path and domain
*       used when the cookie was set.
*
* @param String name The name of the cookie.
* @param String value The value of the cookie.
* @param Object options An object literal containing key/value pairs to provide optional cookie attributes.
* @option Number|Date expires Either an integer specifying the expiration date from now on in days or a Date object.
*                             If a negative value is specified (e.g. a date in the past), the cookie will be deleted.
*                             If set to null or omitted, the cookie will be a session cookie and will not be retained
*                             when the the browser exits.
* @option String path The value of the path atribute of the cookie (default: path of page that created the cookie).
* @option String domain The value of the domain attribute of the cookie (default: domain of page that created the cookie).
* @option Boolean secure If true, the secure attribute of the cookie will be set and the cookie transmission will
*                        require a secure protocol (like HTTPS).
* @type undefined
*
* @name $.cookie
* @cat Plugins/Cookie
* @author Klaus Hartl/klaus.hartl@stilbuero.de
*/

/**
* Get the value of a cookie with the given name.
*
* @example $.cookie('the_cookie');
* @desc Get the value of a cookie.
*
* @param String name The name of the cookie.
* @return The value of the cookie.
* @type String
*
* @name $.cookie
* @cat Plugins/Cookie
* @author Klaus Hartl/klaus.hartl@stilbuero.de
*/
jQuery.cookie = function(name, value, options) {
	if (typeof value != 'undefined') { // name and value given, set cookie
		options = options || {};
		if (value === null) {
			value = '';
			options.expires = -1;
		}
		var expires = '';
		if (options.expires && (typeof options.expires == 'number' || options.expires.toUTCString)) {
			var date;
			if (typeof options.expires == 'number') {
				date = new Date();
				date.setTime(date.getTime() + (options.expires * 24 * 60 * 60 * 1000));
			} else {
				date = options.expires;
			}
			expires = '; expires=' + date.toUTCString(); // use expires attribute, max-age is not supported by IE
		}
		// CAUTION: Needed to parenthesize options.path and options.domain
		// in the following expressions, otherwise they evaluate to undefined
		// in the packed version for some reason...
		var path = options.path ? '; path=' + (options.path) : '';
		var domain = options.domain ? '; domain=' + (options.domain) : '';
		var secure = options.secure ? '; secure' : '';
		document.cookie = [name, '=', encodeURIComponent(value), expires, path, domain, secure].join('');
	} else { // only name given, get cookie
		var cookieValue = null;
		if (document.cookie && document.cookie != '') {
			var cookies = document.cookie.split(';');
			for (var i = 0; i < cookies.length; i++) {
				var cookie = jQuery.trim(cookies[i]);
				// Does this cookie string begin with the name we want?
				if (cookie.substring(0, name.length + 1) == (name + '=')) {
					cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
					break;
				}
			}
		}
		return cookieValue;
	}
};

/// End file: jquery.cookie.js


/*! nanoScrollerJS - v0.7.4 - 2013
* http://jamesflorentino.github.com/nanoScrollerJS/
* Copyright (c) 2013 James Florentino; Licensed MIT */
(function ($, window, document) {
	"use strict";
	var BROWSER_IS_IE7, BROWSER_SCROLLBAR_WIDTH, DOMSCROLL, DOWN, DRAG, KEYDOWN, KEYUP, MOUSEDOWN, MOUSEMOVE, MOUSEUP, MOUSEWHEEL, NanoScroll, PANEDOWN, RESIZE, SCROLL, SCROLLBAR, TOUCHMOVE, UP, WHEEL, defaults, getBrowserScrollbarWidth;
	defaults = {
		/**
		  a classname for the pane element.
		  @property paneClass
		  @type String
		  @default 'pane'
		*/

		paneClass: 'pane',
		/**
		  a classname for the slider element.
		  @property sliderClass
		  @type String
		  @default 'slider'
		*/

		sliderClass: 'slider',
		/**
		  a classname for the content element.
		  @property contentClass
		  @type String
		  @default 'content'
		*/

		contentClass: 'nano_content',
		/**
		  a setting to enable native scrolling in iOS devices.
		  @property iOSNativeScrolling
		  @type Boolean
		  @default false
		*/

		iOSNativeScrolling: false,
		/**
		  a setting to prevent the rest of the page being
		  scrolled when user scrolls the `.content` element.
		  @property preventPageScrolling
		  @type Boolean
		  @default false
		*/

		preventPageScrolling: false,
		/**
		  a setting to disable binding to the resize event.
		  @property disableResize
		  @type Boolean
		  @default false
		*/

		disableResize: false,
		/**
		  a setting to make the scrollbar always visible.
		  @property alwaysVisible
		  @type Boolean
		  @default false
		*/

		alwaysVisible: false,
		/**
		  a default timeout for the `flash()` method.
		  @property flashDelay
		  @type Number
		  @default 1500
		*/

		flashDelay: 1500,
		/**
		  a minimum height for the `.slider` element.
		  @property sliderMinHeight
		  @type Number
		  @default 20
		*/

		sliderMinHeight: 20,
		/**
		  a maximum height for the `.slider` element.
		  @property sliderMaxHeight
		  @type Number
		  @default null
		*/

		sliderMaxHeight: null,
		/**
		  an alternate document context.
		  @property documentContext
		  @type Document
		  @default null
		*/

		documentContext: null,
		/**
		  an alternate window context.
		  @property windowContext
		  @type Window
		  @default null
		*/

		windowContext: null
	};
	/**
	  @property SCROLLBAR
	  @type String
	  @static
	  @final
	  @private
	*/

	SCROLLBAR = 'scrollbar';
	/**
	  @property SCROLL
	  @type String
	  @static
	  @final
	  @private
	*/

	SCROLL = 'scroll';
	/**
	  @property MOUSEDOWN
	  @type String
	  @final
	  @private
	*/

	MOUSEDOWN = 'mousedown';
	/**
	  @property MOUSEMOVE
	  @type String
	  @static
	  @final
	  @private
	*/

	MOUSEMOVE = 'mousemove';
	/**
	  @property MOUSEWHEEL
	  @type String
	  @final
	  @private
	*/

	MOUSEWHEEL = 'mousewheel';
	/**
	  @property MOUSEUP
	  @type String
	  @static
	  @final
	  @private
	*/

	MOUSEUP = 'mouseup';
	/**
	  @property RESIZE
	  @type String
	  @final
	  @private
	*/

	RESIZE = 'resize';
	/**
	  @property DRAG
	  @type String
	  @static
	  @final
	  @private
	*/

	DRAG = 'drag';
	/**
	  @property UP
	  @type String
	  @static
	  @final
	  @private
	*/

	UP = 'up';
	/**
	  @property PANEDOWN
	  @type String
	  @static
	  @final
	  @private
	*/

	PANEDOWN = 'panedown';
	/**
	  @property DOMSCROLL
	  @type String
	  @static
	  @final
	  @private
	*/

	DOMSCROLL = 'DOMMouseScroll';
	/**
	  @property DOWN
	  @type String
	  @static
	  @final
	  @private
	*/

	DOWN = 'down';
	/**
	  @property WHEEL
	  @type String
	  @static
	  @final
	  @private
	*/

	WHEEL = 'wheel';
	/**
	  @property KEYDOWN
	  @type String
	  @static
	  @final
	  @private
	*/

	KEYDOWN = 'keydown';
	/**
	  @property KEYUP
	  @type String
	  @static
	  @final
	  @private
	*/

	KEYUP = 'keyup';
	/**
	  @property TOUCHMOVE
	  @type String
	  @static
	  @final
	  @private
	*/

	TOUCHMOVE = 'touchmove';
	/**
	  @property BROWSER_IS_IE7
	  @type Boolean
	  @static
	  @final
	  @private
	*/

	BROWSER_IS_IE7 = window.navigator.appName === 'Microsoft Internet Explorer' && /msie 7./i.test(window.navigator.appVersion) && window.ActiveXObject;
	/**
	  @property BROWSER_SCROLLBAR_WIDTH
	  @type Number
	  @static
	  @default null
	  @private
	*/

	BROWSER_SCROLLBAR_WIDTH = null;
	/**
	  Returns browser's native scrollbar width
	  @method getBrowserScrollbarWidth
	  @return {Number} the scrollbar width in pixels
	  @static
	  @private
	*/

	getBrowserScrollbarWidth = function () {
		var outer, outerStyle, scrollbarWidth;
		outer = document.createElement('div');
		outerStyle = outer.style;
		outerStyle.position = 'absolute';
		outerStyle.width = '100px';
		outerStyle.height = '100px';
		outerStyle.overflow = SCROLL;
		outerStyle.top = '-9999px';
		document.body.appendChild(outer);
		scrollbarWidth = outer.offsetWidth - outer.clientWidth;
		document.body.removeChild(outer);
		return scrollbarWidth;
	};
	/**
	  @class NanoScroll
	  @param element {HTMLElement|Node} the main element
	  @param options {Object} nanoScroller's options
	  @constructor
	*/

	NanoScroll = (function () {
		function NanoScroll(el, options) {
			this.el = el;
			this.options = options;
			BROWSER_SCROLLBAR_WIDTH || (BROWSER_SCROLLBAR_WIDTH = getBrowserScrollbarWidth());
			this.$el = $(this.el);
			this.doc = $(this.options.documentContext || document);
			this.win = $(this.options.windowContext || window);
			this.$content = this.$el.children("." + options.contentClass);
			this.$content.attr('tabindex', this.options.tabIndex || 0);
			this.content = this.$content[0];
			if (this.options.iOSNativeScrolling && (this.el.style.WebkitOverflowScrolling != null)) {
				this.nativeScrolling();
			} else {
				this.generate();
			}
			this.createEvents();
			this.addEvents();
			this.reset();
		}

		/**
		  Prevents the rest of the page being scrolled
		  when user scrolls the `.content` element.
		  @method preventScrolling
		  @param event {Event}
		  @param direction {String} Scroll direction (up or down)
		  @private
		*/


		NanoScroll.prototype.preventScrolling = function (e, direction) {
			if (!this.isActive) {
				return;
			}
			if (e.type === DOMSCROLL) {
				if (direction === DOWN && e.originalEvent.detail > 0 || direction === UP && e.originalEvent.detail < 0) {
					e.preventDefault();
				}
			} else if (e.type === MOUSEWHEEL) {
				if (!e.originalEvent || !e.originalEvent.wheelDelta) {
					return;
				}
				if (direction === DOWN && e.originalEvent.wheelDelta < 0 || direction === UP && e.originalEvent.wheelDelta > 0) {
					e.preventDefault();
				}
			}
		};

		/**
		  Enable iOS native scrolling
		*/


		NanoScroll.prototype.nativeScrolling = function () {
			this.$content.css({
				WebkitOverflowScrolling: 'touch'
			});
			this.iOSNativeScrolling = true;
			this.isActive = true;
		};

		/**
		  Updates those nanoScroller properties that
		  are related to current scrollbar position.
		  @method updateScrollValues
		  @private
		*/


		NanoScroll.prototype.updateScrollValues = function () {
			var content;
			content = this.content;
			this.maxScrollTop = content.scrollHeight - content.clientHeight;
			this.prevScrollTop = this.contentScrollTop || 0;
			this.contentScrollTop = content.scrollTop;
			if (!this.iOSNativeScrolling) {
				this.maxSliderTop = this.paneHeight - this.sliderHeight;
				this.sliderTop = this.maxScrollTop === 0 ? 0 : this.contentScrollTop * this.maxSliderTop / this.maxScrollTop;
			}
		};

		/**
		  Creates event related methods
		  @method createEvents
		  @private
		*/


		NanoScroll.prototype.createEvents = function () {
			var _this = this;
			this.events = {
				down: function (e) {
					_this.isBeingDragged = true;
					_this.offsetY = e.pageY - _this.slider.offset().top;
					_this.pane.addClass('active');
					_this.doc.bind(MOUSEMOVE, _this.events[DRAG]).bind(MOUSEUP, _this.events[UP]);
					return false;
				},
				drag: function (e) {
					_this.sliderY = e.pageY - _this.$el.offset().top - _this.offsetY;
					_this.scroll();
					_this.updateScrollValues();
					if (_this.contentScrollTop >= _this.maxScrollTop && _this.prevScrollTop !== _this.maxScrollTop) {
						_this.$el.trigger('scrollend');
					} else if (_this.contentScrollTop === 0 && _this.prevScrollTop !== 0) {
						_this.$el.trigger('scrolltop');
					}
					return false;
				},
				up: function (e) {
					_this.isBeingDragged = false;
					_this.pane.removeClass('active');
					_this.doc.unbind(MOUSEMOVE, _this.events[DRAG]).unbind(MOUSEUP, _this.events[UP]);
					return false;
				},
				resize: function (e) {
					_this.reset();
				},
				panedown: function (e) {
					_this.sliderY = (e.offsetY || e.originalEvent.layerY) - (_this.sliderHeight * 0.5);
					_this.scroll();
					_this.events.down(e);
					return false;
				},
				scroll: function (e) {
					if (_this.isBeingDragged) {
						return;
					}
					_this.updateScrollValues();
					if (!_this.iOSNativeScrolling) {
						_this.sliderY = _this.sliderTop;
						_this.slider.css({
							top: _this.sliderTop
						});
					}
					if (e == null) {
						return;
					}
					if (_this.contentScrollTop >= _this.maxScrollTop) {
						if (_this.options.preventPageScrolling) {
							_this.preventScrolling(e, DOWN);
						}
						if (_this.prevScrollTop !== _this.maxScrollTop) {
							_this.$el.trigger('scrollend');
						}
					} else if (_this.contentScrollTop === 0) {
						if (_this.options.preventPageScrolling) {
							_this.preventScrolling(e, UP);
						}
						if (_this.prevScrollTop !== 0) {
							_this.$el.trigger('scrolltop');
						}
					}
				},
				wheel: function (e) {
					var delta;
					if (e == null) {
						return;
					}
					delta = e.delta || e.wheelDelta || (e.originalEvent && e.originalEvent.wheelDelta) || -e.detail || (e.originalEvent && -e.originalEvent.detail);
					if (delta) {
						_this.sliderY += -delta / 3;
					}
					_this.scroll();
					return false;
				}
			};
		};

		/**
		  Adds event listeners with jQuery.
		  @method addEvents
		  @private
		*/


		NanoScroll.prototype.addEvents = function () {
			var events;
			this.removeEvents();
			events = this.events;
			if (!this.options.disableResize) {
				this.win.bind(RESIZE, events[RESIZE]);
			}
			if (!this.iOSNativeScrolling) {
				this.slider.bind(MOUSEDOWN, events[DOWN]);
				this.pane.bind(MOUSEDOWN, events[PANEDOWN]).bind("" + MOUSEWHEEL + " " + DOMSCROLL, events[WHEEL]);
			}
			this.$content.bind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
		};

		/**
		  Removes event listeners with jQuery.
		  @method removeEvents
		  @private
		*/


		NanoScroll.prototype.removeEvents = function () {
			var events;
			events = this.events;
			this.win.unbind(RESIZE, events[RESIZE]);
			if (!this.iOSNativeScrolling) {
				this.slider.unbind();
				this.pane.unbind();
			}
			this.$content.unbind("" + SCROLL + " " + MOUSEWHEEL + " " + DOMSCROLL + " " + TOUCHMOVE, events[SCROLL]);
		};

		/**
		  Generates nanoScroller's scrollbar and elements for it.
		  @method generate
		  @chainable
		  @private
		*/


		NanoScroll.prototype.generate = function () {
			var contentClass, cssRule, options, paneClass, sliderClass;
			options = this.options;
			paneClass = options.paneClass, sliderClass = options.sliderClass, contentClass = options.contentClass;
			if (!this.$el.find("" + paneClass).length && !this.$el.find("" + sliderClass).length) {
				this.$el.append("<div class=\"" + paneClass + "\"><div class=\"" + sliderClass + "\" /></div>");
			}
			this.pane = this.$el.children("." + paneClass);
			this.slider = this.pane.find("." + sliderClass);
			if (BROWSER_SCROLLBAR_WIDTH) {
				cssRule = {
					right: -BROWSER_SCROLLBAR_WIDTH
				};
				this.$el.addClass('has-scrollbar');
			}
			if (cssRule != null) {
				this.$content.css(cssRule);
			}
			return this;
		};

		/**
		  @method restore
		  @private
		*/


		NanoScroll.prototype.restore = function () {
			this.stopped = false;
			this.pane.show();
			this.addEvents();
		};

		/**
		  Resets nanoScroller's scrollbar.
		  @method reset
		  @chainable
		  @example
			  $(".nano").nanoScroller();
		*/


		NanoScroll.prototype.reset = function () {
			var content, contentHeight, contentStyle, contentStyleOverflowY, paneBottom, paneHeight, paneOuterHeight, paneTop, parentMaxHeight, sliderHeight;
			if (this.iOSNativeScrolling) {
				this.contentHeight = this.content.scrollHeight;
				return;
			}
			if (!this.$el.find("." + this.options.paneClass).length) {
				this.generate().stop();
			}
			if (this.stopped) {
				this.restore();
			}
			content = this.content;
			contentStyle = content.style;
			contentStyleOverflowY = contentStyle.overflowY;
			if (BROWSER_IS_IE7) {
				this.$content.css({
					height: this.$content.height()
				});
			}
			contentHeight = content.scrollHeight + BROWSER_SCROLLBAR_WIDTH;
			parentMaxHeight = parseInt(this.$el.css("max-height"), 10);
			if (parentMaxHeight > 0) {
				this.$el.height("");
				this.$el.height(content.scrollHeight > parentMaxHeight ? parentMaxHeight : content.scrollHeight);
			}
			paneHeight = this.pane.outerHeight(false);
			paneTop = parseInt(this.pane.css('top'), 10);
			paneBottom = parseInt(this.pane.css('bottom'), 10);
			paneOuterHeight = paneHeight + paneTop + paneBottom;
			sliderHeight = Math.round(paneOuterHeight / contentHeight * paneOuterHeight);
			if (sliderHeight < this.options.sliderMinHeight) {
				sliderHeight = this.options.sliderMinHeight;
			} else if ((this.options.sliderMaxHeight != null) && sliderHeight > this.options.sliderMaxHeight) {
				sliderHeight = this.options.sliderMaxHeight;
			}
			if (contentStyleOverflowY === SCROLL && contentStyle.overflowX !== SCROLL) {
				sliderHeight += BROWSER_SCROLLBAR_WIDTH;
			}
			this.maxSliderTop = paneOuterHeight - sliderHeight;
			this.contentHeight = contentHeight;
			this.paneHeight = paneHeight;
			this.paneOuterHeight = paneOuterHeight;
			this.sliderHeight = sliderHeight;
			this.slider.height(sliderHeight);
			this.events.scroll();
			this.pane.show();
			this.isActive = true;
			if ((content.scrollHeight === content.clientHeight) || (this.pane.outerHeight(true) >= content.scrollHeight && contentStyleOverflowY !== SCROLL)) {
				this.pane.hide();
				this.isActive = false;
			} else if (this.el.clientHeight === content.scrollHeight && contentStyleOverflowY === SCROLL) {
				this.slider.hide();
			} else {
				this.slider.show();
			}
			this.pane.css({
				opacity: (this.options.alwaysVisible ? 1 : ''),
				visibility: (this.options.alwaysVisible ? 'visible' : '')
			});
			return this;
		};

		/**
		  @method scroll
		  @private
		  @example
			  $(".nano").nanoScroller({ scroll: 'top' });
		*/


		NanoScroll.prototype.scroll = function () {
			if (!this.isActive) {
				return;
			}
			this.sliderY = Math.max(0, this.sliderY);
			this.sliderY = Math.min(this.maxSliderTop, this.sliderY);
			this.$content.scrollTop((this.paneHeight - this.contentHeight + BROWSER_SCROLLBAR_WIDTH) * this.sliderY / this.maxSliderTop * -1);
			if (!this.iOSNativeScrolling) {
				this.slider.css({
					top: this.sliderY
				});
			}
			return this;
		};

		/**
		  Scroll at the bottom with an offset value
		  @method scrollBottom
		  @param offsetY {Number}
		  @chainable
		  @example
			  $(".nano").nanoScroller({ scrollBottom: value });
		*/


		NanoScroll.prototype.scrollBottom = function (offsetY) {
			if (!this.isActive) {
				return;
			}
			this.reset();
			this.$content.scrollTop(this.contentHeight - this.$content.height() - offsetY).trigger(MOUSEWHEEL);
			return this;
		};

		/**
		  Scroll at the top with an offset value
		  @method scrollTop
		  @param offsetY {Number}
		  @chainable
		  @example
			  $(".nano").nanoScroller({ scrollTop: value });
		*/


		NanoScroll.prototype.scrollTop = function (offsetY) {
			if (!this.isActive) {
				return;
			}
			this.reset();
			this.$content.scrollTop(+offsetY).trigger(MOUSEWHEEL);
			return this;
		};

		/**
		  Scroll to an element
		  @method scrollTo
		  @param node {Node} A node to scroll to.
		  @chainable
		  @example
			  $(".nano").nanoScroller({ scrollTo: $('#a_node') });
		*/


		NanoScroll.prototype.scrollTo = function (node) {
			if (!this.isActive) {
				return;
			}
			this.reset();
			this.scrollTop($(node).get(0).offsetTop);
			return this;
		};

		/**
		  To stop the operation.
		  This option will tell the plugin to disable all event bindings and hide the gadget scrollbar from the UI.
		  @method stop
		  @chainable
		  @example
			  $(".nano").nanoScroller({ stop: true });
		*/


		NanoScroll.prototype.stop = function () {
			this.stopped = true;
			this.removeEvents();
			this.pane.hide();
			return this;
		};

		/**
		  Destroys nanoScroller and restores browser's native scrollbar.
		  @method destroy
		  @chainable
		  @example
			  $(".nano").nanoScroller({ destroy: true });
		*/


		NanoScroll.prototype.destroy = function () {
			if (!this.stopped) {
				this.stop();
			}
			if (this.pane.length) {
				this.pane.remove();
			}
			if (BROWSER_IS_IE7) {
				this.$content.height('');
			}
			this.$content.removeAttr('tabindex');
			if (this.$el.hasClass('has-scrollbar')) {
				this.$el.removeClass('has-scrollbar');
				this.$content.css({
					right: ''
				});
			}
			return this;
		};

		/**
		  To flash the scrollbar gadget for an amount of time defined in plugin settings (defaults to 1,5s).
		  Useful if you want to show the user (e.g. on pageload) that there is more content waiting for him.
		  @method flash
		  @chainable
		  @example
			  $(".nano").nanoScroller({ flash: true });
		*/


		NanoScroll.prototype.flash = function () {
			var _this = this;
			if (!this.isActive) {
				return;
			}
			this.reset();
			this.pane.addClass('flashed');
			setTimeout(function () {
				_this.pane.removeClass('flashed');
			}, this.options.flashDelay);
			return this;
		};

		return NanoScroll;

	})();
	$.fn.nanoScroller = function (settings) {
		return this.each(function () {
			var options, scrollbar;
			if (!(scrollbar = this.nanoscroller)) {
				options = $.extend({}, defaults, settings);
				this.nanoscroller = scrollbar = new NanoScroll(this, options);
			}
			if (settings && typeof settings === "object") {
				$.extend(scrollbar.options, settings);
				if (settings.scrollBottom) {
					return scrollbar.scrollBottom(settings.scrollBottom);
				}
				if (settings.scrollTop) {
					return scrollbar.scrollTop(settings.scrollTop);
				}
				if (settings.scrollTo) {
					return scrollbar.scrollTo(settings.scrollTo);
				}
				if (settings.scroll === 'bottom') {
					return scrollbar.scrollBottom(0);
				}
				if (settings.scroll === 'top') {
					return scrollbar.scrollTop(0);
				}
				if (settings.scroll && settings.scroll instanceof $) {
					return scrollbar.scrollTo(settings.scroll);
				}
				if (settings.stop) {
					return scrollbar.stop();
				}
				if (settings.destroy) {
					return scrollbar.destroy();
				}
				if (settings.flash) {
					return scrollbar.flash();
				}
			}
			return scrollbar.reset();
		});
	};
	$.fn.nanoScroller.Constructor = NanoScroll;
})(jQuery, window, document);

/// End file: jquery.nanoscroller.js

/*
 * RoyalSlider
 *
 * @version 9.4.92:
 *
 * Copyright 2011-2013, Dmitry Semenov
 *
 */
(function($) {

	"use strict";

	if(!$.rsModules) {
		$.rsModules = {uid:0};
	}

	function RoyalSlider(element, options) {
		var i,
			self = this,
			ua = navigator.userAgent.toLowerCase();

		self.uid = $.rsModules.uid++;
		self.ns = '.rs' + self.uid; // unique namespace for events

		// feature detection, some ideas taken from Modernizr
		var tempStyle = document.createElement('div').style,
			vendors = ['webkit','Moz','ms','O'],
			vendor = '',
			lastTime = 0,
			tempV;

		for (i = 0; i < vendors.length; i++ ) {
			tempV = vendors[i];
			if (!vendor && (tempV + 'Transform') in tempStyle ) {
				vendor = tempV;
			}
			tempV = tempV.toLowerCase();
			
			if(!window.requestAnimationFrame) {
				window.requestAnimationFrame = window[tempV+'RequestAnimationFrame'];
				window.cancelAnimationFrame = window[tempV+'CancelAnimationFrame'] || window[tempV+'CancelRequestAnimationFrame'];
			}
		}

		// requestAnimationFrame polyfill by Erik Möller
		// fixes from Paul Irish and Tino Zijdel
		if (!window.requestAnimationFrame) {
			window.requestAnimationFrame = function(callback, element) {
				var currTime = new Date().getTime(),
					timeToCall = Math.max(0, 16 - (currTime - lastTime)),
					id = window.setTimeout(function() { callback(currTime + timeToCall); }, timeToCall);
					lastTime = currTime + timeToCall;
				return id;
			};
		}

		if (!window.cancelAnimationFrame) {
			window.cancelAnimationFrame = function(id) { clearTimeout(id); };
		}
			

		self.isIPAD = ua.match(/(ipad)/);


		// browser UA sniffing, sadly still required
		var uaMatch = function( ua ) {
			var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
				/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
				/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
				/(msie) ([\w.]+)/.exec( ua ) ||
				ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
				[];

			return {
				browser: match[ 1 ] || "",
				version: match[ 2 ] || "0"
			};
		};
		var matched = uaMatch( ua );
		var br = {};
		if ( matched.browser ) {
			br[ matched.browser ] = true;
			br.version = matched.version;
		}

		if(br.chrome) { 
			br.webkit = true;
		}

		self._browser = br;
		self.isAndroid = ua.indexOf("android") > -1;



		self.slider = $(element); // DOM reference
		self.ev = $(self); // event object
		self._doc = $(document);
		self.st = $.extend({}, $.fn.royalSlider.defaults, options); 
		self._currAnimSpeed = self.st.transitionSpeed;
		self._minPosOffset = 0;
		if(self.st.allowCSS3) {
			if((!br.webkit || self.st.allowCSS3OnWebkit) ) {
				var bT = vendor + (vendor ? 'T' : 't' );
				self._useCSS3Transitions = ( (bT + 'ransform') in tempStyle ) && ( (bT + 'ransition') in tempStyle );
				if(self._useCSS3Transitions) {
					self._use3dTransform = (vendor + (vendor ? 'P' : 'p'  ) + 'erspective') in tempStyle;
				}
			}
		}
		
		vendor = vendor.toLowerCase();
		self._vendorPref = '-'+vendor+'-';
		
		self._slidesHorizontal = (self.st.slidesOrientation === 'vertical') ? false : true;
		self._reorderProp = self._slidesHorizontal ? 'left' : 'top';
		self._sizeProp = self._slidesHorizontal ? 'width' : 'height';
		self._prevNavItemId = -1;
		self._isMove = (self.st.transitionType === 'fade') ? false : true;
		if(!self._isMove) {
			self.st.sliderDrag = false;
			self._fadeZIndex = 10;
		}
		self._opacityCSS = 'z-index:0; display:none; opacity:0;';

		self._newSlideId = 0;
		self._sPosition = 0;
		self._nextSlidePos = 0;

		// init modules
		$.each($.rsModules, function (helper, opts) {
			if(helper !== 'uid')
				opts.call(self);
		});

		// parse all slides
		self.slides = [];
		self._idCount = 0;
		var returnVal;
		var ts = self.st.slides ? $(self.st.slides) : self.slider.children().detach();
		
		ts.each(function() {
			self._parseNode(this, true);
		});

		if(self.st.randomizeSlides) {
			self.slides.sort(function() { return 0.5 - Math.random(); });
		}
		self.numSlides = self.slides.length;
		self._refreshNumPreloadImages();

		if(!self.st.startSlideId) {
			self.st.startSlideId = 0;
		} else if(self.st.startSlideId > self.numSlides - 1) {
			self.st.startSlideId = self.numSlides - 1;
		}

		self._newSlideId = self.staticSlideId = self.currSlideId = self._realId =  self.st.startSlideId;
		self.currSlide = self.slides[self.currSlideId];

		self._accelerationPos = 0;
		self.msTouch = false;
		self.slider.addClass( (self._slidesHorizontal ? 'rsHor' : 'rsVer') + (self._isMove ? '' : ' rsFade') );

		var sliderHTML = '<div class="rsOverflow"><div class="rsContainer">';
		self.slidesSpacing = self.st.slidesSpacing;
		self._slideSize = ( self._slidesHorizontal ? self.slider.width() : self.slider.height() ) + self.st.slidesSpacing;

		self._preload = Boolean(self._numPreloadImages > 0);
		
		if(self.numSlides <= 1) {
			self._loop = false;
		}
		var loopHelpers = (self._loop && self._isMove) ? ( self.numSlides === 2 ? 1 : 2) : 0;
		self._loopHelpers = loopHelpers;

		self._maxImages = self.numSlides < 6 ? self.numSlides : 6;
		self._currBlockIndex = 0;


		self._idOffset = 0;
		self.slidesJQ = [];
		
		for(i =0; i < self.numSlides; i++) {
			self.slidesJQ.push( $(createItemHTML(i)) );
		}
		self._sliderOverflow = sliderHTML = $(sliderHTML + '</div></div>');


		var addCursors = function() {
			if(self.st.sliderDrag) {
				self._hasDrag = true;
				if (br.msie || br.opera) {
					self._grabCursor = self._grabbingCursor = "move";
				} else if(br.mozilla) {
					self._grabCursor = "-moz-grab";
					self._grabbingCursor = "-moz-grabbing";
				} else if(br.webkit && (navigator.platform.indexOf("Mac")!=-1)) {
					self._grabCursor = "-webkit-grab";
					self._grabbingCursor = "-webkit-grabbing";
				}
				self._setGrabCursor();
			}
		};
		var rsNS = self.ns;
		var addEventNames = function(pref, down, move, up, cancel) {
			self._downEvent = pref + down + rsNS;
			self._moveEvent = pref + move + rsNS;
			self._upEvent = pref + up + rsNS;
			if(cancel)
				self._cancelEvent = pref + cancel + rsNS;
		};


		// ie10
		self.msEnabled = window.navigator.msPointerEnabled;

		if(self.msEnabled) {
			self.msTouch = Boolean(window.navigator.msMaxTouchPoints > 1);
			self.hasTouch = false;
			self._lastItemFriction = 0.2;
			
			addEventNames('MSPointer', 'Down', 'Move', 'Up', 'Cancel');
		} else {
			addEventNames('mouse', 'down', 'move', 'up', 'up');

			if('ontouchstart' in window || 'createTouch' in document) {
				self.hasTouch = true;
				self._downEvent += ' touchstart' + rsNS;
				self._moveEvent += ' touchmove' + rsNS;
				self._upEvent += ' touchend' + rsNS;
				self._cancelEvent += ' touchcancel' + rsNS;
				self._lastItemFriction = 0.5;
				if(self.st.sliderTouch) {
					self._hasDrag = true;
				}
			} else {
				self.hasTouch = false;
				self._lastItemFriction = 0.2;
			}
		}
		addCursors();
	
		self.slider.html(sliderHTML);

		
		self._controlsContainer = self.st.controlsInside ? self._sliderOverflow : self.slider;
		
		self._slidesContainer = self._sliderOverflow.children('.rsContainer');
		if(self.msEnabled) {
			self._slidesContainer.css('-ms-touch-action', self._slidesHorizontal ? 'pan-y' : 'pan-x');
		}
		self._preloader = $('<div class="rsPreloader"></div>');
		var slides = self._slidesContainer.children('.rsSlide');

		self._currHolder = self.slidesJQ[self.currSlideId];
		self._selectedSlideHolder = 0;

		function createItemHTML(i, className) {
			return '<div style="'+ (self._isMove ? '' : (i !== self.currSlideId  ? self._opacityCSS : 'z-index:0;') ) +'" class="rsSlide '+ (className || '')+'"></div>';
		}
		
		if(self._useCSS3Transitions) {

			// some constants for CSS3
			self._TP = 'transition-property';
			self._TD = 'transition-duration';
			self._TTF = 'transition-timing-function';

			self._yProp = self._xProp = self._vendorPref +'transform';

			if(self._use3dTransform) {
				if(br.webkit && !br.chrome) {
					self.slider.addClass('rsWebkit3d');
				}
				if((/iphone|ipad|ipod/gi).test(navigator.appVersion)) {
					
				}

				self._tPref1 = 'translate3d(';
				self._tPref2 = 'px, ';
				self._tPref3 = 'px, 0px)';
			} else {
				self._tPref1 = 'translate(';
				self._tPref2 = 'px, ';
				self._tPref3 = 'px)';
			}
			if(!self._isMove) {
				var animObj = {};
				animObj[(self._vendorPref + self._TP)] = 'opacity';
				animObj[(self._vendorPref + self._TD)] = self.st.transitionSpeed + 'ms';
				animObj[(self._vendorPref + self._TTF)] = self.st.css3easeInOut;
				slides.css(animObj);
			} else {
				self._slidesContainer[(self._vendorPref + self._TP)] = (self._vendorPref + 'transform');
			}
			

		} else {
			self._xProp = 'left';
			self._yProp = 'top';
		}

		

		// window resize
		var resizeTimer;
		$(window).on('resize'+self.ns, function() {	
			if(resizeTimer) {
				clearTimeout(resizeTimer);			
			}
			resizeTimer = setTimeout(function() { self.updateSliderSize(); }, 50);			
		});	
		self.ev.trigger('rsAfterPropsSetup'); // navigation (bullets, thumbs...) are created here

		self.updateSliderSize();


		// keyboard nav
		if(self.st.keyboardNavEnabled) {
			self._bindKeyboardNav();
		}

		if(self.st.arrowsNavHideOnTouch && (self.hasTouch || self.msTouch) ) {
			self.st.arrowsNav = false;
		}

		//Direction navigation (arrows)
		if(self.st.arrowsNav) {
			var rArr = 'rsArrow',
				container = self._controlsContainer;
			$('<div class="'+rArr+' '+rArr+'Left"><div class="'+rArr+'Icn"></div></div><div class="'+rArr+' '+rArr+'Right"><div class="'+rArr+'Icn"></div></div>').appendTo(container);

			self._arrowLeft = container.children('.'+rArr+'Left').click(function(e) {
				e.preventDefault();
				self.prev();
			});
			self._arrowRight = container.children('.'+rArr+'Right').click(function(e) {
				e.preventDefault();
				self.next();
			});

			if(self.st.arrowsNavAutoHide && !self.hasTouch) {
				self._arrowLeft.addClass('rsHidden');
				self._arrowRight.addClass('rsHidden');

				var hoverEl = container;
				hoverEl.one("mousemove.arrowshover",function() {
					self._arrowLeft.removeClass('rsHidden');
					self._arrowRight.removeClass('rsHidden');			
				});


				hoverEl.hover(
					function() {
						if(!self._arrowsAutoHideLocked) {
							self._arrowLeft.removeClass('rsHidden');
							self._arrowRight.removeClass('rsHidden');
						}
					},
					function() {
						if(!self._arrowsAutoHideLocked) {
							self._arrowLeft.addClass('rsHidden');
							self._arrowRight.addClass('rsHidden');
						}
					}
				);	
			}	
			self.ev.on('rsOnUpdateNav', function() {
				self._updateArrowsNav();
			});
			self._updateArrowsNav();
		}

			
		
		if( self._hasDrag ) {
			self._slidesContainer.on(self._downEvent, function(e) { self._onDragStart(e); });	
		} else {
			self.dragSuccess = false;
		}
		var videoClasses = ['rsPlayBtnIcon', 'rsPlayBtn', 'rsCloseVideoBtn', 'rsCloseVideoIcn'];
		self._slidesContainer.click(function(e) {
			if(!self.dragSuccess) {
				var t = $(e.target);
				var tClass = t.attr('class');
				if( $.inArray(tClass, videoClasses) !== -1) {
					if( self.toggleVideo() ) {
						return false;
					}
				}
				if(self.st.navigateByClick && !self._blockActions) {
					if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
						return true;
					}
					self._mouseNext(e);
				} 
				self.ev.trigger('rsSlideClick');
			} 
		}).on('click.rs', 'a', function(e) {	
			if(self.dragSuccess) {						
				return false;
			} else {
				self._blockActions = true;
				//e.stopPropagation();
				//e.stopImmediatePropagation();
				setTimeout(function() {
					self._blockActions = false;
				}, 3);
			}
		});
		self.ev.trigger('rsAfterInit');
	} /* RoyalSlider Constructor End */

	/**
	 *
	 * RoyalSlider Core Prototype
	 * 
	 */
	RoyalSlider.prototype = {
		constructor: RoyalSlider,
		_mouseNext: function(e) {
			var self = this,
				relativePos = e[self._slidesHorizontal ? 'pageX' : 'pageY'] - self._sliderOffset;

			if(relativePos >= self._nextSlidePos) {
				self.next();
			} else if(relativePos < 0) {
				self.prev();
			}
		},
		_refreshNumPreloadImages: function() {
			var self = this,
				n;
			n = self.st.numImagesToPreload;
			self._loop = self.st.loop;

			if(self._loop) {
				if(self.numSlides === 2) {
					self._loop = false;
					self.st.loopRewind = true;
				} else if(self.numSlides < 2) {
					self.st.loopRewind = self._loop = false;
				}
				
			}
			if(self._loop && n > 0) {
				if(self.numSlides <= 4) {
					n = 1;
				} else {
					if(self.st.numImagesToPreload > (self.numSlides - 1) / 2 ) {
						n = Math.floor( (self.numSlides - 1) / 2 );
					}
				} 
			}
			self._numPreloadImages = n;
		},
		_parseNode: function(content, pushToSlides) {
			var self = this,
				hasImg,
				isRoot,
				hasCover,
				obj = {},
				tempEl,
				first = true;
			content = $(content);
			self._currContent = content;
			self.ev.trigger('rsBeforeParseNode', [content, obj]);
			if(obj.stopParsing) {
				return;
			}
			content = self._currContent;
			obj.id = self._idCount;
			obj.contentAdded = false;
			self._idCount++;
			obj.images = [];
			obj.isBig = false;

			if(!obj.hasCover) {
				if(content.hasClass('rsImg')) {
					tempEl = content;
					hasImg = true;
				} else {
					tempEl = content.find('.rsImg');
					if(tempEl.length) {
						hasImg = true;
					}
				}

				if(hasImg) {
					obj.bigImage = tempEl.eq(0).attr('data-rsBigImg');
					tempEl.each(function() {
						var item = $(this);
						if(item.is('a')) {
							parseEl(item, 'href');
						} else if(item.is('img')) {
							parseEl(item, 'src');
						} else {
							parseEl(item);
						}
					});
				} else if(content.is('img')) {
					content.addClass('rsImg rsMainSlideImage');
					parseEl(content, 'src');
				}
			}
			tempEl = content.find('.rsCaption');
			if(tempEl.length) {
				obj.caption = tempEl.remove();
			}
			obj.content = content;

			self.ev.trigger('rsAfterParseNode', [content, obj]);
			function parseEl(el, s) {
				if(s) {
					obj.images.push( el.attr(s) );
				} else {
					obj.images.push( el.text() );
				}
				if(first) {
					first = false;
					obj.caption = (s === 'src') ? el.attr('alt') : el.contents();
					obj.image = obj.images[0];
					obj.videoURL = el.attr('data-rsVideo');
					
					
					var wAtt = el.attr('data-rsw'),
						hAtt = el.attr('data-rsh');
					if (typeof wAtt !== 'undefined' && wAtt !== false && typeof hAtt !== 'undefined' && hAtt !== false ) {
						obj.iW = parseInt(wAtt, 10);
						obj.iH = parseInt(hAtt, 10);
					} else if(self.st.imgWidth && self.st.imgHeight ) {
						obj.iW = self.st.imgWidth;
						obj.iH = self.st.imgHeight;
					}
				}
			}
			if(pushToSlides) {
				self.slides.push(obj);
			}
			if(obj.images.length === 0) {
				obj.isLoaded = true;
				obj.isRendered = false;
				obj.isLoading = false;
				obj.images = null;
			}
			return obj;
		},
		_bindKeyboardNav: function() {
			var self = this,
				interval,
				keyCode,
				onKeyboardAction = function (keyCode) {
					if(keyCode === 37) {
						self.prev();
					} else if (keyCode === 39) {
						self.next();
					}
				};

			self._doc.on('keydown' + self.ns, function(e) {
				if(!self._isDragging) {
					keyCode = e.keyCode;
					if(keyCode === 37 || keyCode === 39) {
						if(!interval) {
							onKeyboardAction(keyCode);
							interval = setInterval(function() {
								onKeyboardAction(keyCode);
							}, 700);
						}
					}
				}
			}).on('keyup' + self.ns, function(e) {
				if(interval) {
					clearInterval(interval); 
					interval = null;
				}
			});

			
			
		},




		goTo: function(id, notUserAction) {
			var self = this;
			if(id !== self.currSlideId) {
				self._moveTo(id,self.st.transitionSpeed, true, !notUserAction);
			}
		},
		destroy: function(remove) {
			var self = this;
			self.ev.trigger('rsBeforeDestroy');
			self._doc.off('keydown' +self.ns+ ' keyup' + self.ns + ' ' + self._moveEvent +' '+ self._upEvent );
			self._slidesContainer.off(self._downEvent + ' click');	
			self.slider.data('royalSlider', null);
			$.removeData(self.slider, 'royalSlider');
			$(window).off('resize' + self.ns);
			if(remove) {
				self.slider.remove();
			}
			self.slides = null;
			self.slider = null;
			self.ev = null;
		},
		_updateBlocksContent: function(beforeTransition, getId) {
			var self = this,
				item,
				i,
				n,
				pref,
				group,
				groupId,
				slideCode,
				loop = self._loop,
				numSlides = self.numSlides;
			if(!isNaN(getId) ) {
				return getCorrectLoopedId(getId);
			}


			var id = self.currSlideId;
			var groupOffset;
			
			var itemsOnSide = beforeTransition ? (Math.abs(self._prevSlideId - self.currSlideId) >= self.numSlides - 1 ? 0 : 1) : self._numPreloadImages;
			var itemsToCheck = Math.min(2, itemsOnSide); 
			
			var updateAfter = false;
			var updateBefore = false;
			var tempId;


			
			for(i = id; i < id + 1 + itemsToCheck; i++) {
				tempId = getCorrectLoopedId(i);
				item = self.slides[tempId];
				if(item && (!item.isAdded || !item.positionSet) ) {
					updateAfter = true;
					break;
				}
			}
			for(i = id - 1; i > id - 1 - itemsToCheck; i--) {
				tempId = getCorrectLoopedId(i);
				item = self.slides[tempId];
				if(item && (!item.isAdded || !item.positionSet) ) {
					updateBefore = true;
					break;
				}
			}
			if(updateAfter) {
				for(i = id; i < id + itemsOnSide + 1; i++) {
					tempId = getCorrectLoopedId(i);
					groupOffset = Math.floor( (self._realId - (id - i)) / self.numSlides) * self.numSlides;
					item = self.slides[tempId];
					if(item) {
						updateItem(item, tempId);	
					}
				}
			}
			if(updateBefore) {
				for(i = id - 1; i > id - 1 - itemsOnSide; i--) {
					tempId = getCorrectLoopedId(i);
					groupOffset = Math.floor( (self._realId - (id - i) ) / numSlides) * numSlides;
					item = self.slides[tempId];
					if(item) {
						updateItem(item, tempId);
					}
				}
			}
			if(!beforeTransition) {
				var start = id;
				var distance = itemsOnSide;
				var min = getCorrectLoopedId(id - itemsOnSide);
				var max = getCorrectLoopedId(id + itemsOnSide);
				
				var nmin = min > max ? 0 : min;
				
				for (i = 0; i < numSlides; i++) { 
					if(min > max) {
						if(i > min - 1) {
							continue;
						}
					}
					if(i < nmin || i > max) {
						item = self.slides[i];
						if(item && item.holder) {
							item.holder.detach();
							item.isAdded = false;
						}     
					}                               
				}   
			}

			
			
				
				
			function updateItem(item , i, slideCode) {

				if(!item.isAdded) {
					if(!slideCode)
						slideCode = self.slidesJQ[i];

					if(!item.holder) {
						slideCode = self.slidesJQ[i] = $(slideCode);
						item.holder = slideCode;
					} else {
						slideCode = item.holder;
					}

					item.appendOnLoaded = false;

					
					updatePos(i, item, slideCode);
					addContent(i, item);
					self._addBlockToContainer(item, slideCode, beforeTransition);
					item.isAdded = true;
				} else {
					addContent(i, item);
					updatePos(i, item);
				}
			}
			function addContent(i, item) {
				if(!item.contentAdded) {
					self.setItemHtml(item, beforeTransition);
					if(!beforeTransition) {
						item.contentAdded = true;
					}
					
				}
			}
			function updatePos(i, item, slideCode) {
				if(self._isMove) {
					if(!slideCode) {
						slideCode = self.slidesJQ[i];
					}

					slideCode.css(self._reorderProp, (i + self._idOffset + groupOffset) * self._slideSize);
				}
			}
			function getCorrectLoopedId(index) {
				var changed = false;
				if(loop) {
					if(index > numSlides - 1) {
						return getCorrectLoopedId(index - numSlides);
					} else  if(index < 0) {
						return getCorrectLoopedId(numSlides + index);
					}
				}
				return index;
			}
			
		},

		/**
		 * Sets or loads HTML for specified slide
		 * @param {Object} currSlideObject  holds data about curr slide (read about rsAfterParseNode for more info)
		 * @param {Boolean} beforeTransition determines if setItemHTML method is called before or after transition
		 */
		setItemHtml: function(currSlideObject, beforeTransition) {
			var self = this;

			var parseDataAndLoad = function() {
				if(!currSlideObject.images) {
					currSlideObject.isRendered = true;
					currSlideObject.isLoaded = true;
					currSlideObject.isLoading = false;
					appendContent(true);
					return;
				}
				if(currSlideObject.isLoading) {
					return;
				}
				
				var el,
					isRoot;
				if(currSlideObject.content.hasClass('rsImg') ) {
					el = currSlideObject.content;
					isRoot = true;
				} else {
					el = currSlideObject.content.find('.rsImg:not(img)');
				}
				if(el && !el.is('img')) {
					el.each(function() {
						var item = $(this),
							newEl = '<img class="rsImg" src="'+ ( item.is('a') ? item.attr('href') : item.text() ) +'" />';

						if(!isRoot) {
							item.replaceWith( newEl );
						} else {
							currSlideObject.content = $(newEl);
						}
					});
				}
				
				el = isRoot ? currSlideObject.content : currSlideObject.content.find('img.rsImg');
				setPreloader();
				
				el.eq(0).addClass('rsMainSlideImage');
				if(currSlideObject.iW && currSlideObject.iH) {
					if(!currSlideObject.isLoaded) {
						self._resizeImage( currSlideObject );
					}
					appendContent();
				}

				currSlideObject.isLoading = true;
				var newEl;

				var eNames = 'load.rs error.rs';
				if(currSlideObject.isBig) {
					$('<img />').on(eNames, function(e){
						$(this).off(eNames);
						onLoad( [this], true );
					}).attr('src', currSlideObject.image);
				} else {
					currSlideObject.loaded = [];
					currSlideObject.numStartedLoad = 0;
					var onLoaded = function(e) {
						$(this).off(eNames);
						currSlideObject.loaded.push( this );
						if(currSlideObject.loaded.length === currSlideObject.numStartedLoad) {
							onLoad( currSlideObject.loaded, false );
						}
					};
					for(var i = 0; i < currSlideObject.images.length; i++) {
						var image = $('<img />');
						currSlideObject.numStartedLoad++;
						image.on('load.rs error.rs', onLoaded).attr('src', currSlideObject.images[i]);
					}
				}
			};

			var onLoad = function($images, isBig) {
				if($images.length) {
					var img = $images[0],
					src = img.src;

					if(isBig !== currSlideObject.isBig) {
						var c = currSlideObject.holder.children();
						if(c && c.length > 1) {
							removePreloader();
						}
						return;
					}

					if(currSlideObject.iW && currSlideObject.iH) {
						imageLoadingComplete();
						return;
					}
					currSlideObject.iW = img.width;
					currSlideObject.iH = img.height;
					if(currSlideObject.iW && currSlideObject.iH) {
						imageLoadingComplete();
						return;
					} else {
						// if no size, try again
						var loader = new Image();
						loader.onload = function() {
							if(loader.width) {
								currSlideObject.iW = loader.width;
								currSlideObject.iH = loader.height;
								imageLoadingComplete();
							} else {
								setTimeout(function() {
									if(loader.width) {
										currSlideObject.iW = loader.width;
										currSlideObject.iH = loader.height;
									}

									// failed to get size on last tier, just output image
									imageLoadingComplete();
								}, 1000);
							}
						};
						loader.src = img.src;
					}
				} else {
					imageLoadingComplete();
				}
			};

			var imageLoadingComplete = function () {
				currSlideObject.isLoaded = true;
				currSlideObject.isLoading = false;

				appendContent();
				removePreloader();
				triggerLoaded();
			};

			var waitForTransition = function () {
				if(!self._isMove && currSlideObject.images && currSlideObject.iW && currSlideObject.iH) {
					parseDataAndLoad();
					return;
				}
				currSlideObject.holder.isWaiting = true;
				setPreloader();
				currSlideObject.holder.slideId = -99;
			};
			
			var appendContent = function() {
				if(!currSlideObject.isAppended && self.ev) {

					var visibleNearby = self.st.visibleNearby,
					bId = currSlideObject.id - self._newSlideId;
					if(!beforeTransition && !currSlideObject.appendOnLoaded && self.st.fadeinLoadedSlide  && ( bId === 0 || ( (visibleNearby || self._isAnimating || self._isDragging) && (bId === -1 || bId === 1) ) ) ) {
						var css = {
							visibility: 'visible', 
							opacity: 0
						};
						css[self._vendorPref + 'transition'] = 'opacity 400ms ease-in-out';
						currSlideObject.content.css(css);

						setTimeout(function() {
							currSlideObject.content.css('opacity', 1);
						}, 16);
					}

					if(currSlideObject.holder.find('.rsPreloader').length) {
						currSlideObject.holder.append( currSlideObject.content );
					} else {
						currSlideObject.holder.html( currSlideObject.content );
					}
					

					currSlideObject.isAppended = true;
					if(currSlideObject.isLoaded) {
						self._resizeImage(currSlideObject);
						triggerLoaded();
					}
					if(!currSlideObject.sizeReady) {
						currSlideObject.sizeReady = true;
						setTimeout(function() {
							// triggers after content is added, usually is true when page is refreshed from cache
							self.ev.trigger('rsMaybeSizeReady', currSlideObject);
						}, 100);
					}
					
				}
			};
			var triggerLoaded = function () {
				if(!currSlideObject.loadedTriggered && self.ev) {
					currSlideObject.isLoaded = currSlideObject.loadedTriggered = true;
					currSlideObject.holder.trigger('rsAfterContentSet');
					self.ev.trigger('rsAfterContentSet', currSlideObject);
				}
			};
			var setPreloader = function () {
				if(self.st.usePreloader)
					currSlideObject.holder.html(self._preloader.clone());
			};
			var removePreloader = function (now) {
				if(self.st.usePreloader) {
					var preloader = currSlideObject.holder.find('.rsPreloader');
					if(preloader.length) {
						preloader.remove();
					}
				}
			};

			if(currSlideObject.isLoaded) {
				appendContent();
				return;
			} else {
				if(beforeTransition) {
					waitForTransition();
				} else {
					parseDataAndLoad();
				}
			}

		},
		_addBlockToContainer: function(slideObject, content, dontFade) {
			var self = this;
			var holder = slideObject.holder;
			var bId = slideObject.id - self._newSlideId;
			var visibleNearby = false;

			self._slidesContainer.append(holder);
			slideObject.appendOnLoaded = false;
		},
	
		_onDragStart:function(e, isThumbs) {
			var self = this,
				point,
				wasAnimating,
				isTouch = (e.type === 'touchstart');


			self._isTouchGesture = isTouch;	

			self.ev.trigger('rsDragStart');
			if($(e.target).closest('.rsNoDrag', self._currHolder).length) {
				self.dragSuccess = false;
				return true;
			}


			if(!isThumbs) {
				if(self._isAnimating) {
					self._wasAnimating = true;

					self._stopAnimation();
				}
			}
			self.dragSuccess = false;
			if(self._isDragging) {
				if(isTouch) {
					self._multipleTouches = true;
				}
				return;
			} else {
				if(isTouch) {
					self._multipleTouches = false;
				}
			}

			self._setGrabbingCursor();
			
			if(isTouch) {
				//parsing touch event
				var touches = e.originalEvent.touches;
				if(touches && touches.length > 0) {
					point = touches[0];
					if(touches.length > 1) {
						self._multipleTouches = true;
					}
				}					
				else {	
					return;						
				}
			} else {
				e.preventDefault();				
				point = e;
				if(self.msEnabled) point = point.originalEvent;		
			}

			self._isDragging = true;
			self._doc.on(self._moveEvent, function(e) { self._onDragMove(e, isThumbs); })
						.on(self._upEvent, function(e) { self._onDragRelease(e, isThumbs); });
			
			self._currMoveAxis = '';
			self._hasMoved = false;
			self._pageX = point.pageX;
			self._pageY = point.pageY;
			self._startPagePos = self._accelerationPos = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal) ? point.pageX : point.pageY;
			
			self._horDir = 0;
			self._verDir = 0;

			self._currRenderPosition = !isThumbs ? self._sPosition : self._thumbsPosition;

			self._startTime = new Date().getTime();
			if(isTouch) {
				self._sliderOverflow.on(self._cancelEvent, function(e) { self._onDragRelease(e, isThumbs); });	
			}
		},
		_renderMovement:function(point, isThumbs) {
			var self = this;
			if(self._checkedAxis) {

				var timeStamp = self._renderMoveTime,
					deltaX = point.pageX - self._pageX,
					deltaY = point.pageY - self._pageY,
					newX = self._currRenderPosition + deltaX,
					newY = self._currRenderPosition + deltaY,
					isHorizontal = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
					newPos = isHorizontal ? newX : newY,
					mAxis = self._currMoveAxis;

				self._hasMoved = true;
				self._pageX = point.pageX;
				self._pageY = point.pageY;

				if(mAxis === 'x' && deltaX !== 0) {
					self._horDir = deltaX > 0 ? 1 : -1;
				} else if(mAxis === 'y' && deltaY !== 0) {
					self._verDir = deltaY > 0 ? 1 : -1;
				}

				var pointPos = isHorizontal ? self._pageX : self._pageY,
					deltaPos = isHorizontal ? deltaX : deltaY;
				if(!isThumbs) {
					if(!self._loop) {
						if(self.currSlideId <= 0) {
							if(pointPos - self._startPagePos > 0) {
								newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
							}
						}
						if(self.currSlideId >= self.numSlides - 1) {
							if(pointPos - self._startPagePos < 0) {
								newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
							}
						}
					}
				} else {
					if(newPos > self._thumbsMinPosition) {
						newPos = self._currRenderPosition + deltaPos * self._lastItemFriction;
					} else if(newPos < self._thumbsMaxPosition) {
						newPos = self._currRenderPosition + deltaPos * self._lastItemFriction ;
					}
				}

				self._currRenderPosition = newPos;
				
				if (timeStamp - self._startTime > 200) {
					self._startTime = timeStamp;
					self._accelerationPos = pointPos;						
				}

				if(!isThumbs) {
					if(self._isMove) {
						self._setPosition(self._currRenderPosition);
					}
				} else {
					self._setThumbsPosition(self._currRenderPosition);
				}
			}
			
		},
		_onDragMove:function(e, isThumbs) {
			var self = this,
				point,
				isTouch = (e.type === 'touchmove');

			if(self._isTouchGesture && !isTouch) {
				return;
			}

			if(isTouch) {
				if(self._lockAxis) {
					return;
				}	
				var touches = e.originalEvent.touches;
				if(touches) {
					if(touches.length > 1) {
						return;
					} else {
						point = touches[0];	
					}
				} else {
					return;
				}
			} else {
				point = e;
				if(self.msEnabled) point = point.originalEvent;	
			}
			

			if(!self._hasMoved) {
				if(self._useCSS3Transitions) {
					(!isThumbs ? self._slidesContainer : self._thumbsContainer).css((self._vendorPref + self._TD), '0s');
				}
				(function animloop(){
					if(self._isDragging) {
						self._animFrame = requestAnimationFrame(animloop);
						if(self._renderMoveEvent)
							self._renderMovement(self._renderMoveEvent, isThumbs);
					}
					
				})();
			}
				
			if(!self._checkedAxis) {
				
				var dir = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal),
					diff = (Math.abs(point.pageX - self._pageX) - Math.abs(point.pageY - self._pageY) ) - (dir ? -7 : 7);

				if(diff > 7) {
					// hor movement
					if(dir) {
						e.preventDefault();
						self._currMoveAxis = 'x';
					} else if(isTouch) {
						self._completeGesture();
						return;
					} 
					self._checkedAxis = true;
				} else if(diff < -7) {
					// ver movement
					if(!dir) {
						e.preventDefault();
						self._currMoveAxis = 'y';
					} else if(isTouch) {
						self._completeGesture();
						return;
					} 
					self._checkedAxis = true;
				}
				return;
			}
			
			e.preventDefault();	
			self._renderMoveTime = new Date().getTime();
			self._renderMoveEvent = point;
		},
		_completeGesture: function() {
			var self = this;
			self._lockAxis = true;
			self._hasMoved = self._isDragging = false;
			self._onDragRelease();
		},
		_onDragRelease:function(e, isThumbs) {
			var self = this,
				totalMoveDist,
				accDist,
				duration,
				v0,
				newPos,
				newDist,
				newDuration,
				blockLink,
				isTouch = (e.type === 'touchend' || e.type === 'touchcancel');


			if(self._isTouchGesture && !isTouch) {
				return;
			}
			self._isTouchGesture = false;
			self.ev.trigger('rsDragRelease');

			self._renderMoveEvent = null;
			self._isDragging = false;
			self._lockAxis = false;
			self._checkedAxis = false;
			self._renderMoveTime = 0;
			cancelAnimationFrame(self._animFrame);
			if(self._hasMoved) {
				if(!isThumbs) {
					if(self._isMove) {
						self._setPosition(self._currRenderPosition);
					}
				} else {
					self._setThumbsPosition(self._currRenderPosition);
				}
			}


			self._doc.off(self._moveEvent).off(self._upEvent);

			if(isTouch) {
				self._sliderOverflow.off(self._cancelEvent);	
			}

			
			self._setGrabCursor();
			if (!self._hasMoved && !self._multipleTouches) {
				if(isThumbs && self._thumbsEnabled) {
					var item = $(e.target).closest('.rsNavItem');
					if(item.length) {
						self.goTo(item.index());
					}	
					return;
				}
			}
			var orient = (!isThumbs ? self._slidesHorizontal : self._thumbsHorizontal);
			if(!self._hasMoved || (self._currMoveAxis === 'y' && orient) || (self._currMoveAxis === 'x' && !orient) ) {
				if(!isThumbs && self._wasAnimating) {
					self._wasAnimating = false;
					if(!self.st.navigateByClick) {
						self.dragSuccess = true;
					} else {
						self._mouseNext( (self.msEnabled ? e.originalEvent : e) );
						self.dragSuccess = true;
						return;
					}
				} else {
					self._wasAnimating = false;
					self.dragSuccess = false;
					return;
				}
				
			} else {
				self.dragSuccess = true;
			}

			self._wasAnimating = false;
			
			
			self._currMoveAxis = '';

			
			function getCorrectSpeed(newSpeed) {
				if(newSpeed < 100) {
					return 100;
				} else if(newSpeed > 500) {
					return 500;
				} 
				return newSpeed;
			}
			function returnToCurrent(isSlow, v0) {
				if(self._isMove || isThumbs) {

					newPos = (-self._realId - self._idOffset) * self._slideSize;
					newDist = Math.abs(self._sPosition  - newPos);
					self._currAnimSpeed = newDist / v0;
					if(isSlow) {
						self._currAnimSpeed += 250; 
					}
					self._currAnimSpeed = getCorrectSpeed(self._currAnimSpeed);

					self._animateTo(newPos, false);
				}
			}

			var snapDist = self.st.minSlideOffset,
				point = isTouch ? e.originalEvent.changedTouches[0] : (self.msEnabled ? e.originalEvent : e),
				pPos = orient ? point.pageX : point.pageY,
				sPos = self._startPagePos,
				axPos = self._accelerationPos,
				axCurrItem = self.currSlideId,
				axNumItems = self.numSlides,
				dir = orient ? self._horDir : self._verDir,
				loop = self._loop,
				changeHash = false,
				distOffset = 0;
			
			totalMoveDist = Math.abs(pPos - sPos);
			accDist = pPos - axPos;


			duration = (new Date().getTime()) - self._startTime;
			v0 = Math.abs(accDist) / duration;	

			if(dir === 0 || axNumItems <= 1) {
				returnToCurrent(true, v0);
				return;
			}

			if(!loop && !isThumbs) {
				if(axCurrItem <= 0) {
					if(dir > 0) {
						returnToCurrent(true, v0);
						return;
					}
				} else if(axCurrItem >= axNumItems - 1) {
					if(dir < 0) {
						returnToCurrent(true, v0);
						return;
					}
				}
			}

			if(!isThumbs) {
				if(sPos + snapDist < pPos) {
					if(dir < 0) {		
						returnToCurrent(false, v0);
						return;					
					}
					self._moveTo('prev', getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset + 1) * self._slideSize) / v0), changeHash, true, true);
				} else if(sPos - snapDist > pPos) {
					if(dir > 0) {		
						returnToCurrent(false, v0);
						return;					
					}
					self._moveTo('next', getCorrectSpeed(Math.abs(self._sPosition  - (-self._realId - self._idOffset - 1) * self._slideSize) / v0), changeHash, true, true);
				} else {
					returnToCurrent(false, v0);
				}
			} else {
				newPos = self._thumbsPosition;
				var transitionSpeed;
				
				if(newPos > self._thumbsMinPosition) {
					newPos = self._thumbsMinPosition;
				} else if(newPos < self._thumbsMaxPosition) {
					newPos = self._thumbsMaxPosition;
				} else {
					var friction = 0.003,
						S = (v0 * v0) / (friction * 2),
						minXDist = -self._thumbsPosition,
						maxXDist = self._thumbsContainerSize - self._thumbsViewportSize + self._thumbsPosition;

					if (accDist > 0 && S > minXDist) {
						minXDist = minXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
						v0 = v0 * minXDist / S;
						S = minXDist;
					} else if (accDist < 0 && S > maxXDist) {
						maxXDist = maxXDist + self._thumbsViewportSize / (15 / (S / v0 * friction));
						v0 = v0 * maxXDist / S;
						S = maxXDist;
					}




					transitionSpeed =  Math.max(Math.round(v0 / friction), 50);
					newPos = newPos + S * (accDist < 0 ? -1 : 1);


					if(newPos > self._thumbsMinPosition) {
						self._animateThumbsTo(newPos, transitionSpeed, true, self._thumbsMinPosition, 200);
						return;
					} else if(newPos < self._thumbsMaxPosition) {
						self._animateThumbsTo( newPos, transitionSpeed, true, self._thumbsMaxPosition, 200);
						return;
					}
				}

				self._animateThumbsTo(newPos, transitionSpeed, true);

			}
		},
		_setPosition: function(pos) {
			var self = this;
			pos = self._sPosition = pos;
			if(self._useCSS3Transitions) {
				self._slidesContainer.css(self._xProp, self._tPref1 + ( self._slidesHorizontal ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 );		
			} else {
				self._slidesContainer.css(self._slidesHorizontal ? self._xProp : self._yProp, pos);
			}
		},
		
		
		updateSliderSize: function(force) {
			var self = this,
				newWidth,
				newHeight;

			if(self.st.autoScaleSlider) {
				var asw = self.st.autoScaleSliderWidth,
					ash = self.st.autoScaleSliderHeight;

				if(self.st.autoScaleHeight) {
					newWidth = self.slider.width();
					if(newWidth != self.width) {
						self.slider.css("height", newWidth * (ash / asw) );
						newWidth = self.slider.width();
					}	
					newHeight = self.slider.height();
				} else {
					newHeight = self.slider.height();
					if(newHeight != self.height) {
						self.slider.css("width", newHeight * (asw / ash));
						newHeight = self.slider.height();
					}		
					newWidth = self.slider.width();
				}
			
			} else {
				newWidth = self.slider.width();
				newHeight = self.slider.height();
			}
			


			if(force || newWidth != self.width || newHeight != self.height) {
				self.width = newWidth;
				self.height = newHeight;

				self._wrapWidth = newWidth;
				self._wrapHeight = newHeight;

				self.ev.trigger('rsBeforeSizeSet');
				self.ev.trigger('rsAfterSizePropSet');

				self._sliderOverflow.css({
					width: self._wrapWidth,
					height: self._wrapHeight
				});


				self._slideSize = (self._slidesHorizontal ? self._wrapWidth : self._wrapHeight) + self.st.slidesSpacing;
				

				self._imagePadding = self.st.imageScalePadding;
				var item,
					slideItem,
					i,
					img;
				for(i = 0; i < self.slides.length; i++) {
					item = self.slides[i];
					item.positionSet = false;

					if(item && item.images && item.isLoaded) {
						item.isRendered = false;
						self._resizeImage(item);
					} 
				}
				if(self._cloneHolders) {
					for(i = 0; i < self._cloneHolders.length; i++) {
						item = self._cloneHolders[i];
						item.holder.css(self._reorderProp, (item.id + self._idOffset) * self._slideSize);
					}
				}
				
				self._updateBlocksContent();

				if(self._isMove) {
					if(self._useCSS3Transitions) {
						self._slidesContainer.css(self._vendorPref + 'transition-duration', '0s');
					}
					self._setPosition( (-self._realId - self._idOffset) * self._slideSize);
				}
				self.ev.trigger('rsOnUpdateNav');
			}
			self._sliderOffset = self._sliderOverflow.offset();
			self._sliderOffset = self._sliderOffset[self._reorderProp];


		},
		
		/**
		 * Adds slide
		 * @param  {jQuery object or raw HTML} htmltext 
		 * @param  {int} index    (optional) Index where item should be added (last item is removed of not specified)
		 */
		appendSlide: function(htmltext, index) {
			var self = this,
				parsedSlide = self._parseNode(htmltext);

			if(isNaN(index) || index > self.numSlides) {
				index = self.numSlides;
			}
			self.slides.splice(index, 0, parsedSlide);
			self.slidesJQ.splice(index, 0, '<div style="'+ (self._isMove ? 'position:absolute;' : self._opacityCSS ) +'" class="rsSlide"></div>');

			if(index < self.currSlideId) {
				self.currSlideId++;
			}
			self.ev.trigger('rsOnAppendSlide', [parsedSlide, index]);
			
			self._refreshSlides(index);

			if(index === self.currSlideId) {
				self.ev.trigger('rsAfterSlideChange');
			}
		},

		/**
		 * Removes slide
		 * @param  {int} Index of item that should be removed
		 */
		removeSlide: function(index) {
			var self = this,
				slideToRemove = self.slides[index];

			if(slideToRemove) {
				if(slideToRemove.holder) {
					slideToRemove.holder.remove();
				}
				if(index < self.currSlideId) {
					self.currSlideId--;
				}
				self.slides.splice(index, 1);
				self.slidesJQ.splice(index, 1);

				self.ev.trigger('rsOnRemoveSlide', [index]);
				self._refreshSlides(index);

				if(index === self.currSlideId) {
					self.ev.trigger('rsAfterSlideChange');
				}
			}
		},
		_refreshSlides: function(refreshIndex) {

			// todo: optimize this stuff
			var self = this;

			var oldNumSlides = self.numSlides;
			var numLoops = self._realId <= 0 ? 0 : Math.floor(self._realId / oldNumSlides);

			self.numSlides = self.slides.length;
			if(self.numSlides === 0) {
				self.currSlideId = self._idOffset = self._realId = 0;
				self.currSlide = self._oldHolder = null;
			} else {
				self._realId = numLoops * self.numSlides + self.currSlideId;
			}

			for(var i = 0; i < self.numSlides; i++) {
				self.slides[i].id = i;
			}

			self.currSlide = self.slides[self.currSlideId];
			self._currHolder = self.slidesJQ[self.currSlideId];

			if(self.currSlideId >= self.numSlides) {
				self.goTo(self.numSlides - 1);
			} else if(self.currSlideId < 0) {
				self.goTo(0);
			}

			self._refreshNumPreloadImages();

			if(self._isMove && self._loop) {
				self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
			}
			if(self._refreshSlidesTimeout) {
				clearTimeout(self._refreshSlidesTimeout);
			}


			self._refreshSlidesTimeout = setTimeout(function() {
				if(self._isMove) {
					self._setPosition( (-self._realId - self._idOffset) * self._slideSize);	
				}
				self._updateBlocksContent();
				if(!self._isMove) {
					self._currHolder.css({
						display: 'block',
						opacity: 1
					});
				}
				
			}, 14);
			self.ev.trigger('rsOnUpdateNav');
		},
		_setGrabCursor:function() {	
			var self = this;
			if(self._hasDrag && self._isMove) {
				if(self._grabCursor) {
					self._sliderOverflow.css('cursor', self._grabCursor);
				} else {
					self._sliderOverflow.removeClass('grabbing-cursor');
					self._sliderOverflow.addClass('grab-cursor');	
				}
			}
		},
		_setGrabbingCursor:function() {		
			var self = this;
			if(self._hasDrag && self._isMove) {
				if(self._grabbingCursor) {
					self._sliderOverflow.css('cursor', self._grabbingCursor);
				} else {
					self._sliderOverflow.removeClass('grab-cursor');
					self._sliderOverflow.addClass('grabbing-cursor');	
				}	
			}
		},
		next: function(notUserAction) {
			var self = this;
			self._moveTo('next',  self.st.transitionSpeed, true, !notUserAction);
		},
		prev: function(notUserAction) {
			var self = this;
			self._moveTo('prev', self.st.transitionSpeed, true, !notUserAction);
		},
		_moveTo:function(type,  speed, inOutEasing, userAction, fromSwipe) {
			var self = this,
				newPos,
				difference,
				i,
				newItemId;
			
			
			self.ev.trigger('rsBeforeMove', [type, userAction]);
			if(type === 'next') {
				newItemId = self.currSlideId+1;
			} else if(type === 'prev') {
				newItemId = self.currSlideId-1;
			} else {
				newItemId = type = parseInt(type, 10);
			}

			if(!self._loop) {
				if(newItemId < 0) {
					self._doBackAndForthAnim('left', !userAction);
					return;
				} else if(newItemId >= self.numSlides ) {
					self._doBackAndForthAnim('right', !userAction);
					return;
				}
			}
			
			if(self._isAnimating) {
				self._stopAnimation(true);
				inOutEasing = false;
			}

			difference = newItemId - self.currSlideId;



			self._prevSlideId = self.currSlideId;
			var prevId = self.currSlideId;
			var id = self.currSlideId + difference;
			var realId = self._realId;
			var temp;
			var delayed;
			if(self._loop) {
				id = self._updateBlocksContent(false, id);
				realId += difference;
			} else {
				realId = id;
			}
			self._newSlideId = id;

			self._oldHolder = self.slidesJQ[self.currSlideId];

			
			self._realId = realId;
			self.currSlideId = self._newSlideId;

			self.currSlide = self.slides[self.currSlideId];
			self._currHolder = self.slidesJQ[self.currSlideId];

			
			var checkDist = self.st.slidesDiff;
			var next = Boolean(difference > 0);
			var absDiff = Math.abs(difference);
			var g1 = Math.floor( prevId / self._numPreloadImages);
			var g2 = Math.floor( ( prevId + (next ? checkDist : -checkDist  ) ) / self._numPreloadImages);
			var biggest = next ? Math.max(g1,g2) : Math.min(g1,g2);
			var biggestId = biggest * self._numPreloadImages +  ( next ? (self._numPreloadImages - 1) : 0 );
			if(biggestId > self.numSlides - 1) {
				biggestId = self.numSlides - 1;
			} else if(biggestId < 0) {
				biggestId = 0;
			}
			var toLast =  next ? (biggestId - prevId) :  (prevId - biggestId);
			if(toLast > self._numPreloadImages) {
				toLast = self._numPreloadImages;
			}
			if(absDiff > toLast + checkDist) {
				self._idOffset +=  ( absDiff - (toLast + checkDist) ) * ( next ? -1 : 1 );
				speed = speed * 1.4;
				for(i = 0; i < self.numSlides; i++) {
					self.slides[i].positionSet = false;
				}
			}
			self._currAnimSpeed = speed;

			self._updateBlocksContent(true);
			if(!fromSwipe) {
				delayed = true;
			}


			newPos = (-realId - self._idOffset) * self._slideSize;

			

			if(delayed) {
				setTimeout(function() {
					self._isWorking = false;
					self._animateTo(newPos, type, false, inOutEasing);
					self.ev.trigger('rsOnUpdateNav');
				}, 0);
			} else {
				self._animateTo(newPos, type, false, inOutEasing);
				self.ev.trigger('rsOnUpdateNav');
			}
			
			
			function isSetToCurrent(testId) {
				if(testId < 0) {
					testId = self.numSlides + testId;
				} else if(testId > self.numSlides - 1) {
					testId = testId - self.numSlides;
				}
				if(testId !== self.currSlideId) {
					return false;
				}
				return true;
			}
			
		},
		_updateArrowsNav: function() {
			var self = this,
				arrDisClass = 'rsArrowDisabled';
			if(self.st.arrowsNav) {
				if(self.numSlides <= 1) {
					self._arrowLeft.css('display', 'none');
					self._arrowRight.css('display', 'none');
					return;
				} else {
					self._arrowLeft.css('display', 'block');
					self._arrowRight.css('display', 'block');
				}
				if(!self._loop && !self.st.loopRewind) {
					if(self.currSlideId === 0) {
						self._arrowLeft.addClass(arrDisClass);
					} else {
						self._arrowLeft.removeClass(arrDisClass);
					}
					if(self.currSlideId === self.numSlides - 1) {
						self._arrowRight.addClass(arrDisClass);
					} else {
						self._arrowRight.removeClass(arrDisClass);
					}
				}
			}
		},
		_animateTo:function(pos, dir,  loadAll, inOutEasing, customComplete) {
			var self = this,
				moveProp,
				oldBlock,
				animBlock;

			var animObj = {};
			if(isNaN(self._currAnimSpeed)) {
				self._currAnimSpeed = 400;
			} 
			


			self._sPosition = self._currRenderPosition = pos;

			self.ev.trigger('rsBeforeAnimStart');

			if(!self._useCSS3Transitions) {
				if(self._isMove) {
					animObj[self._slidesHorizontal ? self._xProp : self._yProp] = pos + 'px';


					self._slidesContainer.animate(animObj, self._currAnimSpeed, /*'easeOutQuart'*/ inOutEasing ? self.st.easeInOut : self.st.easeOut);
				} else {
					oldBlock = self._oldHolder;
					animBlock = self._currHolder;					

					animBlock.stop(true, true).css({
						opacity: 0,
						display: 'block',
						zIndex: self._fadeZIndex
					});
					self._currAnimSpeed = self.st.transitionSpeed;
					animBlock.animate({opacity: 1}, self._currAnimSpeed, self.st.easeInOut);

					
					clearTimeouts();
					if(oldBlock) {
						oldBlock.data('rsTimeout', setTimeout(function() {
							oldBlock.stop(true, true).css({
								opacity: 0,
								display: 'none',
								zIndex: 0
							});
						}, self._currAnimSpeed + 60) );
					}
				}
				
			} else {
				if(self._isMove) {
					
					

						self._currAnimSpeed = parseInt(self._currAnimSpeed, 10);
						var td = self._vendorPref + self._TD;
						var ttf = self._vendorPref + self._TTF;

						animObj[td] = self._currAnimSpeed+'ms';
						animObj[ttf] = inOutEasing ? $.rsCSS3Easing[self.st.easeInOut] : $.rsCSS3Easing[self.st.easeOut];
						
						self._slidesContainer.css(animObj);
					if(inOutEasing || !self.hasTouch) {
						setTimeout(function() {
							self._setPosition(pos);
						}, 5);
					} else {
						self._setPosition(pos);
					} 
					
					

				} else {
					//self._currAnimSpeed = 10
					self._currAnimSpeed = self.st.transitionSpeed;
					oldBlock = self._oldHolder;
					animBlock = self._currHolder;		
					if(animBlock.data('rsTimeout')) {
						animBlock.css('opacity', 0);
					}
					clearTimeouts();
					if(oldBlock) {
						//if(oldBlock)
						oldBlock.data('rsTimeout', setTimeout(function() {
							animObj[self._vendorPref + self._TD] = '0ms';
							animObj.zIndex = 0;
							animObj.display = 'none';
							oldBlock.data('rsTimeout', '');
							oldBlock.css(animObj);
							setTimeout(function() {
								oldBlock.css('opacity', 0);
							}, 16);
						}, self._currAnimSpeed + 60) );
					}

					animObj.display = 'block';
					animObj.zIndex = self._fadeZIndex;
					animObj.opacity = 0;
					animObj[self._vendorPref + self._TD] = '0ms';
					animObj[self._vendorPref + self._TTF] = $.rsCSS3Easing[self.st.easeInOut];
					animBlock.css(animObj);
					animBlock.data('rsTimeout', setTimeout(function() {
						//animBlock.css('opacity', 0);
						animBlock.css(self._vendorPref + self._TD,  self._currAnimSpeed+'ms');

						//oldBlock.css(self._vendorPref + self._TD,  '0ms');
						animBlock.data('rsTimeout', setTimeout(function() {
							animBlock.css('opacity', 1);
							animBlock.data('rsTimeout', '');
						}, 20) );
					}, 20) );
				}
			}
			self._isAnimating = true;
			if(self.loadingTimeout) {
				clearTimeout(self.loadingTimeout);
			}
			if(customComplete) {
				self.loadingTimeout = setTimeout(function() {
					self.loadingTimeout = null;
					customComplete.call();

				}, self._currAnimSpeed + 60);
			} else {
				self.loadingTimeout = setTimeout(function() {
					self.loadingTimeout = null;
					self._animationComplete(dir);
				}, self._currAnimSpeed + 60);
			}

			function clearTimeouts() {
				var t;
				if(oldBlock) {
					t = oldBlock.data('rsTimeout');
					if(t) {
						if(oldBlock !== animBlock) {
							oldBlock.css({
									opacity: 0,
									display: 'none',
									zIndex: 0
								});
						}
						clearTimeout(t);
						oldBlock.data('rsTimeout', '');
					}
				}
				
				t = animBlock.data('rsTimeout');
				if(t) {
					clearTimeout(t);
					animBlock.data('rsTimeout', '');
				}
			}
		},
		_stopAnimation: function(noCSS3) {
			var self = this;
			self._isAnimating = false;
			clearTimeout(self.loadingTimeout);
			if(self._isMove) {

				if(!self._useCSS3Transitions) {
					self._slidesContainer.stop(true);
					self._sPosition = parseInt(self._slidesContainer.css(self._xProp), 10);
				} else if (!noCSS3) {
					var oldPos = self._sPosition;
					var newPos =  self._currRenderPosition = self._getTransformProp();
					self._slidesContainer.css((self._vendorPref + self._TD), '0ms');
					if(oldPos !==newPos) {
						self._setPosition(newPos);
					}
				}
			} else {
				// kung fu
				if(self._fadeZIndex > 20) {
					self._fadeZIndex = 10;
				} else {
					self._fadeZIndex++;
				}
			}
			
			
		},
		// Thanks to @benpbarnett
		_getTransformProp:function(){
			var self = this,
				transform = window.getComputedStyle(self._slidesContainer.get(0), null).getPropertyValue(self._vendorPref + 'transform'),			
				explodedMatrix = transform.replace(/^matrix\(/i, '').split(/, |\)$/g),
				isMatrix3d = (explodedMatrix[0].indexOf('matrix3d') === 0);
			return parseInt(explodedMatrix[(self._slidesHorizontal ? (isMatrix3d ? 12 : 4) : (isMatrix3d ? 13 : 5) )], 10);
		},
		_getCSS3Prop: function(pos, hor) {
			var self = this;
			return self._useCSS3Transitions ? self._tPref1 + ( hor ? (pos + self._tPref2 + 0) : (0 + self._tPref2 + pos) ) + self._tPref3 : pos;
		},
		_animationComplete: function(dir) {
			var self = this;
			if(!self._isMove) {
				self._currHolder.css('z-index', 0);
				self._fadeZIndex = 10;
			}
			self._isAnimating = false;
			
			self.staticSlideId = self.currSlideId;
			self._updateBlocksContent();


			self._slidesMoved = false;
			
			self.ev.trigger('rsAfterSlideChange');
		},
		_doBackAndForthAnim:function(type, userAction) {
			var self = this,
				newPos = (-self._realId - self._idOffset) * self._slideSize;

			if(self.numSlides === 0 || self._isAnimating) {
				return;
			} 
			if(self.st.loopRewind) {
				self.goTo(type === 'left' ? self.numSlides - 1 : 0, userAction);
				return;
			}

			if(self._isMove) {
				self._currAnimSpeed = 200;

				var allAnimComplete = function () {
					self._isAnimating = false;
				};
				var firstAnimComplete = function () {
					self._isAnimating = false;
					self._animateTo(newPos, '', false, true, allAnimComplete);
				};
				self._animateTo(newPos + (type === 'left' ? 30 : -30),'', false, true, firstAnimComplete);
			}
			
		},
		_resizeImage:function(slideObject, useClone) {

			var isRoot = true;
			if(slideObject.isRendered) {
				return;
			}
			var img = slideObject.content;
			var classToFind = 'rsMainSlideImage';
			var isVideo;
			var self = this,
				imgAlignCenter = self.st.imageAlignCenter,
				imgScaleMode = self.st.imageScaleMode,
				tempEl,
				bMargin;

			if(slideObject.videoURL) {
				classToFind = 'rsVideoContainer';
				if(imgScaleMode !== 'fill') {
					isVideo = true;
				} else {
					tempEl = img;
					if(!tempEl.hasClass(classToFind)) {
						tempEl = tempEl.find('.'+classToFind);
					}
					tempEl.css({width:'100%',height: '100%'});
					classToFind = 'rsMainSlideImage';
				}
			}
			if(!img.hasClass(classToFind)) {
				isRoot = false;
				img = img.find('.'+classToFind);
			}
			if(!img) {
				return;
			}

			var baseImageWidth = slideObject.iW,
				baseImageHeight = slideObject.iH;

			slideObject.isRendered = true;
			if(imgScaleMode === 'none' && !imgAlignCenter) {
				return;
			}
			if(imgScaleMode !== 'fill') {
				bMargin = self._imagePadding;
			} else {
				bMargin = 0;
			}
			//var block = img.parent('.block-inside').css('margin', bMargin);
			var containerWidth = self._wrapWidth - bMargin * 2,
				containerHeight = self._wrapHeight - bMargin * 2,
				hRatio,
				vRatio,
				ratio,
				nWidth,
				nHeight,
				cssObj = {};

			if(imgScaleMode === 'fit-if-smaller') {
				if(baseImageWidth > containerWidth || baseImageHeight > containerHeight) {
					imgScaleMode = 'fit';
				}
			}
			if(imgScaleMode === 'fill' || imgScaleMode === 'fit') {		
				hRatio = containerWidth / baseImageWidth;
				vRatio = containerHeight / baseImageHeight;

				if (imgScaleMode  == "fill") {
					ratio = hRatio > vRatio ? hRatio : vRatio;
				} else if (imgScaleMode  == "fit") {
					ratio = hRatio < vRatio ? hRatio : vRatio;
				} else {
					ratio = 1;
				}

				nWidth = Math.ceil(baseImageWidth * ratio, 10);
				nHeight = Math.ceil(baseImageHeight * ratio, 10);
			} else {								
				nWidth = baseImageWidth;
				nHeight = baseImageHeight;		
			}
			if(imgScaleMode !== 'none') {
				cssObj.width = nWidth;
				cssObj.height = nHeight;
				if(isVideo) {
					img.find('.rsImg').css({width: '100%', height:'100%'});
				}
			}
			if (imgAlignCenter) {     
				cssObj.marginLeft = Math.floor((containerWidth - nWidth) / 2) +  bMargin;
				cssObj.marginTop = Math.floor((containerHeight - nHeight) / 2) +  bMargin;
			}
			img.css(cssObj);
		}
	}; /* RoyalSlider core prototype end */
	$.rsProto = RoyalSlider.prototype;

	$.fn.royalSlider = function(options) {
		var args = arguments;
		return this.each(function(){
			var self = $(this);
			if (typeof options === "object" ||  !options) {
				if( !self.data('royalSlider') ) {
					self.data('royalSlider', new RoyalSlider(self, options));
				}
			} else {
				var royalSlider = self.data('royalSlider');
				if (royalSlider && royalSlider[options]) {
					return royalSlider[options].apply(royalSlider, Array.prototype.slice.call(args, 1));
				}
			}
		});
	};

	$.fn.royalSlider.defaults = {    
		slidesSpacing: 8,
		startSlideId: 0,
		loop: false,
		loopRewind: false,
		numImagesToPreload: 4,
		fadeinLoadedSlide: true,
		slidesOrientation: 'horizontal',
		transitionType: 'move', 
		transitionSpeed: 600,
		controlNavigation: 'bullets',
		controlsInside: true, 
		arrowsNav: true,
		arrowsNavAutoHide: true,
		navigateByClick: true,
		randomizeSlides: false,
		sliderDrag: true, 
		sliderTouch: true,
		keyboardNavEnabled: false,
		fadeInAfterLoaded: true,

		allowCSS3: true,
		allowCSS3OnWebkit: true,

		
		addActiveClass: false,
		autoHeight: false,

		easeOut: 'easeOutSine',
		easeInOut: 'easeInOutSine',

		minSlideOffset: 10,

		imageScaleMode:"fit-if-smaller",
		imageAlignCenter:true,
		imageScalePadding: 4,
		usePreloader: true,

		autoScaleSlider: false,

		autoScaleSliderWidth: 800,
		autoScaleSliderHeight: 400,

		autoScaleHeight: true,

		arrowsNavHideOnTouch: false,
		globalCaption: false,

		slidesDiff: 2
	}; /* default options end */

	$.rsCSS3Easing = {
		easeOutSine: 'cubic-bezier(0.390, 0.575, 0.565, 1.000)',
		easeInOutSine: 'cubic-bezier(0.445, 0.050, 0.550, 0.950)'
	};

	$.extend(jQuery.easing, {
		easeInOutSine: function (x, t, b, c, d) {
			return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
		},
		easeOutSine: function (x, t, b, c, d) {
			return c * Math.sin(t/d * (Math.PI/2)) + b;
		},
		easeOutCubic: function (x, t, b, c, d) {
			return c*((t=t/d-1)*t*t + 1) + b;
		}
	});


})(jQuery, window);
(function($) {

	"use strict";

	/**
	 *
	 * RoyalSlider fullscreen module
	 * @version 1.0.5:
	 *
	 * 1.0.1:
	 * - Added rsEnterFullscreen and rsExitFullscreen events
	 *
	 * 1.0.2
	 * - Added window scroll detection
	 *
	 * 1.0.3
	 * - Fullscreen button now is added to _controlsContainer element
	 *
	 * 1.0.4
	 * - Fixed issue that could cause small image be loaded in fullscreen
	 *
	 * 1.0.5
	 * - Fix "false" native fullscreen on Android
	 * 
	 */
	$.extend($.rsProto, {
		_initFullscreen: function() {
			var self = this;

			self._fullscreenDefaults = {
				enabled: false,
				keyboardNav: true,
				buttonFS: true,
				nativeFS: false,
				doubleTap: true
			};
			self.st.fullscreen = $.extend({}, self._fullscreenDefaults, self.st.fullscreen);

			if(self.st.fullscreen.enabled) {
				self.ev.one('rsBeforeSizeSet', function() {
					self._setupFullscreen();
				});
			}
		},
		_setupFullscreen: function() {
			var self = this;
			self._fsKeyboard = (!self.st.keyboardNavEnabled && self.st.fullscreen.keyboardNav);

			if(self.st.fullscreen.nativeFS) {
				// Thanks to John Dyer http://j.hn/
				self._fullScreenApi = {
					supportsFullScreen: false,
					isFullScreen: function() { return false; },
					requestFullScreen: function() {},
					cancelFullScreen: function() {},
					fullScreenEventName: '',
					prefix: ''
				};

				var browserPrefixes = 'webkit moz o ms khtml'.split(' ');
				// check for native support
				if(!self.isAndroid) {
					if (typeof document.cancelFullScreen != 'undefined') {
						self._fullScreenApi.supportsFullScreen = true;
					} else {
						// check for fullscreen support by vendor prefix
						for (var i = 0; i < browserPrefixes.length; i++ ) {
							self._fullScreenApi.prefix = browserPrefixes[i];
							if (typeof document[ self._fullScreenApi.prefix + 'CancelFullScreen' ] != 'undefined' ) {
								self._fullScreenApi.supportsFullScreen = true;
								break;
							}
						}
					}
				}
			 
				// update methods to do something useful
				if ( self._fullScreenApi.supportsFullScreen) {
					self.nativeFS = true;
					self._fullScreenApi.fullScreenEventName =  self._fullScreenApi.prefix + 'fullscreenchange' + self.ns;

					self._fullScreenApi.isFullScreen = function() {
						switch (this.prefix) {
							case '':
								return document.fullScreen;
							case 'webkit':
								return document.webkitIsFullScreen;
							default:
								return document[this.prefix + 'FullScreen'];
						}
					};
					self._fullScreenApi.requestFullScreen = function(el) {
						return (this.prefix === '') ? el.requestFullScreen() : el[this.prefix + 'RequestFullScreen']();
					};
					self._fullScreenApi.cancelFullScreen = function(el) {
						return (this.prefix === '') ? document.cancelFullScreen() : document[this.prefix + 'CancelFullScreen']();
					};
				} else {
					self._fullScreenApi = false;
				}
			}


			if(self.st.fullscreen.buttonFS) {
				self._fsBtn = $('<div class="rsFullscreenBtn"><div class="rsFullscreenIcn"></div></div>')
					.appendTo(self._controlsContainer)
					.on('click.rs', function() {
						if(self.isFullscreen) {
							self.exitFullscreen();
						} else {

							self.enterFullscreen();
						}
					});
			}
		},
		enterFullscreen: function(preventNative) {
			var self = this;
			if( self._fullScreenApi ) {
				if(!preventNative) {
					self._doc.on( self._fullScreenApi.fullScreenEventName, function(e) {
						if(!self._fullScreenApi.isFullScreen()) {
							self.exitFullscreen(true);
						} else {
							self.enterFullscreen(true);
						}
					});
					self._fullScreenApi.requestFullScreen($('html')[0]);
					return;
				} else {
					self._fullScreenApi.requestFullScreen($('html')[0]);
				}
			}

			if(self._isFullscreenUpdating) {
				return;
			}
			self._isFullscreenUpdating = true;

			self._doc.on('keyup' + self.ns + 'fullscreen', function(e) {
				if(e.keyCode === 27) {
					self.exitFullscreen();
				}
			});
			if(self._fsKeyboard) {
				self._bindKeyboardNav();
			}

			var win = $(window);
			self._fsScrollTopOnEnter = win.scrollTop();
			self._fsScrollLeftOnEnter = win.scrollLeft();

			self._htmlStyle = $('html').attr('style');
			self._bodyStyle = $('body').attr('style');
			self._sliderStyle = self.slider.attr('style');

			$('body, html').css({
				overflow: 'hidden',
				height: '100%',
				width: '100%',
				margin: '0',
				padding: '0'
			});

			self.slider.addClass('rsFullscreen');
			
		
			var item,
				i;
			for(i = 0; i < self.numSlides; i++) {
				item = self.slides[i];
				
				item.isRendered = false;
				if(item.bigImage) {
					item.isBig = true;
					item.isMedLoaded = item.isLoaded;
					item.isMedLoading = item.isLoading;
					item.medImage = item.image;
					item.medIW = item.iW;
					item.medIH = item.iH;
					item.slideId = -99;

					if(item.bigImage !== item.medImage) {
						item.sizeType = 'big';
					}

					item.isLoaded = item.isBigLoaded;
					item.isLoading = false;
					item.image = item.bigImage;
					item.images[0] = item.bigImage;
					item.iW = item.bigIW;
					item.iH = item.bigIH;

					item.isAppended = item.contentAdded = false;
					self._updateItemSrc(item);
				}
				
			}

			
			self.isFullscreen = true;
			
			self._isFullscreenUpdating = false;
			self.updateSliderSize();
			self.ev.trigger('rsEnterFullscreen');
			
		},
		exitFullscreen: function(preventNative) {
			var self = this;

			if( self._fullScreenApi ) {
				if(!preventNative) {
					self._fullScreenApi.cancelFullScreen($('html')[0]);
					return;
				}
				self._doc.off( self._fullScreenApi.fullScreenEventName );
			}
			if(self._isFullscreenUpdating) {
				return;
			}
			self._isFullscreenUpdating = true;

			self._doc.off('keyup'  + self.ns + 'fullscreen');
			if(self._fsKeyboard) {
				self._doc.off('keydown' + self.ns);
			}

			$('html').attr('style', self._htmlStyle || '');
			$('body').attr('style', self._bodyStyle || '');
			

			
			var item,
				i;
			for(i = 0; i < self.numSlides; i++) {
				item = self.slides[i];
				
				
				item.isRendered = false;
				if(item.bigImage) {
					item.isBig = false;
					item.slideId = -99;
					item.isBigLoaded = item.isLoaded;
					item.isBigLoading = item.isLoading;
					item.bigImage = item.image;
					item.bigIW = item.iW;
					item.bigIH = item.iH;
					item.isLoaded = item.isMedLoaded;
					item.isLoading = false;
					item.image = item.medImage;
					item.images[0] = item.medImage;
					item.iW = item.medIW;
					item.iH = item.medIH;

					item.isAppended = item.contentAdded = false;

					self._updateItemSrc(item, true);
					
					
					if(item.bigImage !== item.medImage) {
						item.sizeType = 'med';
					}
				}
			}
			
			self.isFullscreen = false;

			var win = $(window);
			win.scrollTop( self._fsScrollTopOnEnter );
			win.scrollLeft( self._fsScrollLeftOnEnter );
			
			self._isFullscreenUpdating = false;
			self.slider.removeClass('rsFullscreen');

			self.updateSliderSize();
			// fix overflow bug
			setTimeout(function() {
				self.updateSliderSize();
			},1);
			self.ev.trigger('rsExitFullscreen');
		},
		_updateItemSrc: function(item, exit) {
			var newHTML = (!item.isLoaded && !item.isLoading) ? '<a class="rsImg rsMainSlideImage" href="'+item.image+'"></a>' : '<img class="rsImg rsMainSlideImage" src="'+item.image+'"/>';
			
			if(item.content.hasClass('rsImg')) {
				item.content = $(newHTML);
			} else {
				item.content.find('.rsImg').eq(0).replaceWith(newHTML);
			}
			if(!item.isLoaded && !item.isLoading && item.holder) {
				item.holder.html(item.content);
			}
		}
	});
	$.rsModules.fullscreen = $.rsProto._initFullscreen;
})(jQuery);

(function($) {

	"use strict";

	/**
	 *
	 * RoyalSlider auto play module
	 * @version 1.0.5:
	 *
	 * 1.0.3:
	 * - added support for 'autoplay' property name. 
	 *
	 * 1.0.4
	 * - added toggleAutoPlay public method
	 *
	 * 1.0.5
	 * - Fixed issue when autoPlay may not pause when switching browser tabs
	 */
	$.extend($.rsProto, {
		_initAutoplay: function() {
			var self = this,
				del;

			self._autoPlayDefaults = {
				enabled: false,
				stopAtAction: true,
				pauseOnHover: true,
				delay: 2000
			};

			// fix deprecated name
			if(!self.st.autoPlay && self.st.autoplay) {
				self.st.autoPlay = self.st.autoplay;
			}
			self.st.autoPlay = $.extend({}, self._autoPlayDefaults, self.st.autoPlay);

			if(self.st.autoPlay.enabled) {
				self.ev.on('rsBeforeParseNode', function(e, content, obj) {
					content = $(content);
					del = content.attr('data-rsDelay');
					if(del) {
						obj.customDelay = parseInt(del, 10);
					}
				});
				self.ev.one('rsAfterInit', function() {
					self._setupAutoPlay();
				});
				self.ev.on('rsBeforeDestroy', function() {
					self.stopAutoPlay();
					self.slider.off('mouseenter mouseleave');
					$(window).off('blur'+self.ns + ' focus' + self.ns);
				});
				
			}
		},
		_setupAutoPlay: function() {
			var self = this;
				
			self.startAutoPlay();

			self.ev.on('rsAfterContentSet', function(e, slideObject) {
				if(!self._isDragging && !self._isAnimating && self._autoPlayEnabled && slideObject === self.currSlide ) {
					self._play();
				}
			});
			self.ev.on('rsDragRelease', function() {
				if(self._autoPlayEnabled && self._autoPlayPaused) {
					self._autoPlayPaused = false;
					self._play();
				}
			});
			self.ev.on('rsAfterSlideChange', function() {
				if(self._autoPlayEnabled) {
					if(self._autoPlayPaused) {
						self._autoPlayPaused = false; 

						if(self.currSlide.isLoaded) {
							self._play();
						}
					}
				}
			});
			self.ev.on('rsDragStart', function() {
				if(self._autoPlayEnabled) {
					if(self.st.autoPlay.stopAtAction) {
						self.stopAutoPlay();
					} else {
						self._autoPlayPaused = true;
						self._pause();
					}
				}
			});
			self.ev.on('rsBeforeMove', function(e, type, userAction) {
				if(self._autoPlayEnabled) {
					if(userAction && self.st.autoPlay.stopAtAction) {
						self.stopAutoPlay();
					} else {
						self._autoPlayPaused = true;
						self._pause();
					}
				}
			});

			self._pausedByVideo = false;
			self.ev.on('rsVideoStop', function() {
				if(self._autoPlayEnabled) {
					self._pausedByVideo = false;
					self._play();
				}
			});
			self.ev.on('rsVideoPlay', function() {
				if(self._autoPlayEnabled) {
					self._autoPlayPaused = false;
					self._pause();
					self._pausedByVideo = true;
				} 
			});

			$(window).on('blur'+self.ns, function(){
				if(self._autoPlayEnabled) {
					self._autoPlayPaused = true;
					self._pause();
				}
			}).on('focus'+self.ns, function(){
				if(self._autoPlayEnabled && self._autoPlayPaused) {
					self._autoPlayPaused = false;
					self._play();
				}
			});

			if(self.st.autoPlay.pauseOnHover) {
				self._pausedByHover = false;
				self.slider.hover(
					function() {
						if(self._autoPlayEnabled) {
							self._autoPlayPaused = false;
							self._pause();
							self._pausedByHover = true;
						} 
					},
					function() {
						if(self._autoPlayEnabled) {
							self._pausedByHover = false;
							self._play();
						}
					}
				);	
			}
			
		},
		toggleAutoPlay: function() {
			var self = this;
			if(self._autoPlayEnabled) {
				self.stopAutoPlay();
			} else {
				self.startAutoPlay();
			}
		},
		startAutoPlay: function() {
			var self = this;
			self._autoPlayEnabled = true;
			if(self.currSlide.isLoaded) {
				self._play();
			}
		},
		stopAutoPlay: function() {
			var self = this;
			self._pausedByVideo = self._pausedByHover = self._autoPlayPaused = self._autoPlayEnabled = false;
			self._pause();
		},
		_play: function() {
			var self = this;
			if(!self._pausedByHover && !self._pausedByVideo) {
				self._autoPlayRunning = true;
				if(self._autoPlayTimeout) {
					clearTimeout(self._autoPlayTimeout);
				}
				self._autoPlayTimeout = setTimeout(function() {
					var changed;
					if(!self._loop && !self.st.loopRewind) {
						changed = true;
						self.st.loopRewind = true;
					}
					self.next(true);
					if(changed) {
						changed = false;
						self.st.loopRewind = false;
					}
				}, !self.currSlide.customDelay ? self.st.autoPlay.delay : self.currSlide.customDelay);
			}
			
		},
		_pause: function() {
			var self = this;
			if(!self._pausedByHover && !self._pausedByVideo) {
				self._autoPlayRunning = false;
				if(self._autoPlayTimeout) {
					clearTimeout(self._autoPlayTimeout);
					self._autoPlayTimeout = null;
				}
			}
		}
	});
	$.rsModules.autoplay = $.rsProto._initAutoplay;
})(jQuery);

(function($) {

	"use strict";

	/**
	 *
	 * RoyalSlider bullets module
	 * @version 1.0.1:
	 *
	 * 1.0.1
	 * - Minor optimizations
	 * 
	 */ 
	$.extend($.rsProto, {
		_initBullets: function() {
			var self = this;
			if(self.st.controlNavigation === 'bullets') {
				var itemHTML = '<div class="rsNavItem rsBullet"><span></span></div>';
				self.ev.one('rsAfterPropsSetup', function() {

					self._controlNavEnabled = true;
					self.slider.addClass('rsWithBullets');
					var out = '<div class="rsNav rsBullets">';
					for(var i = 0; i < self.numSlides; i++) {
						out += itemHTML;
					}
					self._controlNav = out = $(out + '</div>');
					self._controlNavItems = out.appendTo(self.slider).children();

					self._controlNav.on('click.rs','.rsNavItem',function(e) {
						if(!self._thumbsDrag ) {
							self.goTo( $(this).index() );
						}
					});
				});

				self.ev.on('rsOnAppendSlide', function(e, parsedSlide, index) {
					if(index >= self.numSlides) {
						self._controlNav.append(itemHTML);
					} else {
						self._controlNavItems.eq(index).before(itemHTML);
					}
					self._controlNavItems = self._controlNav.children();
				});
				self.ev.on('rsOnRemoveSlide', function(e, index) {
					var itemToRemove = self._controlNavItems.eq(index);
					if(itemToRemove && itemToRemove.length) {
						itemToRemove.remove();
						self._controlNavItems = self._controlNav.children();
					}
					
				});	

				self.ev.on('rsOnUpdateNav', function() {
					var id = self.currSlideId,
						currItem,
						prevItem;
					if(self._prevNavItem) {
						self._prevNavItem.removeClass('rsNavSelected');
					}
					currItem = self._controlNavItems.eq(id);

					currItem.addClass('rsNavSelected');
					self._prevNavItem = currItem;
				});
			}
		}
	});
	$.rsModules.bullets = $.rsProto._initBullets;
})(jQuery);

(function($) {

	"use strict";

	/**
	 *
	 * RoyalSlider video module
	 * @version 1.1.1:
	 *
	 * 1.0.3:
	 * - Added rsOnDestroyVideoElement event
	 *
	 * 1.0.4:
	 * - Added wmode=transparent to default YouTube video embed code
	 *
	 * 1.0.5
	 * - Fixed bug: HTMl5 YouTube player sometimes keeps playing in ie9 after closing
	 *
	 * 1.0.6
	 * - A bit lightened Vimeo and YouTube regex 
	 *
	 * 1.0.7
	 * - Minor optimizations
	 * - Added autoHideCaption option
	 *
	 * 1.0.9
	 * - Fixed error that could appear if updateSliderSize method is called directly after video close
	 *
	 * 1.1.0
	 * - Video is now removed in rsAfterSlideChange event to avoid transition lag
	 * - Fixed bug that could cause appearing of arrows with auto-hide
	 *
	 * 1.1.1
	 * - Added option disableCSS3inFF
	 */
	$.extend($.rsProto, {
		_initVideo: function() {
			var self = this;
			self._videoDefaults = {
				autoHideArrows: true,
				autoHideControlNav: false,
				autoHideBlocks: false,
				autoHideCaption: false,
				disableCSS3inFF: true,
				youTubeCode: '<iframe src="http://www.youtube.com/embed/%id%?rel=1&autoplay=1&showinfo=0&autoplay=1&wmode=transparent" frameborder="no"></iframe>',
				vimeoCode: '<iframe src="http://player.vimeo.com/video/%id%?byline=0&amp;portrait=0&amp;autoplay=1" frameborder="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>'
			};

			self.st.video = $.extend({}, self._videoDefaults, self.st.video);

			self.ev.on('rsBeforeSizeSet', function() {
				if(self._isVideoPlaying) {
					setTimeout(function() {
						var content = self._currHolder;
						content = content.hasClass('rsVideoContainer') ? content : content.find('.rsVideoContainer');
						if(self._videoFrameHolder) {
							self._videoFrameHolder.css({
								width: content.width(),
								height: content.height()
							});
						}
					}, 32);
				}
			});
			var isFF = self._browser.mozilla;
			self.ev.on('rsAfterParseNode', function(e, content, obj) {
				var jqcontent = $(content),
					tempEl,
					hasVideo;

				if(obj.videoURL) {
					if(self.st.video.disableCSS3inFF && !hasVideo && isFF) {
						hasVideo = true;
						self._useCSS3Transitions = self._use3dTransform = false;
					}
					var wrap = $('<div class="rsVideoContainer"></div>'),
						playBtn = $('<div class="rsBtnCenterer"><div class="rsPlayBtn"><div class="rsPlayBtnIcon"></div></div></div>');
					if(jqcontent.hasClass('rsImg')) {
						obj.content = wrap.append(jqcontent).append(playBtn);
					} else {
						obj.content.find('.rsImg').wrap(wrap).after(playBtn);
					}
				}
			});

			self.ev.on('rsAfterSlideChange', function() {
				self.stopVideo();
			});

		},
		toggleVideo: function() {
			var self = this;
			if(!self._isVideoPlaying) {
				return self.playVideo();
			} else {
				return self.stopVideo();
			}
		},
		playVideo: function() {
			var self = this;
			if(!self._isVideoPlaying) {
				var currSlide = self.currSlide;
				if(!currSlide.videoURL) {
					return false;
				}

				
				var content = self._currVideoContent = currSlide.content;
				var url = currSlide.videoURL,
					videoId,
					regExp,
					match;

				if( url.match(/youtu\.be/i) || url.match(/youtube\.com/i) ) {

					regExp = /^.*((youtu.be\/)|(v\/)|(\/u\/\w\/)|(embed\/)|(watch\?))\??v?=?([^#\&\?]*).*/;


					match = url.match(regExp);
					if (match && match[7].length==11){
						videoId = match[7];
					}

					if(videoId !== undefined) {
						self._videoFrameHolder = self.st.video.youTubeCode.replace("%id%", videoId);
					}
				} else if(url.match(/vimeo\.com/i)) {
					regExp = /(www\.)?vimeo.com\/(\d+)($|\/)/;
					match = url.match(regExp);
					if(match) {
						videoId = match[2];
					}
					if(videoId !== undefined) {
						self._videoFrameHolder = self.st.video.vimeoCode.replace("%id%", videoId);
					}
				}
				self.videoObj = $(self._videoFrameHolder);

				self.ev.trigger('rsOnCreateVideoElement', [url]);


				if(self.videoObj.length) {
					self._videoFrameHolder = $('<div class="rsVideoFrameHolder"><div class="rsPreloader"></div><div class="rsCloseVideoBtn"><div class="rsCloseVideoIcn"></div></div></div>');
					self._videoFrameHolder.find('.rsPreloader').after(self.videoObj);
					content = content.hasClass('rsVideoContainer') ? content : content.find('.rsVideoContainer');
					self._videoFrameHolder.css({
						width: content.width(),
						height: content.height()
					}).find('.rsCloseVideoBtn').off('click.rsv').on('click.rsv', function(e) {
						self.stopVideo();
						e.preventDefault();
						e.stopPropagation();
						return false;
					});
					content.append(self._videoFrameHolder);
					if(self.isIPAD) {
						content.addClass('rsIOSVideo');
					}

					self._toggleHiddenClass(false);

					setTimeout(function() {
						self._videoFrameHolder.addClass('rsVideoActive');
					}, 10);
					self.ev.trigger('rsVideoPlay');
					self._isVideoPlaying = true;
				}
				return true;
			}
			return false;
		},
		stopVideo: function() {
			var self = this;
			if(self._isVideoPlaying) {
				if(self.isIPAD) {
					self.slider.find('.rsCloseVideoBtn').remove();
				}
				
				self._toggleHiddenClass(true);

				setTimeout(function() {
					self.ev.trigger('rsOnDestroyVideoElement', [self.videoObj]);
					var ifr = self._videoFrameHolder.find('iframe');
					if(ifr.length) {
						try {
							ifr.attr('src', "");
						} catch(ex) { }
					}
					self._videoFrameHolder.remove();
					self._videoFrameHolder = null;
				}, 16);
				self.ev.trigger('rsVideoStop');
				self._isVideoPlaying = false;
				return true;
			} 
			return false;
		},
		_toggleHiddenClass: function(remove) {
			var arr = [],
				self = this,
				vst = self.st.video;
			if(vst.autoHideArrows) {
				if(self._arrowLeft) {
					arr.push(self._arrowLeft, self._arrowRight);
					self._arrowsAutoHideLocked = !remove;
				}
				if(self._fsBtn) {
					arr.push(self._fsBtn);
				}
			}
			if(vst.autoHideControlNav && self._controlNav) {
				arr.push(self._controlNav);
			}
			if(vst.autoHideBlocks && self.currSlide.animBlocks) {
				arr.push(self.currSlide.animBlocks);
			}
			if(vst.autoHideCaption && self.globalCaption) {
				arr.push(self.globalCaption);
			}

			if(arr.length) {
				for(var i = 0; i < arr.length; i++) {
					if(!remove) {
						arr[i].addClass('rsHidden');
					} else {
						arr[i].removeClass('rsHidden');
					}
				}
			}
		}
	});
	$.rsModules.video = $.rsProto._initVideo;
})(jQuery);

(function($) {

	"use strict";

	/**
	 *
	 * RoyalSlider global caption module
	 * @version 1.0:
	 * 
	 */ 
	$.extend($.rsProto, {
		_initGlobalCaption: function() {
			var self = this;
			if(self.st.globalCaption) {
				var setCurrCaptionHTML = function () {
					self.globalCaption.html(self.currSlide.caption);
				};
				self.ev.on('rsAfterInit', function() {
					self.globalCaption = $('<div class="rsGCaption"></div>').appendTo( !self.st.globalCaptionInside ? self.slider : self._sliderOverflow );
					setCurrCaptionHTML();
				});
				self.ev.on('rsBeforeAnimStart' , function() {
					setCurrCaptionHTML();
				});
			}
		}
	});
	$.rsModules.globalCaption = $.rsProto._initGlobalCaption;
})(jQuery);
/*!
 * jQuery Transit - CSS3 transitions and transformations
 * (c) 2011-2012 Rico Sta. Cruz
 * MIT Licensed.
 *
 * http://ricostacruz.com/jquery.transit
 * http://github.com/rstacruz/jquery.transit
 */

(function($) {
  $.transit = {
    version: "0.9.9",

    // Map of $.css() keys to values for 'transitionProperty'.
    // See https://developer.mozilla.org/en/CSS/CSS_transitions#Properties_that_can_be_animated
    propertyMap: {
      marginLeft    : 'margin',
      marginRight   : 'margin',
      marginBottom  : 'margin',
      marginTop     : 'margin',
      paddingLeft   : 'padding',
      paddingRight  : 'padding',
      paddingBottom : 'padding',
      paddingTop    : 'padding'
    },

    // Will simply transition "instantly" if false
    enabled: true,

    // Set this to false if you don't want to use the transition end property.
    useTransitionEnd: false
  };

  var div = document.createElement('div');
  var support = {};

  // Helper function to get the proper vendor property name.
  // (`transition` => `WebkitTransition`)
  function getVendorPropertyName(prop) {
    // Handle unprefixed versions (FF16+, for example)
    if (prop in div.style) return prop;

    var prefixes = ['Moz', 'Webkit', 'O', 'ms'];
    var prop_ = prop.charAt(0).toUpperCase() + prop.substr(1);

    if (prop in div.style) { return prop; }

    for (var i=0; i<prefixes.length; ++i) {
      var vendorProp = prefixes[i] + prop_;
      if (vendorProp in div.style) { return vendorProp; }
    }
  }

  // Helper function to check if transform3D is supported.
  // Should return true for Webkits and Firefox 10+.
  function checkTransform3dSupport() {
    div.style[support.transform] = '';
    div.style[support.transform] = 'rotateY(90deg)';
    return div.style[support.transform] !== '';
  }

  var isChrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;

  // Check for the browser's transitions support.
  support.transition      = getVendorPropertyName('transition');
  support.transitionDelay = getVendorPropertyName('transitionDelay');
  support.transform       = getVendorPropertyName('transform');
  support.transformOrigin = getVendorPropertyName('transformOrigin');
  support.filter          = getVendorPropertyName('Filter');
  support.transform3d     = checkTransform3dSupport();

  var eventNames = {
    'transition':       'transitionEnd',
    'MozTransition':    'transitionend',
    'OTransition':      'oTransitionEnd',
    'WebkitTransition': 'webkitTransitionEnd',
    'msTransition':     'MSTransitionEnd'
  };

  // Detect the 'transitionend' event needed.
  var transitionEnd = support.transitionEnd = eventNames[support.transition] || null;

  // Populate jQuery's `$.support` with the vendor prefixes we know.
  // As per [jQuery's cssHooks documentation](http://api.jquery.com/jQuery.cssHooks/),
  // we set $.support.transition to a string of the actual property name used.
  for (var key in support) {
    if (support.hasOwnProperty(key) && typeof $.support[key] === 'undefined') {
      $.support[key] = support[key];
    }
  }

  // Avoid memory leak in IE.
  div = null;

  // ## $.cssEase
  // List of easing aliases that you can use with `$.fn.transition`.
  $.cssEase = {
    '_default':       'ease',
    'in':             'ease-in',
    'out':            'ease-out',
    'in-out':         'ease-in-out',
    'snap':           'cubic-bezier(0,1,.5,1)',
    // Penner equations
    'easeOutCubic':   'cubic-bezier(.215,.61,.355,1)',
    'easeInOutCubic': 'cubic-bezier(.645,.045,.355,1)',
    'easeInCirc':     'cubic-bezier(.6,.04,.98,.335)',
    'easeOutCirc':    'cubic-bezier(.075,.82,.165,1)',
    'easeInOutCirc':  'cubic-bezier(.785,.135,.15,.86)',
    'easeInExpo':     'cubic-bezier(.95,.05,.795,.035)',
    'easeOutExpo':    'cubic-bezier(.19,1,.22,1)',
    'easeInOutExpo':  'cubic-bezier(1,0,0,1)',
    'easeInQuad':     'cubic-bezier(.55,.085,.68,.53)',
    'easeOutQuad':    'cubic-bezier(.25,.46,.45,.94)',
    'easeInOutQuad':  'cubic-bezier(.455,.03,.515,.955)',
    'easeInQuart':    'cubic-bezier(.895,.03,.685,.22)',
    'easeOutQuart':   'cubic-bezier(.165,.84,.44,1)',
    'easeInOutQuart': 'cubic-bezier(.77,0,.175,1)',
    'easeInQuint':    'cubic-bezier(.755,.05,.855,.06)',
    'easeOutQuint':   'cubic-bezier(.23,1,.32,1)',
    'easeInOutQuint': 'cubic-bezier(.86,0,.07,1)',
    'easeInSine':     'cubic-bezier(.47,0,.745,.715)',
    'easeOutSine':    'cubic-bezier(.39,.575,.565,1)',
    'easeInOutSine':  'cubic-bezier(.445,.05,.55,.95)',
    'easeInBack':     'cubic-bezier(.6,-.28,.735,.045)',
    'easeOutBack':    'cubic-bezier(.175, .885,.32,1.275)',
    'easeInOutBack':  'cubic-bezier(.68,-.55,.265,1.55)'
  };

  // ## 'transform' CSS hook
  // Allows you to use the `transform` property in CSS.
  //
  //     $("#hello").css({ transform: "rotate(90deg)" });
  //
  //     $("#hello").css('transform');
  //     //=> { rotate: '90deg' }
  //
  $.cssHooks['transit:transform'] = {
    // The getter returns a `Transform` object.
    get: function(elem) {
      return $(elem).data('transform') || new Transform();
    },

    // The setter accepts a `Transform` object or a string.
    set: function(elem, v) {
      var value = v;

      if (!(value instanceof Transform)) {
        value = new Transform(value);
      }

      // We've seen the 3D version of Scale() not work in Chrome when the
      // element being scaled extends outside of the viewport.  Thus, we're
      // forcing Chrome to not use the 3d transforms as well.  Not sure if
      // translate is affectede, but not risking it.  Detection code from
      // http://davidwalsh.name/detecting-google-chrome-javascript
      if (support.transform === 'WebkitTransform' && !isChrome) {
        elem.style[support.transform] = value.toString(true);
      } else {
        elem.style[support.transform] = value.toString();
      }

      $(elem).data('transform', value);
    }
  };

  // Add a CSS hook for `.css({ transform: '...' })`.
  // In jQuery 1.8+, this will intentionally override the default `transform`
  // CSS hook so it'll play well with Transit. (see issue #62)
  $.cssHooks.transform = {
    set: $.cssHooks['transit:transform'].set
  };

  // ## 'filter' CSS hook
  // Allows you to use the `filter` property in CSS.
  //
  //     $("#hello").css({ filter: 'blur(10px)' });
  //
  $.cssHooks.filter = {
    get: function(elem) {
      return elem.style[support.filter];
    },
    set: function(elem, value) {
      elem.style[support.filter] = value;
    }
  };

  // jQuery 1.8+ supports prefix-free transitions, so these polyfills will not
  // be necessary.
  if ($.fn.jquery < "1.8") {
    // ## 'transformOrigin' CSS hook
    // Allows the use for `transformOrigin` to define where scaling and rotation
    // is pivoted.
    //
    //     $("#hello").css({ transformOrigin: '0 0' });
    //
    $.cssHooks.transformOrigin = {
      get: function(elem) {
        return elem.style[support.transformOrigin];
      },
      set: function(elem, value) {
        elem.style[support.transformOrigin] = value;
      }
    };

    // ## 'transition' CSS hook
    // Allows you to use the `transition` property in CSS.
    //
    //     $("#hello").css({ transition: 'all 0 ease 0' });
    //
    $.cssHooks.transition = {
      get: function(elem) {
        return elem.style[support.transition];
      },
      set: function(elem, value) {
        elem.style[support.transition] = value;
      }
    };
  }

  // ## Other CSS hooks
  // Allows you to rotate, scale and translate.
  registerCssHook('scale');
  registerCssHook('translate');
  registerCssHook('rotate');
  registerCssHook('rotateX');
  registerCssHook('rotateY');
  registerCssHook('rotate3d');
  registerCssHook('perspective');
  registerCssHook('skewX');
  registerCssHook('skewY');
  registerCssHook('x', true);
  registerCssHook('y', true);

  // ## Transform class
  // This is the main class of a transformation property that powers
  // `$.fn.css({ transform: '...' })`.
  //
  // This is, in essence, a dictionary object with key/values as `-transform`
  // properties.
  //
  //     var t = new Transform("rotate(90) scale(4)");
  //
  //     t.rotate             //=> "90deg"
  //     t.scale              //=> "4,4"
  //
  // Setters are accounted for.
  //
  //     t.set('rotate', 4)
  //     t.rotate             //=> "4deg"
  //
  // Convert it to a CSS string using the `toString()` and `toString(true)` (for WebKit)
  // functions.
  //
  //     t.toString()         //=> "rotate(90deg) scale(4,4)"
  //     t.toString(true)     //=> "rotate(90deg) scale3d(4,4,0)" (WebKit version)
  //
  function Transform(str) {
    if (typeof str === 'string') { this.parse(str); }
    return this;
  }

  Transform.prototype = {
    // ### setFromString()
    // Sets a property from a string.
    //
    //     t.setFromString('scale', '2,4');
    //     // Same as set('scale', '2', '4');
    //
    setFromString: function(prop, val) {
      var args =
        (typeof val === 'string')  ? val.split(',') :
        (val.constructor === Array) ? val :
        [ val ];

      args.unshift(prop);

      Transform.prototype.set.apply(this, args);
    },

    // ### set()
    // Sets a property.
    //
    //     t.set('scale', 2, 4);
    //
    set: function(prop) {
      var args = Array.prototype.slice.apply(arguments, [1]);
      if (this.setter[prop]) {
        this.setter[prop].apply(this, args);
      } else {
        this[prop] = args.join(',');
      }
    },

    get: function(prop) {
      if (this.getter[prop]) {
        return this.getter[prop].apply(this);
      } else {
        return this[prop] || 0;
      }
    },

    setter: {
      // ### rotate
      //
      //     .css({ rotate: 30 })
      //     .css({ rotate: "30" })
      //     .css({ rotate: "30deg" })
      //     .css({ rotate: "30deg" })
      //
      rotate: function(theta) {
        this.rotate = unit(theta, 'deg');
      },

      rotateX: function(theta) {
        this.rotateX = unit(theta, 'deg');
      },

      rotateY: function(theta) {
        this.rotateY = unit(theta, 'deg');
      },

      // ### scale
      //
      //     .css({ scale: 9 })      //=> "scale(9,9)"
      //     .css({ scale: '3,2' })  //=> "scale(3,2)"
      //
      scale: function(x, y) {
        if (y === undefined) { y = x; }
        this.scale = x + "," + y;
      },

      // ### skewX + skewY
      skewX: function(x) {
        this.skewX = unit(x, 'deg');
      },

      skewY: function(y) {
        this.skewY = unit(y, 'deg');
      },

      // ### perspectvie
      perspective: function(dist) {
        this.perspective = unit(dist, 'px');
      },

      // ### x / y
      // Translations. Notice how this keeps the other value.
      //
      //     .css({ x: 4 })       //=> "translate(4px, 0)"
      //     .css({ y: 10 })      //=> "translate(4px, 10px)"
      //
      x: function(x) {
        this.set('translate', x, null);
      },

      y: function(y) {
        this.set('translate', null, y);
      },

      // ### translate
      // Notice how this keeps the other value.
      //
      //     .css({ translate: '2, 5' })    //=> "translate(2px, 5px)"
      //
      translate: function(x, y) {
        if (this._translateX === undefined) { this._translateX = 0; }
        if (this._translateY === undefined) { this._translateY = 0; }

        if (x !== null && x !== undefined) { this._translateX = unit(x, 'px'); }
        if (y !== null && y !== undefined) { this._translateY = unit(y, 'px'); }

        this.translate = this._translateX + "," + this._translateY;
      }
    },

    getter: {
      x: function() {
        return this._translateX || 0;
      },

      y: function() {
        return this._translateY || 0;
      },

      scale: function() {
        var s = (this.scale || "1,1").split(',');
        if (s[0]) { s[0] = parseFloat(s[0]); }
        if (s[1]) { s[1] = parseFloat(s[1]); }

        // "2.5,2.5" => 2.5
        // "2.5,1" => [2.5,1]
        return (s[0] === s[1]) ? s[0] : s;
      },

      rotate3d: function() {
        var s = (this.rotate3d || "0,0,0,0deg").split(',');
        for (var i=0; i<=3; ++i) {
          if (s[i]) { s[i] = parseFloat(s[i]); }
        }
        if (s[3]) { s[3] = unit(s[3], 'deg'); }

        return s;
      }
    },

    // ### parse()
    // Parses from a string. Called on constructor.
    parse: function(str) {
      var self = this;
      str.replace(/([a-zA-Z0-9]+)\((.*?)\)/g, function(x, prop, val) {
        self.setFromString(prop, val);
      });
    },

    // ### toString()
    // Converts to a `transition` CSS property string. If `use3d` is given,
    // it converts to a `-webkit-transition` CSS property string instead.
    toString: function(use3d) {
      var re = [];

      for (var i in this) {
        if (this.hasOwnProperty(i)) {
          // Don't use 3D transformations if the browser can't support it.
          if ((!support.transform3d) && (
            (i === 'rotateX') ||
            (i === 'rotateY') ||
            (i === 'perspective') ||
            (i === 'transformOrigin'))) { continue; }

          if (i[0] !== '_') {
            if (use3d && (i === 'scale')) {
              re.push(i + "3d(" + this[i] + ",1)");
            } else if (use3d && (i === 'translate')) {
              re.push(i + "3d(" + this[i] + ",0)");
            } else {
              re.push(i + "(" + this[i] + ")");
            }
          }
        }
      }

      return re.join(" ");
    }
  };

  function callOrQueue(self, queue, fn) {
    if (queue === true) {
      self.queue(fn);
    } else if (queue) {
      self.queue(queue, fn);
    } else {
      fn();
    }
  }

  // ### getProperties(dict)
  // Returns properties (for `transition-property`) for dictionary `props`. The
  // value of `props` is what you would expect in `$.css(...)`.
  function getProperties(props) {
    var re = [];

    $.each(props, function(key) {
      key = $.camelCase(key); // Convert "text-align" => "textAlign"
      key = $.transit.propertyMap[key] || $.cssProps[key] || key;
      key = uncamel(key); // Convert back to dasherized

      // Get vendor specify propertie
      if (support[key])
        key = uncamel(support[key]);

      if ($.inArray(key, re) === -1) { re.push(key); }
    });

    return re;
  }

  // ### getTransition()
  // Returns the transition string to be used for the `transition` CSS property.
  //
  // Example:
  //
  //     getTransition({ opacity: 1, rotate: 30 }, 500, 'ease');
  //     //=> 'opacity 500ms ease, -webkit-transform 500ms ease'
  //
  function getTransition(properties, duration, easing, delay) {
    // Get the CSS properties needed.
    var props = getProperties(properties);

    // Account for aliases (`in` => `ease-in`).
    if ($.cssEase[easing]) { easing = $.cssEase[easing]; }

    // Build the duration/easing/delay attributes for it.
    var attribs = '' + toMS(duration) + ' ' + easing;
    if (parseInt(delay, 10) > 0) { attribs += ' ' + toMS(delay); }

    // For more properties, add them this way:
    // "margin 200ms ease, padding 200ms ease, ..."
    var transitions = [];
    $.each(props, function(i, name) {
      transitions.push(name + ' ' + attribs);
    });

    return transitions.join(', ');
  }

  // ## $.fn.transition
  // Works like $.fn.animate(), but uses CSS transitions.
  //
  //     $("...").transition({ opacity: 0.1, scale: 0.3 });
  //
  //     // Specific duration
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500);
  //
  //     // With duration and easing
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in');
  //
  //     // With callback
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, function() { ... });
  //
  //     // With everything
  //     $("...").transition({ opacity: 0.1, scale: 0.3 }, 500, 'in', function() { ... });
  //
  //     // Alternate syntax
  //     $("...").transition({
  //       opacity: 0.1,
  //       duration: 200,
  //       delay: 40,
  //       easing: 'in',
  //       complete: function() { /* ... */ }
  //      });
  //
  $.fn.transition = $.fn.transit = function(properties, duration, easing, callback) {
    var self  = this;
    var delay = 0;
    var queue = true;

    var theseProperties = jQuery.extend(true, {}, properties);

    // Account for `.transition(properties, callback)`.
    if (typeof duration === 'function') {
      callback = duration;
      duration = undefined;
    }

    // Account for `.transition(properties, options)`.
    if (typeof duration === 'object') {
      easing = duration.easing;
      delay = duration.delay || 0;
      queue = duration.queue || true;
      callback = duration.complete;
      duration = duration.duration;
    }

    // Account for `.transition(properties, duration, callback)`.
    if (typeof easing === 'function') {
      callback = easing;
      easing = undefined;
    }

    // Alternate syntax.
    if (typeof theseProperties.easing !== 'undefined') {
      easing = theseProperties.easing;
      delete theseProperties.easing;
    }

    if (typeof theseProperties.duration !== 'undefined') {
      duration = theseProperties.duration;
      delete theseProperties.duration;
    }

    if (typeof theseProperties.complete !== 'undefined') {
      callback = theseProperties.complete;
      delete theseProperties.complete;
    }

    if (typeof theseProperties.queue !== 'undefined') {
      queue = theseProperties.queue;
      delete theseProperties.queue;
    }

    if (typeof theseProperties.delay !== 'undefined') {
      delay = theseProperties.delay;
      delete theseProperties.delay;
    }

    // Set defaults. (`400` duration, `ease` easing)
    if (typeof duration === 'undefined') { duration = $.fx.speeds._default; }
    if (typeof easing === 'undefined')   { easing = $.cssEase._default; }

    duration = toMS(duration);

    // Build the `transition` property.
    var transitionValue = getTransition(theseProperties, duration, easing, delay);

    // Compute delay until callback.
    // If this becomes 0, don't bother setting the transition property.
    var work = $.transit.enabled && support.transition;
    var i = work ? (parseInt(duration, 10) + parseInt(delay, 10)) : 0;

    // If there's nothing to do...
    if (i === 0) {
      var fn = function(next) {
        self.css(theseProperties);
        if (callback) { callback.apply(self); }
        if (next) { next(); }
      };

      callOrQueue(self, queue, fn);
      return self;
    }

    // Save the old transitions of each element so we can restore it later.
    var oldTransitions = {};

    var run = function(nextCall) {
      var bound = false;

      // Prepare the callback.
      var cb = function() {
        if (bound) { self.unbind(transitionEnd, cb); }

        if (i > 0) {
          self.each(function() {
            this.style[support.transition] = (oldTransitions[this] || null);
          });
        }

        if (typeof callback === 'function') { callback.apply(self); }
        if (typeof nextCall === 'function') { nextCall(); }
      };

      if ((i > 0) && (transitionEnd) && ($.transit.useTransitionEnd)) {
        // Use the 'transitionend' event if it's available.
        bound = true;
        self.bind(transitionEnd, cb);
      } else {
        // Fallback to timers if the 'transitionend' event isn't supported.
        window.setTimeout(cb, i);
      }

      // Apply transitions.
      self.each(function() {
        if (i > 0) {
          this.style[support.transition] = transitionValue;
        }
        $(this).css(properties);
      });
    };

    // Defer running. This allows the browser to paint any pending CSS it hasn't
    // painted yet before doing the transitions.
    var deferredRun = function(next) {
        this.offsetWidth; // force a repaint
        run(next);
    };

    // Use jQuery's fx queue.
    callOrQueue(self, queue, deferredRun);

    // Chainability.
    return this;
  };

  function registerCssHook(prop, isPixels) {
    // For certain properties, the 'px' should not be implied.
    if (!isPixels) { $.cssNumber[prop] = true; }

    $.transit.propertyMap[prop] = support.transform;

    $.cssHooks[prop] = {
      get: function(elem) {
        var t = $(elem).css('transit:transform');
        return t.get(prop);
      },

      set: function(elem, value) {
        var t = $(elem).css('transit:transform');
        t.setFromString(prop, value);

        $(elem).css({ 'transit:transform': t });
      }
    };

  }

  // ### uncamel(str)
  // Converts a camelcase string to a dasherized string.
  // (`marginLeft` => `margin-left`)
  function uncamel(str) {
    return str.replace(/([A-Z])/g, function(letter) { return '-' + letter.toLowerCase(); });
  }

  // ### unit(number, unit)
  // Ensures that number `number` has a unit. If no unit is found, assume the
  // default is `unit`.
  //
  //     unit(2, 'px')          //=> "2px"
  //     unit("30deg", 'rad')   //=> "30deg"
  //
  function unit(i, units) {
    if ((typeof i === "string") && (!i.match(/^[\-0-9\.]+$/))) {
      return i;
    } else {
      return "" + i + units;
    }
  }

  // ### toMS(duration)
  // Converts given `duration` to a millisecond string.
  //
  // toMS('fast') => $.fx.speeds[i] => "200ms"
  // toMS('normal') //=> $.fx.speeds._default => "400ms"
  // toMS(10) //=> '10ms'
  // toMS('100ms') //=> '100ms'  
  //
  function toMS(duration) {
    var i = duration;

    // Allow string durations like 'fast' and 'slow', without overriding numeric values.
    if (typeof i === 'string' && (!i.match(/^[\-0-9\.]+/))) { i = $.fx.speeds[i] || $.fx.speeds._default; }

    return unit(i, 'ms');
  }

  // Export some functions for testable-ness.
  $.transit.getTransitionValue = getTransition;
})(jQuery);

// HTML5 placeholder plugin version 1.1
// Copyright (c) 2010-2014, Rene Pot
// Thanks to Mike Taylor, http://miketaylr.com for setting up initial version
// MIT Licensed: http://www.opensource.org/licenses/mit-license.php
// GitHub: https://github.com/Topener/jQuery-html5-placeholder
//
// Enables cross-browser HTML5 placeholder for inputs, by first testing
// for a native implementation before building one.
//
// This is from the fork by Adam Lynch; https://github.com/adam-lynch/jQuery-html5-placeholder
//
//
// USAGE:
//$('input[placeholder]').placeholder();

// <input type="text" placeholder="username">
(function ($) {
	//feature detection
	var hasPlaceholder = 'placeholder' in document.createElement('input');

	//sniffy sniff sniff -- just to give extra left padding for the older
	//graphics for type=email and type=url
	var isOldOpera = window.opera && parseFloat(window.opera.version()) < 10.5;

	$.fn.placeholder = function (options) {
		var inheritStyle = false;//assume that default styling should be set

		if ("undefined" !== typeof options.inheritStyle) {

			if (options.inheritStyle) {
				inheritStyle = true;
			}
			else {//it was passed, but as a falsy value
				delete options.inheritStyle; //remove so it's not added to element later
			}
		}

		//merge in passed in options, if any and inheritStyle was not specified
		options = inheritStyle ? {} : $.extend({}, $.fn.placeholder.defaults, options);

		//cache the original 'left' value, for use by Opera later
		var o_left = options.placeholderCSS && options.placeholderCSS.left || 'auto';

		//first test for native placeholder support before continuing
		//feature detection inspired by ye olde jquery 1.4 hawtness, with paul irish
		return (hasPlaceholder) ? this : this.each(function () {
			//TODO: if this element already has a placeholder, exit

			//local vars
			var $this = $(this),
				inputVal = $.trim($this.val()),
				inputWidth = $this.width(),
				inputHeight = $this.height(),

			//grab the inputs id for the <label @for>, or make a new one from the Date
				inputId = (this.id) ? this.id : 'placeholder' + (Math.floor(Math.random() * 1123456789)),
				placeholderText = $this.attr('placeholder'),
				placeholderClass = 'polyfill-placeholder',
				placeholder = $('<label for=' + inputId + ' class="' + placeholderClass + '">' + placeholderText + '</label>');

			if ('undefined' === typeof options.placeholderCSS) {
				options.placeholderCSS = {};
			}
			//stuff in some calculated values into the placeholderCSS object
			options.placeholderCSS['width'] = inputWidth;
			options.placeholderCSS['height'] = inputHeight;
			options.placeholderCSS['color'] = options.placeholderCSS.color;

			// adjust position of placeholder
			options.placeholderCSS.left = (isOldOpera && (this.type == 'email' || this.type == 'url')) ?
				'11%' : o_left;
			placeholder.css(options.placeholderCSS);

			//place the placeholder
			if (options.inputWrapper) {
				$this.wrap(options.inputWrapper);
			}
			$this.attr('id', inputId).after(placeholder);

			//if the input isn't empty
			if (inputVal) {
				placeholder.hide();
			};

			//hide placeholder on focus
			$this.focus(function () {
				if (!$.trim($this.val()) || $this.siblings(".polyfill-placeholder")) { // ie8-9 fix for POW-1894
					placeholder.hide();
				};
			});

			//show placeholder if the input is empty
			$this.blur(function () {
				if (!$.trim($this.val())) {
					placeholder.show();
				};
			});
		});
	};

	//expose defaults
	$.fn.placeholder.defaults = {
		//you can pass in a custom wrapper
		inputWrapper: '<span style="position:relative; display:block;"></span>',

		//more or less just emulating what webkit does here
		//tweak to your hearts content
		placeholderCSS: {
			//'font': '0.75em sans-serif',
			//'color': '#bababa',
			'position': 'absolute',
			'left': '5px',
			'top': '3px',
			'overflow-x': 'hidden',
			'display': 'block',
			'cursor': 'text'
		}
	};
})(jQuery);

/// End file: jquery.html5placeholder.js

/*!
 * URI.js - Mutating URLs
 *
 * Version: 1.17.0
 *
 * Author: Rodney Rehm
 * Web: http://medialize.github.io/URI.js/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *   GPL v3 http://opensource.org/licenses/GPL-3.0
 *
 */
(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if (typeof exports === 'object') {
    // Node
    module.exports = factory(require('./punycode'), require('./IPv6'), require('./SecondLevelDomains'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['./punycode', './IPv6', './SecondLevelDomains'], factory);
  } else {
    // Browser globals (root is window)
    root.URI = factory(root.punycode, root.IPv6, root.SecondLevelDomains, root);
  }
}(this, function (punycode, IPv6, SLD, root) {
  'use strict';
  /*global location, escape, unescape */
  // FIXME: v2.0.0 renamce non-camelCase properties to uppercase
  /*jshint camelcase: false */

  // save current URI variable, if any
  var _URI = root && root.URI;

  function URI(url, base) {
    var _urlSupplied = arguments.length >= 1;
    var _baseSupplied = arguments.length >= 2;

    // Allow instantiation without the 'new' keyword
    if (!(this instanceof URI)) {
      if (_urlSupplied) {
        if (_baseSupplied) {
          return new URI(url, base);
        }

        return new URI(url);
      }

      return new URI();
    }

    if (url === undefined) {
      if (_urlSupplied) {
        throw new TypeError('undefined is not a valid argument for URI');
      }

      if (typeof location !== 'undefined') {
        url = location.href + '';
      } else {
        url = '';
      }
    }

    this.href(url);

    // resolve to base according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#constructor
    if (base !== undefined) {
      return this.absoluteTo(base);
    }

    return this;
  }

  URI.version = '1.17.0';

  var p = URI.prototype;
  var hasOwn = Object.prototype.hasOwnProperty;

  function escapeRegEx(string) {
    // https://github.com/medialize/URI.js/commit/85ac21783c11f8ccab06106dba9735a31a86924d#commitcomment-821963
    return string.replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
  }

  function getType(value) {
    // IE8 doesn't return [Object Undefined] but [Object Object] for undefined value
    if (value === undefined) {
      return 'Undefined';
    }

    return String(Object.prototype.toString.call(value)).slice(8, -1);
  }

  function isArray(obj) {
    return getType(obj) === 'Array';
  }

  function filterArrayValues(data, value) {
    var lookup = {};
    var i, length;

    if (getType(value) === 'RegExp') {
      lookup = null;
    } else if (isArray(value)) {
      for (i = 0, length = value.length; i < length; i++) {
        lookup[value[i]] = true;
      }
    } else {
      lookup[value] = true;
    }

    for (i = 0, length = data.length; i < length; i++) {
      /*jshint laxbreak: true */
      var _match = lookup && lookup[data[i]] !== undefined
        || !lookup && value.test(data[i]);
      /*jshint laxbreak: false */
      if (_match) {
        data.splice(i, 1);
        length--;
        i--;
      }
    }

    return data;
  }

  function arrayContains(list, value) {
    var i, length;

    // value may be string, number, array, regexp
    if (isArray(value)) {
      // Note: this can be optimized to O(n) (instead of current O(m * n))
      for (i = 0, length = value.length; i < length; i++) {
        if (!arrayContains(list, value[i])) {
          return false;
        }
      }

      return true;
    }

    var _type = getType(value);
    for (i = 0, length = list.length; i < length; i++) {
      if (_type === 'RegExp') {
        if (typeof list[i] === 'string' && list[i].match(value)) {
          return true;
        }
      } else if (list[i] === value) {
        return true;
      }
    }

    return false;
  }

  function arraysEqual(one, two) {
    if (!isArray(one) || !isArray(two)) {
      return false;
    }

    // arrays can't be equal if they have different amount of content
    if (one.length !== two.length) {
      return false;
    }

    one.sort();
    two.sort();

    for (var i = 0, l = one.length; i < l; i++) {
      if (one[i] !== two[i]) {
        return false;
      }
    }

    return true;
  }

  function trimSlashes(text) {
    var trim_expression = /^\/+|\/+$/g;
    return text.replace(trim_expression, '');
  }

  URI._parts = function() {
    return {
      protocol: null,
      username: null,
      password: null,
      hostname: null,
      urn: null,
      port: null,
      path: null,
      query: null,
      fragment: null,
      // state
      duplicateQueryParameters: URI.duplicateQueryParameters,
      escapeQuerySpace: URI.escapeQuerySpace
    };
  };
  // state: allow duplicate query parameters (a=1&a=1)
  URI.duplicateQueryParameters = false;
  // state: replaces + with %20 (space in query strings)
  URI.escapeQuerySpace = true;
  // static properties
  URI.protocol_expression = /^[a-z][a-z0-9.+-]*$/i;
  URI.idn_expression = /[^a-z0-9\.-]/i;
  URI.punycode_expression = /(xn--)/i;
  // well, 333.444.555.666 matches, but it sure ain't no IPv4 - do we care?
  URI.ip4_expression = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/;
  // credits to Rich Brown
  // source: http://forums.intermapper.com/viewtopic.php?p=1096#1096
  // specification: http://www.ietf.org/rfc/rfc4291.txt
  URI.ip6_expression = /^\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(%.+)?\s*$/;
  // expression used is "gruber revised" (@gruber v2) determined to be the
  // best solution in a regex-golf we did a couple of ages ago at
  // * http://mathiasbynens.be/demo/url-regex
  // * http://rodneyrehm.de/t/url-regex.html
  URI.find_uri_expression = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/ig;
  URI.findUri = {
    // valid "scheme://" or "www."
    start: /\b(?:([a-z][a-z0-9.+-]*:\/\/)|www\.)/gi,
    // everything up to the next whitespace
    end: /[\s\r\n]|$/,
    // trim trailing punctuation captured by end RegExp
    trim: /[`!()\[\]{};:'".,<>?«»“”„‘’]+$/
  };
  // http://www.iana.org/assignments/uri-schemes.html
  // http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers#Well-known_ports
  URI.defaultPorts = {
    http: '80',
    https: '443',
    ftp: '21',
    gopher: '70',
    ws: '80',
    wss: '443'
  };
  // allowed hostname characters according to RFC 3986
  // ALPHA DIGIT "-" "." "_" "~" "!" "$" "&" "'" "(" ")" "*" "+" "," ";" "=" %encoded
  // I've never seen a (non-IDN) hostname other than: ALPHA DIGIT . -
  URI.invalid_hostname_characters = /[^a-zA-Z0-9\.-]/;
  // map DOM Elements to their URI attribute
  URI.domAttributes = {
    'a': 'href',
    'blockquote': 'cite',
    'link': 'href',
    'base': 'href',
    'script': 'src',
    'form': 'action',
    'img': 'src',
    'area': 'href',
    'iframe': 'src',
    'embed': 'src',
    'source': 'src',
    'track': 'src',
    'input': 'src', // but only if type="image"
    'audio': 'src',
    'video': 'src'
  };
  URI.getDomAttribute = function(node) {
    if (!node || !node.nodeName) {
      return undefined;
    }

    var nodeName = node.nodeName.toLowerCase();
    // <input> should only expose src for type="image"
    if (nodeName === 'input' && node.type !== 'image') {
      return undefined;
    }

    return URI.domAttributes[nodeName];
  };

  function escapeForDumbFirefox36(value) {
    // https://github.com/medialize/URI.js/issues/91
    return escape(value);
  }

  // encoding / decoding according to RFC3986
  function strictEncodeURIComponent(string) {
    // see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/encodeURIComponent
    return encodeURIComponent(string)
      .replace(/[!'()*]/g, escapeForDumbFirefox36)
      .replace(/\*/g, '%2A');
  }
  URI.encode = strictEncodeURIComponent;
  URI.decode = decodeURIComponent;
  URI.iso8859 = function() {
    URI.encode = escape;
    URI.decode = unescape;
  };
  URI.unicode = function() {
    URI.encode = strictEncodeURIComponent;
    URI.decode = decodeURIComponent;
  };
  URI.characters = {
    pathname: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(24|26|2B|2C|3B|3D|3A|40)/ig,
        map: {
          // -._~!'()*
          '%24': '$',
          '%26': '&',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%3A': ':',
          '%40': '@'
        }
      },
      decode: {
        expression: /[\/\?#]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23'
        }
      }
    },
    reserved: {
      encode: {
        // RFC3986 2.1: For consistency, URI producers and normalizers should
        // use uppercase hexadecimal digits for all percent-encodings.
        expression: /%(21|23|24|26|27|28|29|2A|2B|2C|2F|3A|3B|3D|3F|40|5B|5D)/ig,
        map: {
          // gen-delims
          '%3A': ':',
          '%2F': '/',
          '%3F': '?',
          '%23': '#',
          '%5B': '[',
          '%5D': ']',
          '%40': '@',
          // sub-delims
          '%21': '!',
          '%24': '$',
          '%26': '&',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '='
        }
      }
    },
    urnpath: {
      // The characters under `encode` are the characters called out by RFC 2141 as being acceptable
      // for usage in a URN. RFC2141 also calls out "-", ".", and "_" as acceptable characters, but
      // these aren't encoded by encodeURIComponent, so we don't have to call them out here. Also
      // note that the colon character is not featured in the encoding map; this is because URI.js
      // gives the colons in URNs semantic meaning as the delimiters of path segements, and so it
      // should not appear unencoded in a segment itself.
      // See also the note above about RFC3986 and capitalalized hex digits.
      encode: {
        expression: /%(21|24|27|28|29|2A|2B|2C|3B|3D|40)/ig,
        map: {
          '%21': '!',
          '%24': '$',
          '%27': '\'',
          '%28': '(',
          '%29': ')',
          '%2A': '*',
          '%2B': '+',
          '%2C': ',',
          '%3B': ';',
          '%3D': '=',
          '%40': '@'
        }
      },
      // These characters are the characters called out by RFC2141 as "reserved" characters that
      // should never appear in a URN, plus the colon character (see note above).
      decode: {
        expression: /[\/\?#:]/g,
        map: {
          '/': '%2F',
          '?': '%3F',
          '#': '%23',
          ':': '%3A'
        }
      }
    }
  };
  URI.encodeQuery = function(string, escapeQuerySpace) {
    var escaped = URI.encode(string + '');
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    return escapeQuerySpace ? escaped.replace(/%20/g, '+') : escaped;
  };
  URI.decodeQuery = function(string, escapeQuerySpace) {
    string += '';
    if (escapeQuerySpace === undefined) {
      escapeQuerySpace = URI.escapeQuerySpace;
    }

    try {
      return URI.decode(escapeQuerySpace ? string.replace(/\+/g, '%20') : string);
    } catch(e) {
      // we're not going to mess with weird encodings,
      // give up and return the undecoded original string
      // see https://github.com/medialize/URI.js/issues/87
      // see https://github.com/medialize/URI.js/issues/92
      return string;
    }
  };
  // generate encode/decode path functions
  var _parts = {'encode':'encode', 'decode':'decode'};
  var _part;
  var generateAccessor = function(_group, _part) {
    return function(string) {
      try {
        return URI[_part](string + '').replace(URI.characters[_group][_part].expression, function(c) {
          return URI.characters[_group][_part].map[c];
        });
      } catch (e) {
        // we're not going to mess with weird encodings,
        // give up and return the undecoded original string
        // see https://github.com/medialize/URI.js/issues/87
        // see https://github.com/medialize/URI.js/issues/92
        return string;
      }
    };
  };

  for (_part in _parts) {
    URI[_part + 'PathSegment'] = generateAccessor('pathname', _parts[_part]);
    URI[_part + 'UrnPathSegment'] = generateAccessor('urnpath', _parts[_part]);
  }

  var generateSegmentedPathFunction = function(_sep, _codingFuncName, _innerCodingFuncName) {
    return function(string) {
      // Why pass in names of functions, rather than the function objects themselves? The
      // definitions of some functions (but in particular, URI.decode) will occasionally change due
      // to URI.js having ISO8859 and Unicode modes. Passing in the name and getting it will ensure
      // that the functions we use here are "fresh".
      var actualCodingFunc;
      if (!_innerCodingFuncName) {
        actualCodingFunc = URI[_codingFuncName];
      } else {
        actualCodingFunc = function(string) {
          return URI[_codingFuncName](URI[_innerCodingFuncName](string));
        };
      }

      var segments = (string + '').split(_sep);

      for (var i = 0, length = segments.length; i < length; i++) {
        segments[i] = actualCodingFunc(segments[i]);
      }

      return segments.join(_sep);
    };
  };

  // This takes place outside the above loop because we don't want, e.g., encodeUrnPath functions.
  URI.decodePath = generateSegmentedPathFunction('/', 'decodePathSegment');
  URI.decodeUrnPath = generateSegmentedPathFunction(':', 'decodeUrnPathSegment');
  URI.recodePath = generateSegmentedPathFunction('/', 'encodePathSegment', 'decode');
  URI.recodeUrnPath = generateSegmentedPathFunction(':', 'encodeUrnPathSegment', 'decode');

  URI.encodeReserved = generateAccessor('reserved', 'encode');

  URI.parse = function(string, parts) {
    var pos;
    if (!parts) {
      parts = {};
    }
    // [protocol"://"[username[":"password]"@"]hostname[":"port]"/"?][path]["?"querystring]["#"fragment]

    // extract fragment
    pos = string.indexOf('#');
    if (pos > -1) {
      // escaping?
      parts.fragment = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract query
    pos = string.indexOf('?');
    if (pos > -1) {
      // escaping?
      parts.query = string.substring(pos + 1) || null;
      string = string.substring(0, pos);
    }

    // extract protocol
    if (string.substring(0, 2) === '//') {
      // relative-scheme
      parts.protocol = null;
      string = string.substring(2);
      // extract "user:pass@host:port"
      string = URI.parseAuthority(string, parts);
    } else {
      pos = string.indexOf(':');
      if (pos > -1) {
        parts.protocol = string.substring(0, pos) || null;
        if (parts.protocol && !parts.protocol.match(URI.protocol_expression)) {
          // : may be within the path
          parts.protocol = undefined;
        } else if (string.substring(pos + 1, pos + 3) === '//') {
          string = string.substring(pos + 3);

          // extract "user:pass@host:port"
          string = URI.parseAuthority(string, parts);
        } else {
          string = string.substring(pos + 1);
          parts.urn = true;
        }
      }
    }

    // what's left must be the path
    parts.path = string;

    // and we're done
    return parts;
  };
  URI.parseHost = function(string, parts) {
    // Copy chrome, IE, opera backslash-handling behavior.
    // Back slashes before the query string get converted to forward slashes
    // See: https://github.com/joyent/node/blob/386fd24f49b0e9d1a8a076592a404168faeecc34/lib/url.js#L115-L124
    // See: https://code.google.com/p/chromium/issues/detail?id=25916
    // https://github.com/medialize/URI.js/pull/233
    string = string.replace(/\\/g, '/');

    // extract host:port
    var pos = string.indexOf('/');
    var bracketPos;
    var t;

    if (pos === -1) {
      pos = string.length;
    }

    if (string.charAt(0) === '[') {
      // IPv6 host - http://tools.ietf.org/html/draft-ietf-6man-text-addr-representation-04#section-6
      // I claim most client software breaks on IPv6 anyways. To simplify things, URI only accepts
      // IPv6+port in the format [2001:db8::1]:80 (for the time being)
      bracketPos = string.indexOf(']');
      parts.hostname = string.substring(1, bracketPos) || null;
      parts.port = string.substring(bracketPos + 2, pos) || null;
      if (parts.port === '/') {
        parts.port = null;
      }
    } else {
      var firstColon = string.indexOf(':');
      var firstSlash = string.indexOf('/');
      var nextColon = string.indexOf(':', firstColon + 1);
      if (nextColon !== -1 && (firstSlash === -1 || nextColon < firstSlash)) {
        // IPv6 host contains multiple colons - but no port
        // this notation is actually not allowed by RFC 3986, but we're a liberal parser
        parts.hostname = string.substring(0, pos) || null;
        parts.port = null;
      } else {
        t = string.substring(0, pos).split(':');
        parts.hostname = t[0] || null;
        parts.port = t[1] || null;
      }
    }

    if (parts.hostname && string.substring(pos).charAt(0) !== '/') {
      pos++;
      string = '/' + string;
    }

    return string.substring(pos) || '/';
  };
  URI.parseAuthority = function(string, parts) {
    string = URI.parseUserinfo(string, parts);
    return URI.parseHost(string, parts);
  };
  URI.parseUserinfo = function(string, parts) {
    // extract username:password
    var firstSlash = string.indexOf('/');
    var pos = string.lastIndexOf('@', firstSlash > -1 ? firstSlash : string.length - 1);
    var t;

    // authority@ must come before /path
    if (pos > -1 && (firstSlash === -1 || pos < firstSlash)) {
      t = string.substring(0, pos).split(':');
      parts.username = t[0] ? URI.decode(t[0]) : null;
      t.shift();
      parts.password = t[0] ? URI.decode(t.join(':')) : null;
      string = string.substring(pos + 1);
    } else {
      parts.username = null;
      parts.password = null;
    }

    return string;
  };
  URI.parseQuery = function(string, escapeQuerySpace) {
    if (!string) {
      return {};
    }

    // throw out the funky business - "?"[name"="value"&"]+
    string = string.replace(/&+/g, '&').replace(/^\?*&*|&+$/g, '');

    if (!string) {
      return {};
    }

    var items = {};
    var splits = string.split('&');
    var length = splits.length;
    var v, name, value;

    for (var i = 0; i < length; i++) {
      v = splits[i].split('=');
      name = URI.decodeQuery(v.shift(), escapeQuerySpace);
      // no "=" is null according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#collect-url-parameters
      value = v.length ? URI.decodeQuery(v.join('='), escapeQuerySpace) : null;

      if (hasOwn.call(items, name)) {
        if (typeof items[name] === 'string' || items[name] === null) {
          items[name] = [items[name]];
        }

        items[name].push(value);
      } else {
        items[name] = value;
      }
    }

    return items;
  };

  URI.build = function(parts) {
    var t = '';

    if (parts.protocol) {
      t += parts.protocol + ':';
    }

    if (!parts.urn && (t || parts.hostname)) {
      t += '//';
    }

    t += (URI.buildAuthority(parts) || '');

    if (typeof parts.path === 'string') {
      if (parts.path.charAt(0) !== '/' && typeof parts.hostname === 'string') {
        t += '/';
      }

      t += parts.path;
    }

    if (typeof parts.query === 'string' && parts.query) {
      t += '?' + parts.query;
    }

    if (typeof parts.fragment === 'string' && parts.fragment) {
      t += '#' + parts.fragment;
    }
    return t;
  };
  URI.buildHost = function(parts) {
    var t = '';

    if (!parts.hostname) {
      return '';
    } else if (URI.ip6_expression.test(parts.hostname)) {
      t += '[' + parts.hostname + ']';
    } else {
      t += parts.hostname;
    }

    if (parts.port) {
      t += ':' + parts.port;
    }

    return t;
  };
  URI.buildAuthority = function(parts) {
    return URI.buildUserinfo(parts) + URI.buildHost(parts);
  };
  URI.buildUserinfo = function(parts) {
    var t = '';

    if (parts.username) {
      t += URI.encode(parts.username);

      if (parts.password) {
        t += ':' + URI.encode(parts.password);
      }

      t += '@';
    }

    return t;
  };
  URI.buildQuery = function(data, duplicateQueryParameters, escapeQuerySpace) {
    // according to http://tools.ietf.org/html/rfc3986 or http://labs.apache.org/webarch/uri/rfc/rfc3986.html
    // being »-._~!$&'()*+,;=:@/?« %HEX and alnum are allowed
    // the RFC explicitly states ?/foo being a valid use case, no mention of parameter syntax!
    // URI.js treats the query string as being application/x-www-form-urlencoded
    // see http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type

    var t = '';
    var unique, key, i, length;
    for (key in data) {
      if (hasOwn.call(data, key) && key) {
        if (isArray(data[key])) {
          unique = {};
          for (i = 0, length = data[key].length; i < length; i++) {
            if (data[key][i] !== undefined && unique[data[key][i] + ''] === undefined) {
              t += '&' + URI.buildQueryParameter(key, data[key][i], escapeQuerySpace);
              if (duplicateQueryParameters !== true) {
                unique[data[key][i] + ''] = true;
              }
            }
          }
        } else if (data[key] !== undefined) {
          t += '&' + URI.buildQueryParameter(key, data[key], escapeQuerySpace);
        }
      }
    }

    return t.substring(1);
  };
  URI.buildQueryParameter = function(name, value, escapeQuerySpace) {
    // http://www.w3.org/TR/REC-html40/interact/forms.html#form-content-type -- application/x-www-form-urlencoded
    // don't append "=" for null values, according to http://dvcs.w3.org/hg/url/raw-file/tip/Overview.html#url-parameter-serialization
    return URI.encodeQuery(name, escapeQuerySpace) + (value !== null ? '=' + URI.encodeQuery(value, escapeQuerySpace) : '');
  };

  URI.addQuery = function(data, name, value) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          URI.addQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (data[name] === undefined) {
        data[name] = value;
        return;
      } else if (typeof data[name] === 'string') {
        data[name] = [data[name]];
      }

      if (!isArray(value)) {
        value = [value];
      }

      data[name] = (data[name] || []).concat(value);
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }
  };
  URI.removeQuery = function(data, name, value) {
    var i, length, key;

    if (isArray(name)) {
      for (i = 0, length = name.length; i < length; i++) {
        data[name[i]] = undefined;
      }
    } else if (getType(name) === 'RegExp') {
      for (key in data) {
        if (name.test(key)) {
          data[key] = undefined;
        }
      }
    } else if (typeof name === 'object') {
      for (key in name) {
        if (hasOwn.call(name, key)) {
          URI.removeQuery(data, key, name[key]);
        }
      }
    } else if (typeof name === 'string') {
      if (value !== undefined) {
        if (getType(value) === 'RegExp') {
          if (!isArray(data[name]) && value.test(data[name])) {
            data[name] = undefined;
          } else {
            data[name] = filterArrayValues(data[name], value);
          }
        } else if (data[name] === String(value) && (!isArray(value) || value.length === 1)) {
          data[name] = undefined;
        } else if (isArray(data[name])) {
          data[name] = filterArrayValues(data[name], value);
        }
      } else {
        data[name] = undefined;
      }
    } else {
      throw new TypeError('URI.removeQuery() accepts an object, string, RegExp as the first parameter');
    }
  };
  URI.hasQuery = function(data, name, value, withinArray) {
    if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          if (!URI.hasQuery(data, key, name[key])) {
            return false;
          }
        }
      }

      return true;
    } else if (typeof name !== 'string') {
      throw new TypeError('URI.hasQuery() accepts an object, string as the name parameter');
    }

    switch (getType(value)) {
      case 'Undefined':
        // true if exists (but may be empty)
        return name in data; // data[name] !== undefined;

      case 'Boolean':
        // true if exists and non-empty
        var _booly = Boolean(isArray(data[name]) ? data[name].length : data[name]);
        return value === _booly;

      case 'Function':
        // allow complex comparison
        return !!value(data[name], name, data);

      case 'Array':
        if (!isArray(data[name])) {
          return false;
        }

        var op = withinArray ? arrayContains : arraysEqual;
        return op(data[name], value);

      case 'RegExp':
        if (!isArray(data[name])) {
          return Boolean(data[name] && data[name].match(value));
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      case 'Number':
        value = String(value);
        /* falls through */
      case 'String':
        if (!isArray(data[name])) {
          return data[name] === value;
        }

        if (!withinArray) {
          return false;
        }

        return arrayContains(data[name], value);

      default:
        throw new TypeError('URI.hasQuery() accepts undefined, boolean, string, number, RegExp, Function as the value parameter');
    }
  };


  URI.commonPath = function(one, two) {
    var length = Math.min(one.length, two.length);
    var pos;

    // find first non-matching character
    for (pos = 0; pos < length; pos++) {
      if (one.charAt(pos) !== two.charAt(pos)) {
        pos--;
        break;
      }
    }

    if (pos < 1) {
      return one.charAt(0) === two.charAt(0) && one.charAt(0) === '/' ? '/' : '';
    }

    // revert to last /
    if (one.charAt(pos) !== '/' || two.charAt(pos) !== '/') {
      pos = one.substring(0, pos).lastIndexOf('/');
    }

    return one.substring(0, pos + 1);
  };

  URI.withinString = function(string, callback, options) {
    options || (options = {});
    var _start = options.start || URI.findUri.start;
    var _end = options.end || URI.findUri.end;
    var _trim = options.trim || URI.findUri.trim;
    var _attributeOpen = /[a-z0-9-]=["']?$/i;

    _start.lastIndex = 0;
    while (true) {
      var match = _start.exec(string);
      if (!match) {
        break;
      }

      var start = match.index;
      if (options.ignoreHtml) {
        // attribut(e=["']?$)
        var attributeOpen = string.slice(Math.max(start - 3, 0), start);
        if (attributeOpen && _attributeOpen.test(attributeOpen)) {
          continue;
        }
      }

      var end = start + string.slice(start).search(_end);
      var slice = string.slice(start, end).replace(_trim, '');
      if (options.ignore && options.ignore.test(slice)) {
        continue;
      }

      end = start + slice.length;
      var result = callback(slice, start, end, string);
      string = string.slice(0, start) + result + string.slice(end);
      _start.lastIndex = start + result.length;
    }

    _start.lastIndex = 0;
    return string;
  };

  URI.ensureValidHostname = function(v) {
    // Theoretically URIs allow percent-encoding in Hostnames (according to RFC 3986)
    // they are not part of DNS and therefore ignored by URI.js

    if (v.match(URI.invalid_hostname_characters)) {
      // test punycode
      if (!punycode) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-] and Punycode.js is not available');
      }

      if (punycode.toASCII(v).match(URI.invalid_hostname_characters)) {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }
    }
  };

  // noConflict
  URI.noConflict = function(removeAll) {
    if (removeAll) {
      var unconflicted = {
        URI: this.noConflict()
      };

      if (root.URITemplate && typeof root.URITemplate.noConflict === 'function') {
        unconflicted.URITemplate = root.URITemplate.noConflict();
      }

      if (root.IPv6 && typeof root.IPv6.noConflict === 'function') {
        unconflicted.IPv6 = root.IPv6.noConflict();
      }

      if (root.SecondLevelDomains && typeof root.SecondLevelDomains.noConflict === 'function') {
        unconflicted.SecondLevelDomains = root.SecondLevelDomains.noConflict();
      }

      return unconflicted;
    } else if (root.URI === this) {
      root.URI = _URI;
    }

    return this;
  };

  p.build = function(deferBuild) {
    if (deferBuild === true) {
      this._deferred_build = true;
    } else if (deferBuild === undefined || this._deferred_build) {
      this._string = URI.build(this._parts);
      this._deferred_build = false;
    }

    return this;
  };

  p.clone = function() {
    return new URI(this);
  };

  p.valueOf = p.toString = function() {
    return this.build(false)._string;
  };


  function generateSimpleAccessor(_part){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        this._parts[_part] = v || null;
        this.build(!build);
        return this;
      }
    };
  }

  function generatePrefixAccessor(_part, _key){
    return function(v, build) {
      if (v === undefined) {
        return this._parts[_part] || '';
      } else {
        if (v !== null) {
          v = v + '';
          if (v.charAt(0) === _key) {
            v = v.substring(1);
          }
        }

        this._parts[_part] = v;
        this.build(!build);
        return this;
      }
    };
  }

  p.protocol = generateSimpleAccessor('protocol');
  p.username = generateSimpleAccessor('username');
  p.password = generateSimpleAccessor('password');
  p.hostname = generateSimpleAccessor('hostname');
  p.port = generateSimpleAccessor('port');
  p.query = generatePrefixAccessor('query', '?');
  p.fragment = generatePrefixAccessor('fragment', '#');

  p.search = function(v, build) {
    var t = this.query(v, build);
    return typeof t === 'string' && t.length ? ('?' + t) : t;
  };
  p.hash = function(v, build) {
    var t = this.fragment(v, build);
    return typeof t === 'string' && t.length ? ('#' + t) : t;
  };

  p.pathname = function(v, build) {
    if (v === undefined || v === true) {
      var res = this._parts.path || (this._parts.hostname ? '/' : '');
      return v ? (this._parts.urn ? URI.decodeUrnPath : URI.decodePath)(res) : res;
    } else {
      if (this._parts.urn) {
        this._parts.path = v ? URI.recodeUrnPath(v) : '';
      } else {
        this._parts.path = v ? URI.recodePath(v) : '/';
      }
      this.build(!build);
      return this;
    }
  };
  p.path = p.pathname;
  p.href = function(href, build) {
    var key;

    if (href === undefined) {
      return this.toString();
    }

    this._string = '';
    this._parts = URI._parts();

    var _URI = href instanceof URI;
    var _object = typeof href === 'object' && (href.hostname || href.path || href.pathname);
    if (href.nodeName) {
      var attribute = URI.getDomAttribute(href);
      href = href[attribute] || '';
      _object = false;
    }

    // window.location is reported to be an object, but it's not the sort
    // of object we're looking for:
    // * location.protocol ends with a colon
    // * location.query != object.search
    // * location.hash != object.fragment
    // simply serializing the unknown object should do the trick
    // (for location, not for everything...)
    if (!_URI && _object && href.pathname !== undefined) {
      href = href.toString();
    }

    if (typeof href === 'string' || href instanceof String) {
      this._parts = URI.parse(String(href), this._parts);
    } else if (_URI || _object) {
      var src = _URI ? href._parts : href;
      for (key in src) {
        if (hasOwn.call(this._parts, key)) {
          this._parts[key] = src[key];
        }
      }
    } else {
      throw new TypeError('invalid input');
    }

    this.build(!build);
    return this;
  };

  // identification accessors
  p.is = function(what) {
    var ip = false;
    var ip4 = false;
    var ip6 = false;
    var name = false;
    var sld = false;
    var idn = false;
    var punycode = false;
    var relative = !this._parts.urn;

    if (this._parts.hostname) {
      relative = false;
      ip4 = URI.ip4_expression.test(this._parts.hostname);
      ip6 = URI.ip6_expression.test(this._parts.hostname);
      ip = ip4 || ip6;
      name = !ip;
      sld = name && SLD && SLD.has(this._parts.hostname);
      idn = name && URI.idn_expression.test(this._parts.hostname);
      punycode = name && URI.punycode_expression.test(this._parts.hostname);
    }

    switch (what.toLowerCase()) {
      case 'relative':
        return relative;

      case 'absolute':
        return !relative;

      // hostname identification
      case 'domain':
      case 'name':
        return name;

      case 'sld':
        return sld;

      case 'ip':
        return ip;

      case 'ip4':
      case 'ipv4':
      case 'inet4':
        return ip4;

      case 'ip6':
      case 'ipv6':
      case 'inet6':
        return ip6;

      case 'idn':
        return idn;

      case 'url':
        return !this._parts.urn;

      case 'urn':
        return !!this._parts.urn;

      case 'punycode':
        return punycode;
    }

    return null;
  };

  // component specific input validation
  var _protocol = p.protocol;
  var _port = p.port;
  var _hostname = p.hostname;

  p.protocol = function(v, build) {
    if (v !== undefined) {
      if (v) {
        // accept trailing ://
        v = v.replace(/:(\/\/)?$/, '');

        if (!v.match(URI.protocol_expression)) {
          throw new TypeError('Protocol "' + v + '" contains characters other than [A-Z0-9.+-] or doesn\'t start with [A-Z]');
        }
      }
    }
    return _protocol.call(this, v, build);
  };
  p.scheme = p.protocol;
  p.port = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      if (v === 0) {
        v = null;
      }

      if (v) {
        v += '';
        if (v.charAt(0) === ':') {
          v = v.substring(1);
        }

        if (v.match(/[^0-9]/)) {
          throw new TypeError('Port "' + v + '" contains characters other than [0-9]');
        }
      }
    }
    return _port.call(this, v, build);
  };
  p.hostname = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v !== undefined) {
      var x = {};
      var res = URI.parseHost(v, x);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      v = x.hostname;
    }
    return _hostname.call(this, v, build);
  };

  // compound accessors
  p.origin = function(v, build) {
    var parts;

    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      var protocol = this.protocol();
      var authority = this.authority();
      if (!authority) return '';
      return (protocol ? protocol + '://' : '') + this.authority();
    } else {
      var origin = URI(v);
      this
        .protocol(origin.protocol())
        .authority(origin.authority())
        .build(!build);
      return this;
    }
  };
  p.host = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildHost(this._parts) : '';
    } else {
      var res = URI.parseHost(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.authority = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      return this._parts.hostname ? URI.buildAuthority(this._parts) : '';
    } else {
      var res = URI.parseAuthority(v, this._parts);
      if (res !== '/') {
        throw new TypeError('Hostname "' + v + '" contains characters other than [A-Z0-9.-]');
      }

      this.build(!build);
      return this;
    }
  };
  p.userinfo = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined) {
      if (!this._parts.username) {
        return '';
      }

      var t = URI.buildUserinfo(this._parts);
      return t.substring(0, t.length -1);
    } else {
      if (v[v.length-1] !== '@') {
        v += '@';
      }

      URI.parseUserinfo(v, this._parts);
      this.build(!build);
      return this;
    }
  };
  p.resource = function(v, build) {
    var parts;

    if (v === undefined) {
      return this.path() + this.search() + this.hash();
    }

    parts = URI.parse(v);
    this._parts.path = parts.path;
    this._parts.query = parts.query;
    this._parts.fragment = parts.fragment;
    this.build(!build);
    return this;
  };

  // fraction accessors
  p.subdomain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    // convenience, return "www" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // grab domain and add another segment
      var end = this._parts.hostname.length - this.domain().length - 1;
      return this._parts.hostname.substring(0, end) || '';
    } else {
      var e = this._parts.hostname.length - this.domain().length;
      var sub = this._parts.hostname.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(sub));

      if (v && v.charAt(v.length - 1) !== '.') {
        v += '.';
      }

      if (v) {
        URI.ensureValidHostname(v);
      }

      this._parts.hostname = this._parts.hostname.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.domain = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // convenience, return "example.org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      // if hostname consists of 1 or 2 segments, it must be the domain
      var t = this._parts.hostname.match(/\./g);
      if (t && t.length < 2) {
        return this._parts.hostname;
      }

      // grab tld and add another segment
      var end = this._parts.hostname.length - this.tld(build).length - 1;
      end = this._parts.hostname.lastIndexOf('.', end -1) + 1;
      return this._parts.hostname.substring(end) || '';
    } else {
      if (!v) {
        throw new TypeError('cannot set domain empty');
      }

      URI.ensureValidHostname(v);

      if (!this._parts.hostname || this.is('IP')) {
        this._parts.hostname = v;
      } else {
        var replace = new RegExp(escapeRegEx(this.domain()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.tld = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (typeof v === 'boolean') {
      build = v;
      v = undefined;
    }

    // return "org" from "www.example.org"
    if (v === undefined) {
      if (!this._parts.hostname || this.is('IP')) {
        return '';
      }

      var pos = this._parts.hostname.lastIndexOf('.');
      var tld = this._parts.hostname.substring(pos + 1);

      if (build !== true && SLD && SLD.list[tld.toLowerCase()]) {
        return SLD.get(this._parts.hostname) || tld;
      }

      return tld;
    } else {
      var replace;

      if (!v) {
        throw new TypeError('cannot set TLD empty');
      } else if (v.match(/[^a-zA-Z0-9-]/)) {
        if (SLD && SLD.is(v)) {
          replace = new RegExp(escapeRegEx(this.tld()) + '$');
          this._parts.hostname = this._parts.hostname.replace(replace, v);
        } else {
          throw new TypeError('TLD "' + v + '" contains characters other than [A-Z0-9]');
        }
      } else if (!this._parts.hostname || this.is('IP')) {
        throw new ReferenceError('cannot set TLD on non-domain host');
      } else {
        replace = new RegExp(escapeRegEx(this.tld()) + '$');
        this._parts.hostname = this._parts.hostname.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.directory = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path && !this._parts.hostname) {
        return '';
      }

      if (this._parts.path === '/') {
        return '/';
      }

      var end = this._parts.path.length - this.filename().length - 1;
      var res = this._parts.path.substring(0, end) || (this._parts.hostname ? '/' : '');

      return v ? URI.decodePath(res) : res;

    } else {
      var e = this._parts.path.length - this.filename().length;
      var directory = this._parts.path.substring(0, e);
      var replace = new RegExp('^' + escapeRegEx(directory));

      // fully qualifier directories begin with a slash
      if (!this.is('relative')) {
        if (!v) {
          v = '/';
        }

        if (v.charAt(0) !== '/') {
          v = '/' + v;
        }
      }

      // directories always end with a slash
      if (v && v.charAt(v.length - 1) !== '/') {
        v += '/';
      }

      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);
      this.build(!build);
      return this;
    }
  };
  p.filename = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var pos = this._parts.path.lastIndexOf('/');
      var res = this._parts.path.substring(pos+1);

      return v ? URI.decodePathSegment(res) : res;
    } else {
      var mutatedDirectory = false;

      if (v.charAt(0) === '/') {
        v = v.substring(1);
      }

      if (v.match(/\.?\//)) {
        mutatedDirectory = true;
      }

      var replace = new RegExp(escapeRegEx(this.filename()) + '$');
      v = URI.recodePath(v);
      this._parts.path = this._parts.path.replace(replace, v);

      if (mutatedDirectory) {
        this.normalizePath(build);
      } else {
        this.build(!build);
      }

      return this;
    }
  };
  p.suffix = function(v, build) {
    if (this._parts.urn) {
      return v === undefined ? '' : this;
    }

    if (v === undefined || v === true) {
      if (!this._parts.path || this._parts.path === '/') {
        return '';
      }

      var filename = this.filename();
      var pos = filename.lastIndexOf('.');
      var s, res;

      if (pos === -1) {
        return '';
      }

      // suffix may only contain alnum characters (yup, I made this up.)
      s = filename.substring(pos+1);
      res = (/^[a-z0-9%]+$/i).test(s) ? s : '';
      return v ? URI.decodePathSegment(res) : res;
    } else {
      if (v.charAt(0) === '.') {
        v = v.substring(1);
      }

      var suffix = this.suffix();
      var replace;

      if (!suffix) {
        if (!v) {
          return this;
        }

        this._parts.path += '.' + URI.recodePath(v);
      } else if (!v) {
        replace = new RegExp(escapeRegEx('.' + suffix) + '$');
      } else {
        replace = new RegExp(escapeRegEx(suffix) + '$');
      }

      if (replace) {
        v = URI.recodePath(v);
        this._parts.path = this._parts.path.replace(replace, v);
      }

      this.build(!build);
      return this;
    }
  };
  p.segment = function(segment, v, build) {
    var separator = this._parts.urn ? ':' : '/';
    var path = this.path();
    var absolute = path.substring(0, 1) === '/';
    var segments = path.split(separator);

    if (segment !== undefined && typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (segment !== undefined && typeof segment !== 'number') {
      throw new Error('Bad segment "' + segment + '", must be 0-based integer');
    }

    if (absolute) {
      segments.shift();
    }

    if (segment < 0) {
      // allow negative indexes to address from the end
      segment = Math.max(segments.length + segment, 0);
    }

    if (v === undefined) {
      /*jshint laxbreak: true */
      return segment === undefined
        ? segments
        : segments[segment];
      /*jshint laxbreak: false */
    } else if (segment === null || segments[segment] === undefined) {
      if (isArray(v)) {
        segments = [];
        // collapse empty elements within array
        for (var i=0, l=v.length; i < l; i++) {
          if (!v[i].length && (!segments.length || !segments[segments.length -1].length)) {
            continue;
          }

          if (segments.length && !segments[segments.length -1].length) {
            segments.pop();
          }

          segments.push(trimSlashes(v[i]));
        }
      } else if (v || typeof v === 'string') {
        v = trimSlashes(v);
        if (segments[segments.length -1] === '') {
          // empty trailing elements have to be overwritten
          // to prevent results such as /foo//bar
          segments[segments.length -1] = v;
        } else {
          segments.push(v);
        }
      }
    } else {
      if (v) {
        segments[segment] = trimSlashes(v);
      } else {
        segments.splice(segment, 1);
      }
    }

    if (absolute) {
      segments.unshift('');
    }

    return this.path(segments.join(separator), build);
  };
  p.segmentCoded = function(segment, v, build) {
    var segments, i, l;

    if (typeof segment !== 'number') {
      build = v;
      v = segment;
      segment = undefined;
    }

    if (v === undefined) {
      segments = this.segment(segment, v, build);
      if (!isArray(segments)) {
        segments = segments !== undefined ? URI.decode(segments) : undefined;
      } else {
        for (i = 0, l = segments.length; i < l; i++) {
          segments[i] = URI.decode(segments[i]);
        }
      }

      return segments;
    }

    if (!isArray(v)) {
      v = (typeof v === 'string' || v instanceof String) ? URI.encode(v) : v;
    } else {
      for (i = 0, l = v.length; i < l; i++) {
        v[i] = URI.encode(v[i]);
      }
    }

    return this.segment(segment, v, build);
  };

  // mutating query string
  var q = p.query;
  p.query = function(v, build) {
    if (v === true) {
      return URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    } else if (typeof v === 'function') {
      var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
      var result = v.call(this, data);
      this._parts.query = URI.buildQuery(result || data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else if (v !== undefined && typeof v !== 'string') {
      this._parts.query = URI.buildQuery(v, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
      this.build(!build);
      return this;
    } else {
      return q.call(this, v, build);
    }
  };
  p.setQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);

    if (typeof name === 'string' || name instanceof String) {
      data[name] = value !== undefined ? value : null;
    } else if (typeof name === 'object') {
      for (var key in name) {
        if (hasOwn.call(name, key)) {
          data[key] = name[key];
        }
      }
    } else {
      throw new TypeError('URI.addQuery() accepts an object, string as the name parameter');
    }

    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.addQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.addQuery(data, name, value === undefined ? null : value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.removeQuery = function(name, value, build) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    URI.removeQuery(data, name, value);
    this._parts.query = URI.buildQuery(data, this._parts.duplicateQueryParameters, this._parts.escapeQuerySpace);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.hasQuery = function(name, value, withinArray) {
    var data = URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace);
    return URI.hasQuery(data, name, value, withinArray);
  };
  p.setSearch = p.setQuery;
  p.addSearch = p.addQuery;
  p.removeSearch = p.removeQuery;
  p.hasSearch = p.hasQuery;

  // sanitizing URLs
  p.normalize = function() {
    if (this._parts.urn) {
      return this
        .normalizeProtocol(false)
        .normalizePath(false)
        .normalizeQuery(false)
        .normalizeFragment(false)
        .build();
    }

    return this
      .normalizeProtocol(false)
      .normalizeHostname(false)
      .normalizePort(false)
      .normalizePath(false)
      .normalizeQuery(false)
      .normalizeFragment(false)
      .build();
  };
  p.normalizeProtocol = function(build) {
    if (typeof this._parts.protocol === 'string') {
      this._parts.protocol = this._parts.protocol.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizeHostname = function(build) {
    if (this._parts.hostname) {
      if (this.is('IDN') && punycode) {
        this._parts.hostname = punycode.toASCII(this._parts.hostname);
      } else if (this.is('IPv6') && IPv6) {
        this._parts.hostname = IPv6.best(this._parts.hostname);
      }

      this._parts.hostname = this._parts.hostname.toLowerCase();
      this.build(!build);
    }

    return this;
  };
  p.normalizePort = function(build) {
    // remove port of it's the protocol's default
    if (typeof this._parts.protocol === 'string' && this._parts.port === URI.defaultPorts[this._parts.protocol]) {
      this._parts.port = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizePath = function(build) {
    var _path = this._parts.path;
    if (!_path) {
      return this;
    }

    if (this._parts.urn) {
      this._parts.path = URI.recodeUrnPath(this._parts.path);
      this.build(!build);
      return this;
    }

    if (this._parts.path === '/') {
      return this;
    }

    var _was_relative;
    var _leadingParents = '';
    var _parent, _pos;

    // handle relative paths
    if (_path.charAt(0) !== '/') {
      _was_relative = true;
      _path = '/' + _path;
    }

    // handle relative files (as opposed to directories)
    if (_path.slice(-3) === '/..' || _path.slice(-2) === '/.') {
      _path += '/';
    }

    // resolve simples
    _path = _path
      .replace(/(\/(\.\/)+)|(\/\.$)/g, '/')
      .replace(/\/{2,}/g, '/');

    // remember leading parents
    if (_was_relative) {
      _leadingParents = _path.substring(1).match(/^(\.\.\/)+/) || '';
      if (_leadingParents) {
        _leadingParents = _leadingParents[0];
      }
    }

    // resolve parents
    while (true) {
      _parent = _path.indexOf('/..');
      if (_parent === -1) {
        // no more ../ to resolve
        break;
      } else if (_parent === 0) {
        // top level cannot be relative, skip it
        _path = _path.substring(3);
        continue;
      }

      _pos = _path.substring(0, _parent).lastIndexOf('/');
      if (_pos === -1) {
        _pos = _parent;
      }
      _path = _path.substring(0, _pos) + _path.substring(_parent + 3);
    }

    // revert to relative
    if (_was_relative && this.is('relative')) {
      _path = _leadingParents + _path.substring(1);
    }

    _path = URI.recodePath(_path);
    this._parts.path = _path;
    this.build(!build);
    return this;
  };
  p.normalizePathname = p.normalizePath;
  p.normalizeQuery = function(build) {
    if (typeof this._parts.query === 'string') {
      if (!this._parts.query.length) {
        this._parts.query = null;
      } else {
        this.query(URI.parseQuery(this._parts.query, this._parts.escapeQuerySpace));
      }

      this.build(!build);
    }

    return this;
  };
  p.normalizeFragment = function(build) {
    if (!this._parts.fragment) {
      this._parts.fragment = null;
      this.build(!build);
    }

    return this;
  };
  p.normalizeSearch = p.normalizeQuery;
  p.normalizeHash = p.normalizeFragment;

  p.iso8859 = function() {
    // expect unicode input, iso8859 output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = escape;
    URI.decode = decodeURIComponent;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.unicode = function() {
    // expect iso8859 input, unicode output
    var e = URI.encode;
    var d = URI.decode;

    URI.encode = strictEncodeURIComponent;
    URI.decode = unescape;
    try {
      this.normalize();
    } finally {
      URI.encode = e;
      URI.decode = d;
    }
    return this;
  };

  p.readable = function() {
    var uri = this.clone();
    // removing username, password, because they shouldn't be displayed according to RFC 3986
    uri.username('').password('').normalize();
    var t = '';
    if (uri._parts.protocol) {
      t += uri._parts.protocol + '://';
    }

    if (uri._parts.hostname) {
      if (uri.is('punycode') && punycode) {
        t += punycode.toUnicode(uri._parts.hostname);
        if (uri._parts.port) {
          t += ':' + uri._parts.port;
        }
      } else {
        t += uri.host();
      }
    }

    if (uri._parts.hostname && uri._parts.path && uri._parts.path.charAt(0) !== '/') {
      t += '/';
    }

    t += uri.path(true);
    if (uri._parts.query) {
      var q = '';
      for (var i = 0, qp = uri._parts.query.split('&'), l = qp.length; i < l; i++) {
        var kv = (qp[i] || '').split('=');
        q += '&' + URI.decodeQuery(kv[0], this._parts.escapeQuerySpace)
          .replace(/&/g, '%26');

        if (kv[1] !== undefined) {
          q += '=' + URI.decodeQuery(kv[1], this._parts.escapeQuerySpace)
            .replace(/&/g, '%26');
        }
      }
      t += '?' + q.substring(1);
    }

    t += URI.decodeQuery(uri.hash(), true);
    return t;
  };

  // resolving relative and absolute URLs
  p.absoluteTo = function(base) {
    var resolved = this.clone();
    var properties = ['protocol', 'username', 'password', 'hostname', 'port'];
    var basedir, i, p;

    if (this._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    if (!(base instanceof URI)) {
      base = new URI(base);
    }

    if (!resolved._parts.protocol) {
      resolved._parts.protocol = base._parts.protocol;
    }

    if (this._parts.hostname) {
      return resolved;
    }

    for (i = 0; (p = properties[i]); i++) {
      resolved._parts[p] = base._parts[p];
    }

    if (!resolved._parts.path) {
      resolved._parts.path = base._parts.path;
      if (!resolved._parts.query) {
        resolved._parts.query = base._parts.query;
      }
    } else if (resolved._parts.path.substring(-2) === '..') {
      resolved._parts.path += '/';
    }

    if (resolved.path().charAt(0) !== '/') {
      basedir = base.directory();
      basedir = basedir ? basedir : base.path().indexOf('/') === 0 ? '/' : '';
      resolved._parts.path = (basedir ? (basedir + '/') : '') + resolved._parts.path;
      resolved.normalizePath();
    }

    resolved.build();
    return resolved;
  };
  p.relativeTo = function(base) {
    var relative = this.clone().normalize();
    var relativeParts, baseParts, common, relativePath, basePath;

    if (relative._parts.urn) {
      throw new Error('URNs do not have any generally defined hierarchical components');
    }

    base = new URI(base).normalize();
    relativeParts = relative._parts;
    baseParts = base._parts;
    relativePath = relative.path();
    basePath = base.path();

    if (relativePath.charAt(0) !== '/') {
      throw new Error('URI is already relative');
    }

    if (basePath.charAt(0) !== '/') {
      throw new Error('Cannot calculate a URI relative to another relative URI');
    }

    if (relativeParts.protocol === baseParts.protocol) {
      relativeParts.protocol = null;
    }

    if (relativeParts.username !== baseParts.username || relativeParts.password !== baseParts.password) {
      return relative.build();
    }

    if (relativeParts.protocol !== null || relativeParts.username !== null || relativeParts.password !== null) {
      return relative.build();
    }

    if (relativeParts.hostname === baseParts.hostname && relativeParts.port === baseParts.port) {
      relativeParts.hostname = null;
      relativeParts.port = null;
    } else {
      return relative.build();
    }

    if (relativePath === basePath) {
      relativeParts.path = '';
      return relative.build();
    }

    // determine common sub path
    common = URI.commonPath(relativePath, basePath);

    // If the paths have nothing in common, return a relative URL with the absolute path.
    if (!common) {
      return relative.build();
    }

    var parents = baseParts.path
      .substring(common.length)
      .replace(/[^\/]*$/, '')
      .replace(/.*?\//g, '../');

    relativeParts.path = (parents + relativeParts.path.substring(common.length)) || './';

    return relative.build();
  };

  // comparing URIs
  p.equals = function(uri) {
    var one = this.clone();
    var two = new URI(uri);
    var one_map = {};
    var two_map = {};
    var checked = {};
    var one_query, two_query, key;

    one.normalize();
    two.normalize();

    // exact match
    if (one.toString() === two.toString()) {
      return true;
    }

    // extract query string
    one_query = one.query();
    two_query = two.query();
    one.query('');
    two.query('');

    // definitely not equal if not even non-query parts match
    if (one.toString() !== two.toString()) {
      return false;
    }

    // query parameters have the same length, even if they're permuted
    if (one_query.length !== two_query.length) {
      return false;
    }

    one_map = URI.parseQuery(one_query, this._parts.escapeQuerySpace);
    two_map = URI.parseQuery(two_query, this._parts.escapeQuerySpace);

    for (key in one_map) {
      if (hasOwn.call(one_map, key)) {
        if (!isArray(one_map[key])) {
          if (one_map[key] !== two_map[key]) {
            return false;
          }
        } else if (!arraysEqual(one_map[key], two_map[key])) {
          return false;
        }

        checked[key] = true;
      }
    }

    for (key in two_map) {
      if (hasOwn.call(two_map, key)) {
        if (!checked[key]) {
          // two contains a parameter not present in one
          return false;
        }
      }
    }

    return true;
  };

  // state
  p.duplicateQueryParameters = function(v) {
    this._parts.duplicateQueryParameters = !!v;
    return this;
  };

  p.escapeQuerySpace = function(v) {
    this._parts.escapeQuerySpace = !!v;
    return this;
  };

  return URI;
}));

/*
 * Extending URI.js for fragment abuse
 */

// --------------------------------------------------------------------------------
// EXAMPLE: storing application/x-www-form-urlencoded data in the fragment
// possibly helpful for Google's hashbangs
// see http://code.google.com/web/ajaxcrawling/
// --------------------------------------------------------------------------------

// Note: make sure this is the last file loaded!

// USAGE:
// var uri = URI("http://example.org/#?foo=bar");
// uri.fragment(true) === {foo: "bar"};
// uri.fragment({bar: "foo"});
// uri.toString() === "http://example.org/#?bar=foo";
// uri.addFragment("name", "value");
// uri.toString() === "http://example.org/#?bar=foo&name=value";
// uri.removeFragment("name");
// uri.toString() === "http://example.org/#?bar=foo";

(function (root, factory) {
  'use strict';
  // https://github.com/umdjs/umd/blob/master/returnExports.js
  if (typeof exports === 'object') {
    // Node
    module.exports = factory(require('./URI'));
  } else if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(['./URI'], factory);
  } else {
    // Browser globals (root is window)
    factory(root.URI);
  }
}(this, function (URI) {
  'use strict';

  var p = URI.prototype;
  // old fragment handler we need to wrap
  var f = p.fragment;

  // make fragmentPrefix configurable
  URI.fragmentPrefix = '?';
  var _parts = URI._parts;
  URI._parts = function() {
    var parts = _parts();
    parts.fragmentPrefix = URI.fragmentPrefix;
    return parts;
  };
  p.fragmentPrefix = function(v) {
    this._parts.fragmentPrefix = v;
    return this;
  };

  // add fragment(true) and fragment({key: value}) signatures
  p.fragment = function(v, build) {
    var prefix = this._parts.fragmentPrefix;
    var fragment = this._parts.fragment || '';
  
    if (v === true) {
      if (fragment.substring(0, prefix.length) !== prefix) {
        return {};
      }
    
      return URI.parseQuery(fragment.substring(prefix.length));
    } else if (v !== undefined && typeof v !== 'string') {
      this._parts.fragment = prefix + URI.buildQuery(v);
      this.build(!build);
      return this;
    } else {
      return f.call(this, v, build);
    }
  };
  p.addFragment = function(name, value, build) {
    var prefix = this._parts.fragmentPrefix;
    var data = URI.parseQuery((this._parts.fragment || '').substring(prefix.length));
    URI.addQuery(data, name, value);
    this._parts.fragment = prefix + URI.buildQuery(data);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.removeFragment = function(name, value, build) {
    var prefix = this._parts.fragmentPrefix;
    var data = URI.parseQuery((this._parts.fragment || '').substring(prefix.length));
    URI.removeQuery(data, name, value);
    this._parts.fragment = prefix + URI.buildQuery(data);
    if (typeof name !== 'string') {
      build = value;
    }

    this.build(!build);
    return this;
  };
  p.addHash = p.addFragment;
  p.removeHash = p.removeFragment;

  // extending existing object rather than defining something new
  return URI;
}));
/*
International Telephone Input v5.8.4
https://github.com/Bluefieldscom/intl-tel-input.git
*/
// wrap in UMD - see https://github.com/umdjs/umd/blob/master/jqueryPlugin.js
(function (factory) {
	if (typeof define === "function" && define.amd) {
		define(["jquery"], function ($) {
			factory($, window, document);
		});
	} else {
		factory(jQuery, window, document);
	}
})(function ($, window, document, undefined) {
	"use strict";
	// these vars persist through all instances of the plugin
	var pluginName = "intlTelInput", id = 1, // give each instance it's own id for namespaced event handling
	defaults = {
		// typing digits after a valid number will be added to the extension part of the number
		allowExtensions: false,
		// automatically format the number according to the selected country
		autoFormat: true,
		// add or remove input placeholder with an example number for the selected country
		autoPlaceholder: true,
		// if there is just a dial code in the input: remove it on blur, and re-add it on focus
		autoHideDialCode: true,
		// default country
		defaultCountry: "",
		// token for ipinfo - required for https or over 1000 daily page views support
		ipinfoToken: "",
		// don't insert international dial codes
		nationalMode: true,
		// number type to use for placeholders
		numberType: "MOBILE",
		// display only these countries
		onlyCountries: [],
		// the countries at the top of the list. defaults to united states and united kingdom
		preferredCountries: ["us", "gb"],
		// specify the path to the libphonenumber script to enable validation/formatting
		utilsScript: ""
	}, keys = {
		UP: 38,
		DOWN: 40,
		ENTER: 13,
		ESC: 27,
		PLUS: 43,
		A: 65,
		Z: 90,
		ZERO: 48,
		NINE: 57,
		SPACE: 32,
		BSPACE: 8,
		DEL: 46,
		CTRL: 17,
		CMD1: 91,
		// Chrome
		CMD2: 224
	}, windowLoaded = false;
	// keep track of if the window.load event has fired as impossible to check after the fact
	$(window).load(function () {
		windowLoaded = true;
	});
	function Plugin(element, options) {
		this.element = element;
		this.options = $.extend({}, defaults, options);
		this._defaults = defaults;
		// event namespace
		this.ns = "." + pluginName + id++;
		// Chrome, FF, Safari, IE9+
		this.isGoodBrowser = Boolean(element.setSelectionRange);
		this.hadInitialPlaceholder = Boolean($(element).attr("placeholder"));
		this._name = pluginName;
	}
	Plugin.prototype = {
		_init: function () {
			// if in nationalMode, disable options relating to dial codes
			if (this.options.nationalMode) {
				this.options.autoHideDialCode = false;
			}
			// IE Mobile doesn't support the keypress event (see issue 68) which makes autoFormat impossible
			if (navigator.userAgent.match(/IEMobile/i)) {
				this.options.autoFormat = false;
			}
			// we cannot just test screen size as some smartphones/website meta tags will report desktop resolutions
			// Note: for some reason jasmine fucks up if you put this in the main Plugin function with the rest of these declarations
			// Note: to target Android Mobiles (and not Tablets), we must find "Android" and "Mobile"
			this.isMobile = /Android.+Mobile|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
			// we return these deferred objects from the _init() call so they can be watched, and then we resolve them when each specific request returns
			// Note: again, jasmine had a spazz when I put these in the Plugin function
			this.autoCountryDeferred = new $.Deferred();
			this.utilsScriptDeferred = new $.Deferred();
			// process all the data: onlyCountries, preferredCountries etc
			this._processCountryData();
			// generate the markup
			this._generateMarkup();
			// set the initial state of the input value and the selected flag
			this._setInitialState();
			// start all of the event listeners: autoHideDialCode, input keydown, selectedFlag click
			this._initListeners();
			// utils script, and auto country
			this._initRequests();
			// return the deferreds
			return [this.autoCountryDeferred, this.utilsScriptDeferred];
		},
		/********************
		*  PRIVATE METHODS
		********************/
		// prepare all of the country data, including onlyCountries and preferredCountries options
		_processCountryData: function () {
			// set the instances country data objects
			this._setInstanceCountryData();
			// set the preferredCountries property
			this._setPreferredCountries();
		},
		// add a country code to this.countryCodes
		_addCountryCode: function (iso2, dialCode, priority) {
			if (!(dialCode in this.countryCodes)) {
				this.countryCodes[dialCode] = [];
			}
			var index = priority || 0;
			this.countryCodes[dialCode][index] = iso2;
		},
		// process onlyCountries array if present, and generate the countryCodes map
		_setInstanceCountryData: function () {
			var i;
			// process onlyCountries option
			if (this.options.onlyCountries.length) {
				// standardise case
				for (i = 0; i < this.options.onlyCountries.length; i++) {
					this.options.onlyCountries[i] = this.options.onlyCountries[i].toLowerCase();
				}
				// build instance country array
				this.countries = [];
				for (i = 0; i < allCountries.length; i++) {
					if ($.inArray(allCountries[i].iso2, this.options.onlyCountries) != -1) {
						this.countries.push(allCountries[i]);
					}
				}
			} else {
				this.countries = allCountries;
			}
			// generate countryCodes map
			this.countryCodes = {};
			for (i = 0; i < this.countries.length; i++) {
				var c = this.countries[i];
				this._addCountryCode(c.iso2, c.dialCode, c.priority);
				// area codes
				if (c.areaCodes) {
					for (var j = 0; j < c.areaCodes.length; j++) {
						// full dial code is country code + dial code
						this._addCountryCode(c.iso2, c.dialCode + c.areaCodes[j]);
					}
				}
			}
		},
		// process preferred countries - iterate through the preferences,
		// fetching the country data for each one
		_setPreferredCountries: function () {
			this.preferredCountries = [];
			for (var i = 0; i < this.options.preferredCountries.length; i++) {
				var countryCode = this.options.preferredCountries[i].toLowerCase(), countryData = this._getCountryData(countryCode, false, true);
				if (countryData) {
					this.preferredCountries.push(countryData);
				}
			}
		},
		// generate all of the markup for the plugin: the selected flag overlay, and the dropdown
		_generateMarkup: function () {
			// telephone input
			this.telInput = $(this.element);
			// prevent autocomplete as there's no safe, cross-browser event we can react to, so it can easily put the plugin in an inconsistent state e.g. the wrong flag selected for the autocompleted number, which on submit could mean the wrong number is saved (esp in nationalMode)
			this.telInput.attr("autocomplete", "off");
			// containers (mostly for positioning)
			this.telInput.wrap($("<div>", {
				"class": "intl-tel-input"
			}));
			var flagsContainer = $("<div>", {
				"class": "flag-dropdown"
			}).insertAfter(this.telInput);
			// currently selected flag (displayed to left of input)
			var selectedFlag = $("<div>", {
				"class": "selected-flag"
			}).appendTo(flagsContainer);
			this.selectedFlagInner = $("<div>", {
				"class": "iti-flag"
			}).appendTo(selectedFlag);
			// CSS triangle
			$("<div>", {
				"class": "arrow"
			}).appendTo(selectedFlag);
			// country list
			// mobile is just a native select element
			// desktop is a proper list containing: preferred countries, then divider, then all countries
			if (this.isMobile) {
				this.countryList = $("<select>").appendTo(flagsContainer);
			} else {
				this.countryList = $("<ul>", {
					"class": "country-list v-hide"
				}).appendTo(flagsContainer);
				if (this.preferredCountries.length && !this.isMobile) {
					this._appendListItems(this.preferredCountries, "preferred");
					$("<li>", {
						"class": "divider"
					}).appendTo(this.countryList);
				}
			}
			this._appendListItems(this.countries, "");
			if (!this.isMobile) {
				// now we can grab the dropdown height, and hide it properly
				this.dropdownHeight = this.countryList.outerHeight();
				this.countryList.removeClass("v-hide").addClass("hide");
				// this is useful in lots of places
				this.countryListItems = this.countryList.children(".country");
			}
		},
		// add a country <li> to the countryList <ul> container
		// UPDATE: if isMobile, add an <option> to the countryList <select> container
		_appendListItems: function (countries, className) {
			// we create so many DOM elements, it is faster to build a temp string
			// and then add everything to the DOM in one go at the end
			var tmp = "";
			// for each country
			for (var i = 0; i < countries.length; i++) {
				var c = countries[i];
				if (this.isMobile) {
					tmp += "<option data-dial-code='" + c.dialCode + "' value='" + c.iso2 + "'>";
					tmp += c.name + " +" + c.dialCode;
					tmp += "</option>";
				} else {
					// open the list item
					tmp += "<li class='country " + className + "' data-dial-code='" + c.dialCode + "' data-country-code='" + c.iso2 + "'>";
					// add the flag
					tmp += "<div class='flag'><div class='iti-flag " + c.iso2 + "'></div></div>";
					// and the country name and dial code
					tmp += "<span class='country-name'>" + c.name + "</span>";
					tmp += "<span class='dial-code'>+" + c.dialCode + "</span>";
					// close the list item
					tmp += "</li>";
				}
			}
			this.countryList.append(tmp);
		},
		// set the initial state of the input value and the selected flag
		_setInitialState: function () {
			var val = this.telInput.val();
			// if there is a number, and it's valid, we can go ahead and set the flag, else fall back to default
			if (this._getDialCode(val)) {
				this._updateFlagFromNumber(val);
			} else if (this.options.defaultCountry != "auto") {
				// check the defaultCountry option, else fall back to the first in the list
				if (this.options.defaultCountry) {
					this.options.defaultCountry = this._getCountryData(this.options.defaultCountry.toLowerCase(), false, false);
				} else {
					this.options.defaultCountry = this.preferredCountries.length ? this.preferredCountries[0] : this.countries[0];
				}
				this._selectFlag(this.options.defaultCountry.iso2);
				// if empty, insert the default dial code (this function will check !nationalMode and !autoHideDialCode)
				if (!val) {
					this._updateDialCode(this.options.defaultCountry.dialCode, false);
				}
			}
			// format
			if (val) {
				// this wont be run after _updateDialCode as that's only called if no val
				this._updateVal(val);
			}
		},
		// initialise the main event listeners: input keyup, and click selected flag
		_initListeners: function () {
			var that = this;
			this._initKeyListeners();
			// autoFormat prevents the change event from firing, so we need to check for changes between focus and blur in order to manually trigger it
			if (this.options.autoHideDialCode || this.options.autoFormat) {
				this._initFocusListeners();
			}
			if (this.isMobile) {
				this.countryList.on("change" + this.ns, function (e) {
					that._selectListItem($(this).find("option:selected"));
				});
			} else {
				// hack for input nested inside label: clicking the selected-flag to open the dropdown would then automatically trigger a 2nd click on the input which would close it again
				var label = this.telInput.closest("label");
				if (label.length) {
					label.on("click" + this.ns, function (e) {
						// if the dropdown is closed, then focus the input, else ignore the click
						if (that.countryList.hasClass("hide")) {
							that.telInput.focus();
						} else {
							e.preventDefault();
						}
					});
				}
				// toggle country dropdown on click
				var selectedFlag = this.selectedFlagInner.parent();
				selectedFlag.on("click" + this.ns, function (e) {
					// only intercept this event if we're opening the dropdown
					// else let it bubble up to the top ("click-off-to-close" listener)
					// we cannot just stopPropagation as it may be needed to close another instance
					if (that.countryList.hasClass("hide") && !that.telInput.prop("disabled") && !that.telInput.prop("readonly")) {
						that._showDropdown();
					}
				});
			}
		},
		_initRequests: function () {
			var that = this;
			// if the user has specified the path to the utils script, fetch it on window.load
			if (this.options.utilsScript) {
				// if the plugin is being initialised after the window.load event has already been fired
				if (windowLoaded) {
					this.loadUtils();
				} else {
					// wait until the load event so we don't block any other requests e.g. the flags image
					$(window).load(function () {
						that.loadUtils();
					});
				}
			} else {
				this.utilsScriptDeferred.resolve();
			}
			if (this.options.defaultCountry == "auto") {
				this._loadAutoCountry();
			} else {
				this.autoCountryDeferred.resolve();
			}
		},
		_loadAutoCountry: function () {
			var that = this;
			// check for cookie
			var cookieAutoCountry = $.cookie ? $.cookie("itiAutoCountry") : "";
			if (cookieAutoCountry) {
				$.fn[pluginName].autoCountry = cookieAutoCountry;
			}
			// 3 options:
			// 1) already loaded (we're done)
			// 2) not already started loading (start)
			// 3) already started loading (do nothing - just wait for loading callback to fire)
			if ($.fn[pluginName].autoCountry) {
				this.autoCountryLoaded();
			} else if (!$.fn[pluginName].startedLoadingAutoCountry) {
				// don't do this twice!
				$.fn[pluginName].startedLoadingAutoCountry = true;
				var ipinfoURL = "//ipinfo.io";
				if (this.options.ipinfoToken) {
					ipinfoURL += "?token=" + this.options.ipinfoToken;
				}
				// dont bother with the success function arg - instead use always() as should still set a defaultCountry even if the lookup fails
				$.get(ipinfoURL, function () { }, "jsonp").always(function (resp) {
					$.fn[pluginName].autoCountry = resp && resp.country ? resp.country.toLowerCase() : "";
					if ($.cookie) {
						$.cookie("itiAutoCountry", $.fn[pluginName].autoCountry, {
							path: "/"
						});
					}
					// tell all instances the auto country is ready
					// TODO: this should just be the current instances
					$(".intl-tel-input input").intlTelInput("autoCountryLoaded");
				});
			}
		},
		_initKeyListeners: function () {
			var that = this;
			if (this.options.autoFormat) {
				// format number and update flag on keypress
				// use keypress event as we want to ignore all input except for a select few keys,
				// but we dont want to ignore the navigation keys like the arrows etc.
				// NOTE: no point in refactoring this to only bind these listeners on focus/blur because then you would need to have those 2 listeners running the whole time anyway...
				this.telInput.on("keypress" + this.ns, function (e) {
					// 32 is space, and after that it's all chars (not meta/nav keys)
					// this fix is needed for Firefox, which triggers keypress event for some meta/nav keys
					// Update: also ignore if this is a metaKey e.g. FF and Safari trigger keypress on the v of Ctrl+v
					// Update: also ignore if ctrlKey (FF on Windows/Ubuntu)
					// Update: also check that we have utils before we do any autoFormat stuff
					if (e.which >= keys.SPACE && !e.ctrlKey && !e.metaKey && window.intlTelInputUtils && !that.telInput.prop("readonly")) {
						e.preventDefault();
						// allowed keys are just numeric keys and plus
						// we must allow plus for the case where the user does select-all and then hits plus to start typing a new number. we could refine this logic to first check that the selection contains a plus, but that wont work in old browsers, and I think it's overkill anyway
						var isAllowedKey = e.which >= keys.ZERO && e.which <= keys.NINE || e.which == keys.PLUS, input = that.telInput[0], noSelection = that.isGoodBrowser && input.selectionStart == input.selectionEnd, max = that.telInput.attr("maxlength"), val = that.telInput.val(), // assumes that if max exists, it is >0
						isBelowMax = max ? val.length < max : true;
						// first: ensure we dont go over maxlength. we must do this here to prevent adding digits in the middle of the number
						// still reformat even if not an allowed key as they could by typing a formatting char, but ignore if there's a selection as doesn't make sense to replace selection with illegal char and then immediately remove it
						if (isBelowMax && (isAllowedKey || noSelection)) {
							var newChar = isAllowedKey ? String.fromCharCode(e.which) : null;
							that._handleInputKey(newChar, true, isAllowedKey);
							// if something has changed, trigger the input event (which was otherwised squashed by the preventDefault)
							if (val != that.telInput.val()) {
								that.telInput.trigger("input");
							}
						}
						if (!isAllowedKey) {
							that._handleInvalidKey();
						}
					}
				});
			}
			// handle cut/paste event (now supported in all major browsers)
			this.telInput.on("cut" + this.ns + " paste" + this.ns, function () {
				// hack because "paste" event is fired before input is updated
				setTimeout(function () {
					if (that.options.autoFormat && window.intlTelInputUtils) {
						var cursorAtEnd = that.isGoodBrowser && that.telInput[0].selectionStart == that.telInput.val().length;
						that._handleInputKey(null, cursorAtEnd);
						that._ensurePlus();
					} else {
						// if no autoFormat, just update flag
						that._updateFlagFromNumber(that.telInput.val());
					}
				});
			});
			// handle keyup event
			// if autoFormat enabled: we use keyup to catch delete events (after the fact)
			// if no autoFormat, this is used to update the flag
			this.telInput.on("keyup" + this.ns, function (e) {
				// the "enter" key event from selecting a dropdown item is triggered here on the input, because the document.keydown handler that initially handles that event triggers a focus on the input, and so the keyup for that same key event gets triggered here. weird, but just make sure we dont bother doing any re-formatting in this case (we've already done preventDefault in the keydown handler, so it wont actually submit the form or anything).
				// ALSO: ignore keyup if readonly
				if (e.which == keys.ENTER || that.telInput.prop("readonly")) { } else if (that.options.autoFormat && window.intlTelInputUtils) {
					// cursorAtEnd defaults to false for bad browsers else they would never get a reformat on delete
					var cursorAtEnd = that.isGoodBrowser && that.telInput[0].selectionStart == that.telInput.val().length;
					if (!that.telInput.val()) {
						// if they just cleared the input, update the flag to the default
						that._updateFlagFromNumber("");
					} else if (e.which == keys.DEL && !cursorAtEnd || e.which == keys.BSPACE) {
						// if delete in the middle: reformat with no suffix (no need to reformat if delete at end)
						// if backspace: reformat with no suffix (need to reformat if at end to remove any lingering suffix - this is a feature)
						// important to remember never to add suffix on any delete key as can fuck up in ie8 so you can never delete a formatting char at the end
						that._handleInputKey();
					}
					that._ensurePlus();
				} else {
					// if no autoFormat, just update flag
					that._updateFlagFromNumber(that.telInput.val());
				}
			});
		},
		// prevent deleting the plus (if not in nationalMode)
		_ensurePlus: function () {
			if (!this.options.nationalMode) {
				var val = this.telInput.val(), input = this.telInput[0];
				if (val.charAt(0) != "+") {
					// newCursorPos is current pos + 1 to account for the plus we are about to add
					var newCursorPos = this.isGoodBrowser ? input.selectionStart + 1 : 0;
					this.telInput.val("+" + val);
					if (this.isGoodBrowser) {
						input.setSelectionRange(newCursorPos, newCursorPos);
					}
				}
			}
		},
		// alert the user to an invalid key event
		_handleInvalidKey: function () {
			var that = this;
			this.telInput.trigger("invalidkey").addClass("iti-invalid-key");
			setTimeout(function () {
				that.telInput.removeClass("iti-invalid-key");
			}, 100);
		},
		// when autoFormat is enabled: handle various key events on the input:
		// 1) adding a new number character, which will replace any selection, reformat, and preserve the cursor position
		// 2) reformatting on backspace/delete
		// 3) cut/paste event
		_handleInputKey: function (newNumericChar, addSuffix, isAllowedKey) {
			var val = this.telInput.val(), cleanBefore = this._getClean(val), originalLeftChars, // raw DOM element
			input = this.telInput[0], digitsOnRight = 0;
			if (this.isGoodBrowser) {
				// cursor strategy: maintain the number of digits on the right. we use the right instead of the left so that A) we dont have to account for the new digit (or multiple digits if paste event), and B) we're always on the right side of formatting suffixes
				digitsOnRight = this._getDigitsOnRight(val, input.selectionEnd);
				// if handling a new number character: insert it in the right place
				if (newNumericChar) {
					// replace any selection they may have made with the new char
					val = val.substr(0, input.selectionStart) + newNumericChar + val.substring(input.selectionEnd, val.length);
				} else {
					// here we're not handling a new char, we're just doing a re-format (e.g. on delete/backspace/paste, after the fact), but we still need to maintain the cursor position. so make note of the char on the left, and then after the re-format, we'll count in the same number of digits from the right, and then keep going through any formatting chars until we hit the same left char that we had before.
					// UPDATE: now have to store 2 chars as extensions formatting contains 2 spaces so you need to be able to distinguish
					originalLeftChars = val.substr(input.selectionStart - 2, 2);
				}
			} else if (newNumericChar) {
				val += newNumericChar;
			}
			// update the number and flag
			this.setNumber(val, null, addSuffix, true, isAllowedKey);
			// update the cursor position
			if (this.isGoodBrowser) {
				var newCursor;
				val = this.telInput.val();
				// if it was at the end, keep it there
				if (!digitsOnRight) {
					newCursor = val.length;
				} else {
					// else count in the same number of digits from the right
					newCursor = this._getCursorFromDigitsOnRight(val, digitsOnRight);
					// but if delete/paste etc, keep going left until hit the same left char as before
					if (!newNumericChar) {
						newCursor = this._getCursorFromLeftChar(val, newCursor, originalLeftChars);
					}
				}
				// set the new cursor
				input.setSelectionRange(newCursor, newCursor);
			}
		},
		// we start from the position in guessCursor, and work our way left until we hit the originalLeftChars or a number to make sure that after reformatting the cursor has the same char on the left in the case of a delete etc
		_getCursorFromLeftChar: function (val, guessCursor, originalLeftChars) {
			for (var i = guessCursor; i > 0; i--) {
				var leftChar = val.charAt(i - 1);
				if ($.isNumeric(leftChar) || val.substr(i - 2, 2) == originalLeftChars) {
					return i;
				}
			}
			return 0;
		},
		// after a reformat we need to make sure there are still the same number of digits to the right of the cursor
		_getCursorFromDigitsOnRight: function (val, digitsOnRight) {
			for (var i = val.length - 1; i >= 0; i--) {
				if ($.isNumeric(val.charAt(i))) {
					if (--digitsOnRight === 0) {
						return i;
					}
				}
			}
			return 0;
		},
		// get the number of numeric digits to the right of the cursor so we can reposition the cursor correctly after the reformat has happened
		_getDigitsOnRight: function (val, selectionEnd) {
			var digitsOnRight = 0;
			for (var i = selectionEnd; i < val.length; i++) {
				if ($.isNumeric(val.charAt(i))) {
					digitsOnRight++;
				}
			}
			return digitsOnRight;
		},
		// listen for focus and blur
		_initFocusListeners: function () {
			var that = this;
			if (this.options.autoHideDialCode) {
				// mousedown decides where the cursor goes, so if we're focusing we must preventDefault as we'll be inserting the dial code, and we want the cursor to be at the end no matter where they click
				this.telInput.on("mousedown" + this.ns, function (e) {
					if (!that.telInput.is(":focus") && !that.telInput.val()) {
						e.preventDefault();
						// but this also cancels the focus, so we must trigger that manually
						that.telInput.focus();
					}
				});
			}
			this.telInput.on("focus" + this.ns, function (e) {
				var value = that.telInput.val();
				// save this to compare on blur
				that.telInput.data("focusVal", value);
				// on focus: if empty, insert the dial code for the currently selected flag
				if (that.options.autoHideDialCode && !value && !that.telInput.prop("readonly") && that.selectedCountryData.dialCode) {
					that._updateVal("+" + that.selectedCountryData.dialCode, null, true);
					// after auto-inserting a dial code, if the first key they hit is '+' then assume they are entering a new number, so remove the dial code. use keypress instead of keydown because keydown gets triggered for the shift key (required to hit the + key), and instead of keyup because that shows the new '+' before removing the old one
					that.telInput.one("keypress.plus" + that.ns, function (e) {
						if (e.which == keys.PLUS) {
							// if autoFormat is enabled, this key event will have already have been handled by another keypress listener (hence we need to add the "+"). if disabled, it will be handled after this by a keyup listener (hence no need to add the "+").
							var newVal = that.options.autoFormat && window.intlTelInputUtils ? "+" : "";
							that.telInput.val(newVal);
						}
					});
					// after tabbing in, make sure the cursor is at the end we must use setTimeout to get outside of the focus handler as it seems the selection happens after that
					setTimeout(function () {
						var input = that.telInput[0];
						var len = that.telInput.val().length;
						if (that.isGoodBrowser) {
							input.setSelectionRange(len, len);
						} else if (input.createTextRange) {	// ie8 custom fix for POW-1894
							var range = input.createTextRange();
							range.collapse(true);
							range.moveEnd('character', len);
							range.moveStart('character', len);
							range.select();
						}
					});
				}
			});
			this.telInput.on("focusout" + this.ns, function () {
				if (that.options.autoHideDialCode) {
					// on blur: if just a dial code then remove it
					var value = that.telInput.val(), startsPlus = value.charAt(0) == "+";
					if (startsPlus) {
						var numeric = that._getNumeric(value);
						// if just a plus, or if just a dial code
						if (!numeric || that.selectedCountryData.dialCode == numeric) {
							that.telInput.val("");
						}
					}
					// remove the keypress listener we added on focus
					that.telInput.off("keypress.plus" + that.ns);
				}
				// if autoFormat, we must manually trigger change event if value has changed
				if (that.options.autoFormat && window.intlTelInputUtils && that.telInput.val() != that.telInput.data("focusVal")) {
					that.telInput.trigger("change");
				}
			});
		},
		// extract the numeric digits from the given string
		_getNumeric: function (s) {
			return s.replace(/\D/g, "");
		},
		_getClean: function (s) {
			var prefix = s.charAt(0) == "+" ? "+" : "";
			return prefix + this._getNumeric(s);
		},
		// show the dropdown
		_showDropdown: function () {
			this._setDropdownPosition();
			// update highlighting and scroll to active list item
			var activeListItem = this.countryList.children(".active");
			if (activeListItem.length) {
				this._highlightListItem(activeListItem);
			}
			// show it
			this.countryList.removeClass("hide");
			if (activeListItem.length) {
				this._scrollTo(activeListItem);
			}
			// bind all the dropdown-related listeners: mouseover, click, click-off, keydown
			this._bindDropdownListeners();
			// update the arrow
			this.selectedFlagInner.children(".arrow").addClass("up");
		},
		// decide where to position dropdown (depends on position within viewport, and scroll)
		_setDropdownPosition: function () {
			var inputTop = this.telInput.offset().top, windowTop = $(window).scrollTop(), // dropdownFitsBelow = (dropdownBottom < windowBottom)
			dropdownFitsBelow = inputTop + this.telInput.outerHeight() + this.dropdownHeight < windowTop + $(window).height(), dropdownFitsAbove = inputTop - this.dropdownHeight > windowTop;
			// dropdownHeight - 1 for border
			var cssTop = !dropdownFitsBelow && dropdownFitsAbove ? "-" + (this.dropdownHeight - 1) + "px" : "";
			this.countryList.css("top", cssTop);
		},
		// we only bind dropdown listeners when the dropdown is open
		_bindDropdownListeners: function () {
			var that = this;
			// when mouse over a list item, just highlight that one
			// we add the class "highlight", so if they hit "enter" we know which one to select
			this.countryList.on("mouseover" + this.ns, ".country", function (e) {
				that._highlightListItem($(this));
			});
			// listen for country selection
			this.countryList.on("click" + this.ns, ".country", function (e) {
				that._selectListItem($(this));
			});
			// click off to close
			// (except when this initial opening click is bubbling up)
			// we cannot just stopPropagation as it may be needed to close another instance
			var isOpening = true;
			$("html").on("click" + this.ns, function (e) {
				if (!isOpening) {
					that._closeDropdown();
				}
				isOpening = false;
			});
			// listen for up/down scrolling, enter to select, or letters to jump to country name.
			// use keydown as keypress doesn't fire for non-char keys and we want to catch if they
			// just hit down and hold it to scroll down (no keyup event).
			// listen on the document because that's where key events are triggered if no input has focus
			var query = "", queryTimer = null;
			$(document).on("keydown" + this.ns, function (e) {
				// prevent down key from scrolling the whole page,
				// and enter key from submitting a form etc
				e.preventDefault();
				if (e.which == keys.UP || e.which == keys.DOWN) {
					// up and down to navigate
					that._handleUpDownKey(e.which);
				} else if (e.which == keys.ENTER) {
					// enter to select
					that._handleEnterKey();
				} else if (e.which == keys.ESC) {
					// esc to close
					that._closeDropdown();
				} else if (e.which >= keys.A && e.which <= keys.Z || e.which == keys.SPACE) {
					// upper case letters (note: keyup/keydown only return upper case letters)
					// jump to countries that start with the query string
					if (queryTimer) {
						clearTimeout(queryTimer);
					}
					query += String.fromCharCode(e.which);
					that._searchForCountry(query);
					// if the timer hits 1 second, reset the query
					queryTimer = setTimeout(function () {
						query = "";
					}, 1e3);
				}
			});
		},
		// highlight the next/prev item in the list (and ensure it is visible)
		_handleUpDownKey: function (key) {
			var current = this.countryList.children(".highlight").first();
			var next = key == keys.UP ? current.prev() : current.next();
			if (next.length) {
				// skip the divider
				if (next.hasClass("divider")) {
					next = key == keys.UP ? next.prev() : next.next();
				}
				this._highlightListItem(next);
				this._scrollTo(next);
			}
		},
		// select the currently highlighted item
		_handleEnterKey: function () {
			var currentCountry = this.countryList.children(".highlight").first();
			if (currentCountry.length) {
				this._selectListItem(currentCountry);
			}
		},
		// find the first list item whose name starts with the query string
		_searchForCountry: function (query) {
			for (var i = 0; i < this.countries.length; i++) {
				if (this._startsWith(this.countries[i].name, query)) {
					var listItem = this.countryList.children("[data-country-code=" + this.countries[i].iso2 + "]").not(".preferred");
					// update highlighting and scroll
					this._highlightListItem(listItem);
					this._scrollTo(listItem, true);
					break;
				}
			}
		},
		// check if (uppercase) string a starts with string b
		_startsWith: function (a, b) {
			return a.substr(0, b.length).toUpperCase() == b;
		},
		// update the input's value to the given val
		// if autoFormat=true, format it first according to the country-specific formatting rules
		// Note: preventConversion will be false (i.e. we allow conversion) on init and when dev calls public method setNumber
		_updateVal: function (val, format, addSuffix, preventConversion, isAllowedKey) {
			var formatted;
			if (this.options.autoFormat && window.intlTelInputUtils && this.selectedCountryData) {
				if (typeof format == "number" && intlTelInputUtils.isValidNumber(val, this.selectedCountryData.iso2)) {
					// if user specified a format, and it's a valid number, then format it accordingly
					formatted = intlTelInputUtils.formatNumberByType(val, this.selectedCountryData.iso2, format);
				} else if (!preventConversion && this.options.nationalMode && val.charAt(0) == "+" && intlTelInputUtils.isValidNumber(val, this.selectedCountryData.iso2)) {
					// if nationalMode and we have a valid intl number, convert it to ntl
					formatted = intlTelInputUtils.formatNumberByType(val, this.selectedCountryData.iso2, intlTelInputUtils.numberFormat.NATIONAL);
				} else {
					// else do the regular AsYouType formatting
					formatted = intlTelInputUtils.formatNumber(val, this.selectedCountryData.iso2, addSuffix, this.options.allowExtensions, isAllowedKey);
				}
				// ensure we dont go over maxlength. we must do this here to truncate any formatting suffix, and also handle paste events
				var max = this.telInput.attr("maxlength");
				if (max && formatted.length > max) {
					formatted = formatted.substr(0, max);
				}
			} else {
				// no autoFormat, so just insert the original value
				formatted = val;
			}
			this.telInput.val(formatted);
		},
		// check if need to select a new flag based on the given number
		_updateFlagFromNumber: function (number) {
			// if we're in nationalMode and we're on US/Canada, make sure the number starts with a +1 so _getDialCode will be able to extract the area code
			// update: if we dont yet have selectedCountryData, but we're here (trying to update the flag from the number), that means we're initialising the plugin with a number that already has a dial code, so fine to ignore this bit
			if (number && this.options.nationalMode && this.selectedCountryData && this.selectedCountryData.dialCode == "1" && number.charAt(0) != "+") {
				if (number.charAt(0) != "1") {
					number = "1" + number;
				}
				number = "+" + number;
			}
			// try and extract valid dial code from input
			var dialCode = this._getDialCode(number), countryCode = null;
			if (dialCode) {
				// check if one of the matching countries is already selected
				var countryCodes = this.countryCodes[this._getNumeric(dialCode)], alreadySelected = this.selectedCountryData && $.inArray(this.selectedCountryData.iso2, countryCodes) != -1;
				// if a matching country is not already selected (or this is an unknown NANP area code): choose the first in the list
				if (!alreadySelected || this._isUnknownNanp(number, dialCode)) {
					// if using onlyCountries option, countryCodes[0] may be empty, so we must find the first non-empty index
					for (var j = 0; j < countryCodes.length; j++) {
						if (countryCodes[j]) {
							countryCode = countryCodes[j];
							break;
						}
					}
				}
			} else if (number.charAt(0) == "+" && this._getNumeric(number).length) {
				// invalid dial code, so empty
				// Note: use getNumeric here because the number has not been formatted yet, so could contain bad shit
				countryCode = "";
			} else if (!number || number == "+") {
				// empty, or just a plus, so default
				countryCode = this.options.defaultCountry.iso2;
			}
			if (countryCode !== null) {
				this._selectFlag(countryCode);
			}
		},
		// check if the given number contains an unknown area code from the North American Numbering Plan i.e. the only dialCode that could be extracted was +1 but the actual number's length is >=4
		_isUnknownNanp: function (number, dialCode) {
			return dialCode == "+1" && this._getNumeric(number).length >= 4;
		},
		// remove highlighting from other list items and highlight the given item
		_highlightListItem: function (listItem) {
			this.countryListItems.removeClass("highlight");
			listItem.addClass("highlight");
		},
		// find the country data for the given country code
		// the ignoreOnlyCountriesOption is only used during init() while parsing the onlyCountries array
		_getCountryData: function (countryCode, ignoreOnlyCountriesOption, allowFail) {
			var countryList = ignoreOnlyCountriesOption ? allCountries : this.countries;
			for (var i = 0; i < countryList.length; i++) {
				if (countryList[i].iso2 == countryCode) {
					return countryList[i];
				}
			}
			if (allowFail) {
				return null;
			} else {
				throw new Error("No country data for '" + countryCode + "'");
			}
		},
		// select the given flag, update the placeholder and the active list item
		_selectFlag: function (countryCode, updateDefault) {
			// do this first as it will throw an error and stop if countryCode is invalid
			this.selectedCountryData = countryCode ? this._getCountryData(countryCode, false, false) : {};
			// update the "defaultCountry" - we only need the iso2 from now on, so just store that
			if (updateDefault && this.selectedCountryData.iso2) {
				// can't just make this equal to selectedCountryData as would be a ref to that object
				this.options.defaultCountry = {
					iso2: this.selectedCountryData.iso2
				};
			}
			this.selectedFlagInner.attr("class", "iti-flag " + countryCode);
			// update the selected country's title attribute
			var title = countryCode ? this.selectedCountryData.name + ": +" + this.selectedCountryData.dialCode : "Unknown";
			this.selectedFlagInner.parent().attr("title", title);
			// and the input's placeholder
			this._updatePlaceholder();
			if (this.isMobile) {
				this.countryList.val(countryCode);
			} else {
				// update the active list item
				this.countryListItems.removeClass("active");
				if (countryCode) {
					this.countryListItems.find(".iti-flag." + countryCode).first().closest(".country").addClass("active");
				}
			}
		},
		// update the input placeholder to an example number from the currently selected country
		_updatePlaceholder: function () {
			if (window.intlTelInputUtils && !this.hadInitialPlaceholder && this.options.autoPlaceholder && this.selectedCountryData) {
				var iso2 = this.selectedCountryData.iso2, numberType = intlTelInputUtils.numberType[this.options.numberType || "FIXED_LINE"], placeholder = iso2 ? intlTelInputUtils.getExampleNumber(iso2, this.options.nationalMode, numberType) : "";
				this.telInput.attr("placeholder", placeholder);
			}
		},
		// called when the user selects a list item from the dropdown
		_selectListItem: function (listItem) {
			var countryCodeAttr = this.isMobile ? "value" : "data-country-code";
			// update selected flag and active list item
			this._selectFlag(listItem.attr(countryCodeAttr), true);
			if (!this.isMobile) {
				this._closeDropdown();
			}
			this._updateDialCode(listItem.attr("data-dial-code"), true);
			// always fire the change event as even if nationalMode=true (and we haven't updated the input val), the system as a whole has still changed - see country-sync example. think of it as making a selection from a select element.
			this.telInput.trigger("change");
			// focus the input
			this.telInput.focus();
			// fix for FF and IE11 (with nationalMode=false i.e. auto inserting dial code), who try to put the cursor at the beginning the first time
			if (this.isGoodBrowser) {
				var len = this.telInput.val().length;
				this.telInput[0].setSelectionRange(len, len);
			}
		},
		// close the dropdown and unbind any listeners
		_closeDropdown: function () {
			this.countryList.addClass("hide");
			// update the arrow
			this.selectedFlagInner.children(".arrow").removeClass("up");
			// unbind key events
			$(document).off(this.ns);
			// unbind click-off-to-close
			$("html").off(this.ns);
			// unbind hover and click listeners
			this.countryList.off(this.ns);
		},
		// check if an element is visible within it's container, else scroll until it is
		_scrollTo: function (element, middle) {
			var container = this.countryList, containerHeight = container.height(), containerTop = container.offset().top, containerBottom = containerTop + containerHeight, elementHeight = element.outerHeight(), elementTop = element.offset().top, elementBottom = elementTop + elementHeight, newScrollTop = elementTop - containerTop + container.scrollTop(), middleOffset = containerHeight / 2 - elementHeight / 2;
			if (elementTop < containerTop) {
				// scroll up
				if (middle) {
					newScrollTop -= middleOffset;
				}
				container.scrollTop(newScrollTop);
			} else if (elementBottom > containerBottom) {
				// scroll down
				if (middle) {
					newScrollTop += middleOffset;
				}
				var heightDifference = containerHeight - elementHeight;
				container.scrollTop(newScrollTop - heightDifference);
			}
		},
		// replace any existing dial code with the new one (if not in nationalMode)
		// also we need to know if we're focusing for a couple of reasons e.g. if so, we want to add any formatting suffix, also if the input is empty and we're not in nationalMode, then we want to insert the dial code
		_updateDialCode: function (newDialCode, focusing) {
			var inputVal = this.telInput.val(), newNumber;
			// save having to pass this every time
			newDialCode = "+" + newDialCode;
			if (this.options.nationalMode && inputVal.charAt(0) != "+") {
				// if nationalMode, we just want to re-format
				newNumber = inputVal;
			} else if (inputVal) {
				// if the previous number contained a valid dial code, replace it
				// (if more than just a plus character)
				var prevDialCode = this._getDialCode(inputVal);
				if (prevDialCode.length > 1) {
					newNumber = inputVal.replace(prevDialCode, newDialCode);
				} else {
					// if the previous number didn't contain a dial code, we should persist it
					var existingNumber = inputVal.charAt(0) != "+" ? $.trim(inputVal) : "";
					newNumber = newDialCode + existingNumber;
				}
			} else {
				newNumber = !this.options.autoHideDialCode || focusing ? newDialCode : "";
			}
			this._updateVal(newNumber, null, focusing);
		},
		// try and extract a valid international dial code from a full telephone number
		// Note: returns the raw string inc plus character and any whitespace/dots etc
		_getDialCode: function (number) {
			var dialCode = "";
			// only interested in international numbers (starting with a plus)
			if (number.charAt(0) == "+") {
				var numericChars = "";
				// iterate over chars
				for (var i = 0; i < number.length; i++) {
					var c = number.charAt(i);
					// if char is number
					if ($.isNumeric(c)) {
						numericChars += c;
						// if current numericChars make a valid dial code
						if (this.countryCodes[numericChars]) {
							// store the actual raw string (useful for matching later)
							dialCode = number.substr(0, i + 1);
						}
						// longest dial code is 4 chars
						if (numericChars.length == 4) {
							break;
						}
					}
				}
			}
			return dialCode;
		},
		/********************
		*  PUBLIC METHODS
		********************/
		// this is called when the ipinfo call returns
		autoCountryLoaded: function () {
			if (this.options.defaultCountry == "auto") {
				this.options.defaultCountry = $.fn[pluginName].autoCountry;
				this._setInitialState();
				this.autoCountryDeferred.resolve();
			}
		},
		// remove plugin
		destroy: function () {
			if (!this.isMobile) {
				// make sure the dropdown is closed (and unbind listeners)
				this._closeDropdown();
			}
			// key events, and focus/blur events if autoHideDialCode=true
			this.telInput.off(this.ns);
			if (this.isMobile) {
				// change event on select country
				this.countryList.off(this.ns);
			} else {
				// click event to open dropdown
				this.selectedFlagInner.parent().off(this.ns);
				// label click hack
				this.telInput.closest("label").off(this.ns);
			}
			// remove markup
			var container = this.telInput.parent();
			container.before(this.telInput).remove();
		},
		// extract the phone number extension if present
		getExtension: function () {
			return this.telInput.val().split(" ext. ")[1] || "";
		},
		// format the number to the given type
		getNumber: function (type) {
			if (window.intlTelInputUtils) {
				return intlTelInputUtils.formatNumberByType(this.telInput.val(), this.selectedCountryData.iso2, type);
			}
			return "";
		},
		// get the type of the entered number e.g. landline/mobile
		getNumberType: function () {
			if (window.intlTelInputUtils) {
				return intlTelInputUtils.getNumberType(this.telInput.val(), this.selectedCountryData.iso2);
			}
			return -99;
		},
		// get the country data for the currently selected flag
		getSelectedCountryData: function () {
			// if this is undefined, the plugin will return it's instance instead, so in that case an empty object makes more sense
			return this.selectedCountryData || {};
		},
		// get the validation error
		getValidationError: function () {
			if (window.intlTelInputUtils) {
				return intlTelInputUtils.getValidationError(this.telInput.val(), this.selectedCountryData.iso2);
			}
			return -99;
		},
		// validate the input val - assumes the global function isValidNumber (from utilsScript)
		isValidNumber: function () {
			var val = $.trim(this.telInput.val()), countryCode = this.options.nationalMode ? this.selectedCountryData.iso2 : "";
			if (window.intlTelInputUtils) {
				return intlTelInputUtils.isValidNumber(val, countryCode);
			}
			return false;
		},
		// load the utils script
		loadUtils: function (path) {
			var that = this;
			var utilsScript = path || this.options.utilsScript;
			if (!$.fn[pluginName].loadedUtilsScript && utilsScript) {
				// don't do this twice! (dont just check if the global intlTelInputUtils exists as if init plugin multiple times in quick succession, it may not have finished loading yet)
				$.fn[pluginName].loadedUtilsScript = true;
				// dont use $.getScript as it prevents caching
				$.ajax({
					url: utilsScript,
					success: function () {
						// tell all instances the utils are ready
						$(".intl-tel-input input").intlTelInput("utilsLoaded");
					},
					complete: function () {
						that.utilsScriptDeferred.resolve();
					},
					dataType: "script",
					cache: true
				});
			} else {
				this.utilsScriptDeferred.resolve();
			}
		},
		// update the selected flag, and update the input val accordingly
		selectCountry: function (countryCode) {
			countryCode = countryCode.toLowerCase();
			// check if already selected
			if (!this.selectedFlagInner.hasClass(countryCode)) {
				this._selectFlag(countryCode, true);
				this._updateDialCode(this.selectedCountryData.dialCode, false);
			}
		},
		// set the input value and update the flag
		setNumber: function (number, format, addSuffix, preventConversion, isAllowedKey) {
			// ensure starts with plus
			if (!this.options.nationalMode && number.charAt(0) != "+") {
				number = "+" + number;
			}
			// we must update the flag first, which updates this.selectedCountryData, which is used later for formatting the number before displaying it
			this._updateFlagFromNumber(number);
			this._updateVal(number, format, addSuffix, preventConversion, isAllowedKey);
		},
		// this is called when the utils are ready
		utilsLoaded: function () {
			// if autoFormat is enabled and there's an initial value in the input, then format it
			if (this.options.autoFormat && this.telInput.val()) {
				this._updateVal(this.telInput.val());
			}
			this._updatePlaceholder();
		}
	};
	// adapted to allow public functions
	// using https://github.com/jquery-boilerplate/jquery-boilerplate/wiki/Extending-jQuery-Boilerplate
	$.fn[pluginName] = function (options) {
		var args = arguments;
		// Is the first parameter an object (options), or was omitted,
		// instantiate a new instance of the plugin.
		if (options === undefined || typeof options === "object") {
			var deferreds = [];
			this.each(function () {
				if (!$.data(this, "plugin_" + pluginName)) {
					var instance = new Plugin(this, options);
					var instanceDeferreds = instance._init();
					// we now have 2 deffereds: 1 for auto country, 1 for utils script
					deferreds.push(instanceDeferreds[0]);
					deferreds.push(instanceDeferreds[1]);
					$.data(this, "plugin_" + pluginName, instance);
				}
			});
			// return the promise from the "master" deferred object that tracks all the others
			return $.when.apply(null, deferreds);
		} else if (typeof options === "string" && options[0] !== "_") {
			// If the first parameter is a string and it doesn't start
			// with an underscore or "contains" the `init`-function,
			// treat this as a call to a public method.
			// Cache the method call to make it possible to return a value
			var returns;
			this.each(function () {
				var instance = $.data(this, "plugin_" + pluginName);
				// Tests that there's already a plugin-instance
				// and checks that the requested public method exists
				if (instance instanceof Plugin && typeof instance[options] === "function") {
					// Call the method of our plugin instance,
					// and pass it the supplied arguments.
					returns = instance[options].apply(instance, Array.prototype.slice.call(args, 1));
				}
				// Allow instances to be destroyed via the 'destroy' method
				if (options === "destroy") {
					$.data(this, "plugin_" + pluginName, null);
				}
			});
			// If the earlier cached method gives a value back return the value,
			// otherwise return this to preserve chainability.
			return returns !== undefined ? returns : this;
		}
	};
	/********************
	*  STATIC METHODS
	********************/
	// get the country data object
	$.fn[pluginName].getCountryData = function () {
		return allCountries;
	};
	// Tell JSHint to ignore this warning: "character may get silently deleted by one or more browsers"
	// jshint -W100
	// Array of country objects for the flag dropdown.
	// Each contains a name, country code (ISO 3166-1 alpha-2) and dial code.
	// Originally from https://github.com/mledoze/countries
	// then modified using the following JavaScript (NOW OUT OF DATE):
	/*
var result = [];
_.each(countries, function(c) {
	// ignore countries without a dial code
	if (c.callingCode[0].length) {
		result.push({
			// var locals contains country names with localised versions in brackets
			n: _.findWhere(locals, {
				countryCode: c.cca2
			}).name,
			i: c.cca2.toLowerCase(),
			d: c.callingCode[0]
		});
	}
});
JSON.stringify(result);
*/
	// then with a couple of manual re-arrangements to be alphabetical
	// then changed Kazakhstan from +76 to +7
	// and Vatican City from +379 to +39 (see issue 50)
	// and Caribean Netherlands from +5997 to +599
	// and Curacao from +5999 to +599
	// Removed: Åland Islands, Christmas Island, Cocos Islands, Guernsey, Isle of Man, Jersey, Kosovo, Mayotte, Pitcairn Islands, South Georgia, Svalbard, Western Sahara
	// Update: converted objects to arrays to save bytes!
	// Update: added "priority" for countries with the same dialCode as others
	// Update: added array of area codes for countries with the same dialCode as others
	// So each country array has the following information:
	// [
	//    Country name,
	//    iso2 code,
	//    International dial code,
	//    Order (if >1 country with same dial code),
	//    Area codes (if >1 country with same dial code)
	// ]
	var allCountries = [["Afghanistan (‫افغانستان‬‎)", "af", "93"], ["Albania (Shqipëri)", "al", "355"], ["Algeria (‫الجزائر‬‎)", "dz", "213"], ["American Samoa", "as", "1684"], ["Andorra", "ad", "376"], ["Angola", "ao", "244"], ["Anguilla", "ai", "1264"], ["Antigua and Barbuda", "ag", "1268"], ["Argentina", "ar", "54"], ["Armenia (Հայաստան)", "am", "374"], ["Aruba", "aw", "297"], ["Australia", "au", "61"], ["Austria (Österreich)", "at", "43"], ["Azerbaijan (Azərbaycan)", "az", "994"], ["Bahamas", "bs", "1242"], ["Bahrain (‫البحرين‬‎)", "bh", "973"], ["Bangladesh (বাংলাদেশ)", "bd", "880"], ["Barbados", "bb", "1246"], ["Belarus (Беларусь)", "by", "375"], ["Belgium (België)", "be", "32"], ["Belize", "bz", "501"], ["Benin (Bénin)", "bj", "229"], ["Bermuda", "bm", "1441"], ["Bhutan (འབྲུག)", "bt", "975"], ["Bolivia", "bo", "591"], ["Bosnia and Herzegovina (Босна и Херцеговина)", "ba", "387"], ["Botswana", "bw", "267"], ["Brazil (Brasil)", "br", "55"], ["British Indian Ocean Territory", "io", "246"], ["British Virgin Islands", "vg", "1284"], ["Brunei", "bn", "673"], ["Bulgaria (България)", "bg", "359"], ["Burkina Faso", "bf", "226"], ["Burundi (Uburundi)", "bi", "257"], ["Cambodia (កម្ពុជា)", "kh", "855"], ["Cameroon (Cameroun)", "cm", "237"], ["Canada", "ca", "1", 1, ["204", "226", "236", "249", "250", "289", "306", "343", "365", "387", "403", "416", "418", "431", "437", "438", "450", "506", "514", "519", "548", "579", "581", "587", "604", "613", "639", "647", "672", "705", "709", "742", "778", "780", "782", "807", "819", "825", "867", "873", "902", "905"]], ["Cape Verde (Kabu Verdi)", "cv", "238"], ["Caribbean Netherlands", "bq", "599", 1], ["Cayman Islands", "ky", "1345"], ["Central African Republic (République centrafricaine)", "cf", "236"], ["Chad (Tchad)", "td", "235"], ["Chile", "cl", "56"], ["China (中国)", "cn", "86"], ["Colombia", "co", "57"], ["Comoros (‫جزر القمر‬‎)", "km", "269"], ["Congo (DRC) (Jamhuri ya Kidemokrasia ya Kongo)", "cd", "243"], ["Congo (Republic) (Congo-Brazzaville)", "cg", "242"], ["Cook Islands", "ck", "682"], ["Costa Rica", "cr", "506"], ["Côte d’Ivoire", "ci", "225"], ["Croatia (Hrvatska)", "hr", "385"], ["Cuba", "cu", "53"], ["Curaçao", "cw", "599", 0], ["Cyprus (Κύπρος)", "cy", "357"], ["Czech Republic (Česká republika)", "cz", "420"], ["Denmark (Danmark)", "dk", "45"], ["Djibouti", "dj", "253"], ["Dominica", "dm", "1767"], ["Dominican Republic (República Dominicana)", "do", "1", 2, ["809", "829", "849"]], ["Ecuador", "ec", "593"], ["Egypt (‫مصر‬‎)", "eg", "20"], ["El Salvador", "sv", "503"], ["Equatorial Guinea (Guinea Ecuatorial)", "gq", "240"], ["Eritrea", "er", "291"], ["Estonia (Eesti)", "ee", "372"], ["Ethiopia", "et", "251"], ["Falkland Islands (Islas Malvinas)", "fk", "500"], ["Faroe Islands (Føroyar)", "fo", "298"], ["Fiji", "fj", "679"], ["Finland (Suomi)", "fi", "358"], ["France", "fr", "33"], ["French Guiana (Guyane française)", "gf", "594"], ["French Polynesia (Polynésie française)", "pf", "689"], ["Gabon", "ga", "241"], ["Gambia", "gm", "220"], ["Georgia (საქართველო)", "ge", "995"], ["Germany (Deutschland)", "de", "49"], ["Ghana (Gaana)", "gh", "233"], ["Gibraltar", "gi", "350"], ["Greece (Ελλάδα)", "gr", "30"], ["Greenland (Kalaallit Nunaat)", "gl", "299"], ["Grenada", "gd", "1473"], ["Guadeloupe", "gp", "590", 0], ["Guam", "gu", "1671"], ["Guatemala", "gt", "502"], ["Guinea (Guinée)", "gn", "224"], ["Guinea-Bissau (Guiné Bissau)", "gw", "245"], ["Guyana", "gy", "592"], ["Haiti", "ht", "509"], ["Honduras", "hn", "504"], ["Hong Kong (香港)", "hk", "852"], ["Hungary (Magyarország)", "hu", "36"], ["Iceland (Ísland)", "is", "354"], ["India (भारत)", "in", "91"], ["Indonesia", "id", "62"], ["Iran (‫ایران‬‎)", "ir", "98"], ["Iraq (‫العراق‬‎)", "iq", "964"], ["Ireland", "ie", "353"], ["Israel (‫ישראל‬‎)", "il", "972"], ["Italy (Italia)", "it", "39", 0], ["Jamaica", "jm", "1876"], ["Japan (日本)", "jp", "81"], ["Jordan (‫الأردن‬‎)", "jo", "962"], ["Kazakhstan (Казахстан)", "kz", "7", 1], ["Kenya", "ke", "254"], ["Kiribati", "ki", "686"], ["Kuwait (‫الكويت‬‎)", "kw", "965"], ["Kyrgyzstan (Кыргызстан)", "kg", "996"], ["Laos (ລາວ)", "la", "856"], ["Latvia (Latvija)", "lv", "371"], ["Lebanon (‫لبنان‬‎)", "lb", "961"], ["Lesotho", "ls", "266"], ["Liberia", "lr", "231"], ["Libya (‫ليبيا‬‎)", "ly", "218"], ["Liechtenstein", "li", "423"], ["Lithuania (Lietuva)", "lt", "370"], ["Luxembourg", "lu", "352"], ["Macau (澳門)", "mo", "853"], ["Macedonia (FYROM) (Македонија)", "mk", "389"], ["Madagascar (Madagasikara)", "mg", "261"], ["Malawi", "mw", "265"], ["Malaysia", "my", "60"], ["Maldives", "mv", "960"], ["Mali", "ml", "223"], ["Malta", "mt", "356"], ["Marshall Islands", "mh", "692"], ["Martinique", "mq", "596"], ["Mauritania (‫موريتانيا‬‎)", "mr", "222"], ["Mauritius (Moris)", "mu", "230"], ["Mexico (México)", "mx", "52"], ["Micronesia", "fm", "691"], ["Moldova (Republica Moldova)", "md", "373"], ["Monaco", "mc", "377"], ["Mongolia (Монгол)", "mn", "976"], ["Montenegro (Crna Gora)", "me", "382"], ["Montserrat", "ms", "1664"], ["Morocco (‫المغرب‬‎)", "ma", "212"], ["Mozambique (Moçambique)", "mz", "258"], ["Myanmar (Burma) (မြန်မာ)", "mm", "95"], ["Namibia (Namibië)", "na", "264"], ["Nauru", "nr", "674"], ["Nepal (नेपाल)", "np", "977"], ["Netherlands (Nederland)", "nl", "31"], ["New Caledonia (Nouvelle-Calédonie)", "nc", "687"], ["New Zealand", "nz", "64"], ["Nicaragua", "ni", "505"], ["Niger (Nijar)", "ne", "227"], ["Nigeria", "ng", "234"], ["Niue", "nu", "683"], ["Norfolk Island", "nf", "672"], ["North Korea (조선 민주주의 인민 공화국)", "kp", "850"], ["Northern Mariana Islands", "mp", "1670"], ["Norway (Norge)", "no", "47"], ["Oman (‫عُمان‬‎)", "om", "968"], ["Pakistan (‫پاکستان‬‎)", "pk", "92"], ["Palau", "pw", "680"], ["Palestine (‫فلسطين‬‎)", "ps", "970"], ["Panama (Panamá)", "pa", "507"], ["Papua New Guinea", "pg", "675"], ["Paraguay", "py", "595"], ["Peru (Perú)", "pe", "51"], ["Philippines", "ph", "63"], ["Poland (Polska)", "pl", "48"], ["Portugal", "pt", "351"], ["Puerto Rico", "pr", "1", 3, ["787", "939"]], ["Qatar (‫قطر‬‎)", "qa", "974"], ["Réunion (La Réunion)", "re", "262"], ["Romania (România)", "ro", "40"], ["Russia (Россия)", "ru", "7", 0], ["Rwanda", "rw", "250"], ["Saint Barthélemy (Saint-Barthélemy)", "bl", "590", 1], ["Saint Helena", "sh", "290"], ["Saint Kitts and Nevis", "kn", "1869"], ["Saint Lucia", "lc", "1758"], ["Saint Martin (Saint-Martin (partie française))", "mf", "590", 2], ["Saint Pierre and Miquelon (Saint-Pierre-et-Miquelon)", "pm", "508"], ["Saint Vincent and the Grenadines", "vc", "1784"], ["Samoa", "ws", "685"], ["San Marino", "sm", "378"], ["São Tomé and Príncipe (São Tomé e Príncipe)", "st", "239"], ["Saudi Arabia (‫المملكة العربية السعودية‬‎)", "sa", "966"], ["Senegal (Sénégal)", "sn", "221"], ["Serbia (Србија)", "rs", "381"], ["Seychelles", "sc", "248"], ["Sierra Leone", "sl", "232"], ["Singapore", "sg", "65"], ["Sint Maarten", "sx", "1721"], ["Slovakia (Slovensko)", "sk", "421"], ["Slovenia (Slovenija)", "si", "386"], ["Solomon Islands", "sb", "677"], ["Somalia (Soomaaliya)", "so", "252"], ["South Africa", "za", "27"], ["South Korea (대한민국)", "kr", "82"], ["South Sudan (‫جنوب السودان‬‎)", "ss", "211"], ["Spain (España)", "es", "34"], ["Sri Lanka (ශ්‍රී ලංකාව)", "lk", "94"], ["Sudan (‫السودان‬‎)", "sd", "249"], ["Suriname", "sr", "597"], ["Swaziland", "sz", "268"], ["Sweden (Sverige)", "se", "46"], ["Switzerland (Schweiz)", "ch", "41"], ["Syria (‫سوريا‬‎)", "sy", "963"], ["Taiwan (台灣)", "tw", "886"], ["Tajikistan", "tj", "992"], ["Tanzania", "tz", "255"], ["Thailand (ไทย)", "th", "66"], ["Timor-Leste", "tl", "670"], ["Togo", "tg", "228"], ["Tokelau", "tk", "690"], ["Tonga", "to", "676"], ["Trinidad and Tobago", "tt", "1868"], ["Tunisia (‫تونس‬‎)", "tn", "216"], ["Turkey (Türkiye)", "tr", "90"], ["Turkmenistan", "tm", "993"], ["Turks and Caicos Islands", "tc", "1649"], ["Tuvalu", "tv", "688"], ["U.S. Virgin Islands", "vi", "1340"], ["Uganda", "ug", "256"], ["Ukraine (Україна)", "ua", "380"], ["United Arab Emirates (‫الإمارات العربية المتحدة‬‎)", "ae", "971"], ["United Kingdom", "gb", "44"], ["United States", "us", "1", 0], ["Uruguay", "uy", "598"], ["Uzbekistan (Oʻzbekiston)", "uz", "998"], ["Vanuatu", "vu", "678"], ["Vatican City (Città del Vaticano)", "va", "39", 1], ["Venezuela", "ve", "58"], ["Vietnam (Việt Nam)", "vn", "84"], ["Wallis and Futuna", "wf", "681"], ["Yemen (‫اليمن‬‎)", "ye", "967"], ["Zambia", "zm", "260"], ["Zimbabwe", "zw", "263"]];
	// loop over all of the countries above
	for (var i = 0; i < allCountries.length; i++) {
		var c = allCountries[i];
		allCountries[i] = {
			name: c[0],
			iso2: c[1],
			dialCode: c[2],
			priority: c[3] || 0,
			areaCodes: c[4] || null
		};
	}
});

/// End file: intlTelInput.js

/// <reference path="../../typings/jquery/jquery.d.ts" />
var RtlModule;
(function (RtlModule) {
    var Rtl = (function () {
        function Rtl() {
        }
        Rtl.Initialize = function () {
            $("span:not([nortl]):not([dir=rtl])").append(function () {
                $(this).attr("dir", "rtl");
            });
        };
        return Rtl;
    }());
    RtlModule.Rtl = Rtl;
})(RtlModule || (RtlModule = {}));

var ElementItem;
(function (ElementItem) {
    // this is unfinished script
    // To do: 
    // - ability to pass an array of ModifierTypes
    // - remove class duplicates
    // - add other modifiers
    (function (ModifierType) {
        ModifierType[ModifierType["Default"] = 0] = "Default";
        ModifierType[ModifierType["NotValid"] = 1] = "NotValid";
        ModifierType[ModifierType["Disabled"] = 2] = "Disabled";
        ModifierType[ModifierType["Process"] = 3] = "Process";
        ModifierType[ModifierType["Failed"] = 4] = "Failed";
        ModifierType[ModifierType["Success"] = 5] = "Success";
        ModifierType[ModifierType["Short"] = 6] = "Short";
        ModifierType[ModifierType["Full"] = 7] = "Full";
        ModifierType[ModifierType["Visible"] = 8] = "Visible";
        ModifierType[ModifierType["Hidden"] = 9] = "Hidden";
    })(ElementItem.ModifierType || (ElementItem.ModifierType = {}));
    var ModifierType = ElementItem.ModifierType;
    var Modifier = (function () {
        function Modifier() {
        }
        Modifier.GetModifierTypeClass = function (modifierType) {
            var modifierTypeClass = '';
            switch (modifierType) {
                case ModifierType.Default: {
                    modifierTypeClass = '';
                    break;
                }
                case ModifierType.NotValid: {
                    modifierTypeClass = '__not-valid';
                    break;
                }
                case ModifierType.Disabled: {
                    modifierTypeClass = '__disabled';
                    break;
                }
                case ModifierType.Process: {
                    modifierTypeClass = '__process';
                    break;
                }
                case ModifierType.Failed: {
                    modifierTypeClass = '__failed';
                    break;
                }
                case ModifierType.Success: {
                    modifierTypeClass = '__success';
                    break;
                }
                case ModifierType.Short: {
                    modifierTypeClass = '__short';
                    break;
                }
                case ModifierType.Full: {
                    modifierTypeClass = '__full';
                    break;
                }
                case ModifierType.Visible: {
                    modifierTypeClass = '__visible';
                    break;
                }
                case ModifierType.Hidden: {
                    modifierTypeClass = '__hidden';
                    break;
                }
            }
            return modifierTypeClass;
        };
        Modifier.ChangeTo = function ($element, modifier) {
            $element.removeClass('__not-valid __disabled __process __failed __success __short __full __visible __hidden');
            switch (modifier) {
                case ModifierType.Process: {
                    $element.prop('disabled', true);
                    // if $element has class button with __icon modifier, we don't add any html for spinner inside
                    if (!$element.hasClass('btn __icon')) {
                        $element.prepend('<i class="fa fa-spin fa-spinner btn_icon"></i>');
                    }
                    break;
                }
                default: {
                    if ($element.prop('disabled') !== undefined) {
                        $element.prop('disabled', false);
                    }
                    break;
                }
            }
            $element.addClass(Modifier.GetModifierTypeClass(modifier));
        };
        //toggle between modifiers or init by default modifier it no any are presented
        Modifier.ToggleBetweenOrInitByFirst = function ($element, defaultModifier, secondaryModifier) {
            var defaultModifierClass = Modifier.GetModifierTypeClass(defaultModifier);
            var secondaryModifierClass = Modifier.GetModifierTypeClass(secondaryModifier);
            var hasDefaultModifier = $element.hasClass(defaultModifierClass);
            var resultModifier;
            $element.removeClass(Modifier.GetModifierTypeClass(defaultModifier));
            $element.removeClass(Modifier.GetModifierTypeClass(secondaryModifier));
            if (hasDefaultModifier) {
                $element.addClass(secondaryModifierClass);
                resultModifier = secondaryModifier;
            }
            else {
                $element.addClass(defaultModifierClass);
                resultModifier = defaultModifier;
            }
            return resultModifier;
        };
        return Modifier;
    }());
    ElementItem.Modifier = Modifier;
})(ElementItem || (ElementItem = {}));

/// <reference path="../../typings/jquery/jquery.d.ts"/>
/// <reference path="../../typings/kendo/kendo.all.d.ts"/>
/// <reference path="../../typings/kendo/kendo.portia.d.ts"/>
/// <reference path="../../typings/modernizr/modernizr.d.ts" />
/// <reference path="../../typings/jquery.transit/jquery.transit.d.ts" />
/// <reference path="../../typings/nanoscroller/nanoscroller.d.ts"/>
/// <reference path="./ElementItem.ts" />
var UI;
(function (UI) {
    var Spin = (function () {
        function Spin() {
        }
        Spin.onSubmitFormStart = function (formId, sender, args) {
            var form;
            // Global event is undefined in firefox - bug 25546
            if (typeof (event) != "undefined") {
                form = $(event.srcElement || event.target);
            }
            else {
                form = $('#' + formId);
            }
            var submit = form.find(':submit');
            submit.prop('disabled', true);
            submit.prepend('<i class="fa fa-spin fa-spinner btn_icon"></i>');
        };
        Spin.showSpinner = function (target, color) {
            if (color === void 0) { color = 'white'; }
            switch (color) {
                case 'black': {
                    $('<i class="fa fa-spin fa-spinner fa-1-5x __black"></i>').insertBefore(target);
                    break;
                }
                case 'white':
                default: {
                    $('<i class="fa fa-spin fa-spinner fa-1-5x"></i>').insertBefore(target);
                    break;
                }
            }
        };
        Spin.replaceIconWithSpinner = function (target) {
            target.prop('disabled', true);
            target.find('i.btn_icon').hide();
            target.prepend('<i class="icon fa fa-spin fa-spinner btn_icon"></i>');
        };
        Spin.replaceSpinnerWithIcon = function (target) {
            target.find('i.fa-spin').remove();
            target.find('i.btn_icon').show();
            target.prop('disabled', false);
        };
        Spin.stopSpinner = function (target) {
            $(target).prev(".fa-spin").remove();
        };
        Spin.ajaxSpin = function (ajaxOpts) {
            ajaxOpts.context.prop('disabled', true);
            Spin.showSpinner(ajaxOpts.context);
            var complete = ajaxOpts.complete;
            ajaxOpts.complete = function (jqXHR, status) {
                Spin.stopSpinner(ajaxOpts.context);
                if (complete != undefined) {
                    complete(jqXHR, status);
                }
            };
            $.ajax(ajaxOpts);
        };
        return Spin;
    }());
    UI.Spin = Spin;
    var NanoScroller = (function () {
        function NanoScroller() {
        }
        NanoScroller.getNanoScroller = function (selector) {
            if (selector == undefined) {
                return $('.nano');
            }
            else {
                return $(selector);
            }
        };
        return NanoScroller;
    }());
    UI.NanoScroller = NanoScroller;
    var KendoHelpers = (function () {
        function KendoHelpers() {
        }
        KendoHelpers.getWidget = function (element) {
            return kendo.widgetInstance(element.closest("[data-" + kendo.ns + "role]"), kendo.ui);
        };
        KendoHelpers.getTabsApi = function (element) {
            return this.getWidget($(element));
        };
        return KendoHelpers;
    }());
    UI.KendoHelpers = KendoHelpers;
    var Overlay = (function () {
        function Overlay() {
        }
        Overlay.addOverlay = function (elem, overlayClass, left, top, closeButton) {
            if (closeButton === void 0) { closeButton = false; }
            if (elem.length > 0) {
                if (typeof top == 'string' && top == 'center') {
                    top = Math.max(($(window).height() - elem.outerHeight(true)) / 2, 0);
                    elem.css('top', top);
                }
                if (typeof left == 'string' && left == 'center') {
                    left = Math.max(($(window).width() - elem.outerWidth(true)) / 2, 0);
                    elem.css('left', left);
                }
                if (closeButton && !elem.find('.close').length) {
                    elem.append('<a class="close"></a>');
                }
                $('<div class="k-overlay ' + overlayClass + '"></div>').appendTo('body');
                elem.show();
                if (closeButton) {
                    elem.find('.close').on('click', function () {
                        Overlay.hideOverlay(elem, overlayClass);
                    });
                }
            }
        };
        Overlay.hideOverlay = function (elem, overlayClass) {
            elem.hide();
            $('.k-overlay.' + overlayClass + '').remove();
        };
        return Overlay;
    }());
    UI.Overlay = Overlay;
    (function (ModalViewFooterContentType) {
        ModalViewFooterContentType[ModalViewFooterContentType["Button"] = 0] = "Button";
        ModalViewFooterContentType[ModalViewFooterContentType["DataAttributeBased"] = 1] = "DataAttributeBased";
    })(UI.ModalViewFooterContentType || (UI.ModalViewFooterContentType = {}));
    var ModalViewFooterContentType = UI.ModalViewFooterContentType;
    var ModalViewClass = (function () {
        function ModalViewClass() {
        }
        ModalViewClass.Root = 'modalview';
        ModalViewClass.Overlay = 'modalview_overlay';
        ModalViewClass.Window = 'modalview_window';
        ModalViewClass.WindowHeader = 'modalview_window_header';
        ModalViewClass.WindowHeaderTitle = 'modalview_window_header_title';
        ModalViewClass.WindowHeaderCancel = 'modalview_window_header_cancel';
        ModalViewClass.WindowContent = 'modalview_window_content';
        ModalViewClass.WindowFooter = 'modalview_window_footer';
        ModalViewClass.WindowFooterCaption = 'modalview_window_footer_caption';
        ModalViewClass.WindowFooterButton = 'modalview_window_footer_button';
        return ModalViewClass;
    }());
    var ModalViewModifiers = (function () {
        function ModalViewModifiers() {
        }
        ModalViewModifiers.HasFooter = '__has-footer';
        ModalViewModifiers.HasFooterCaption = '__has-footer-caption';
        ModalViewModifiers.HasFooterButton = '__has-footer-button';
        return ModalViewModifiers;
    }());
    var ModalView = (function () {
        function ModalView() {
        }
        // Check if passed JQuery element is inside ModalView
        ModalView.ContainsElement = function ($element) {
            return $.isPlainObject($element.parents('.' + ModalViewClass.Root + ':first').data('modalView'));
        };
        // Get parent ModalView Jquery element, if available
        ModalView.GetParentInstance = function ($element) {
            return $element.parents('.' + ModalViewClass.Root + ':first');
        };
        ModalView.create = function (options) {
            // Prevent duplicate initialization
            if ($('#' + options.modalViewId).length > 0) {
                return false;
            }
            ;
            var hasFooter = typeof options.footer !== "undefined" && !options.footer.disabled;
            var html = '<div id="' + options.modalViewId + '" class="' + ModalViewClass.Root + ' __no-print">';
            html += '<div class="' + ModalViewClass.Overlay + '"></div>';
            html += '<div class="wrapper">';
            html += '<div class="wrapper_content"><div class="' + ModalViewClass.Window + '">';
            html += '<header class="' + ModalViewClass.WindowHeader + '">';
            html += '<div class="' + ModalViewClass.WindowHeaderTitle + '">' + options.title + '</div>';
            html += '<button class="' + ModalViewClass.WindowHeaderCancel + ' btn __small"><i class="fa fa-times"></i></button>';
            html += '</header>';
            html += '<div class="' + ModalViewClass.WindowContent + '">';
            if (options.getContentFromId != undefined) {
                html += $('#' + options.getContentFromId).html();
                $('#' + options.getContentFromId).remove();
            }
            html += '</div>';
            if (hasFooter) {
                html += '<footer class="' + ModalViewClass.WindowFooter + '">';
                switch (options.footer.contentType) {
                    case ModalViewFooterContentType.Button: {
                        html += '<button class="' + ModalViewClass.WindowFooterButton + ' btn">' + options.footer.buttonText + '</button>';
                        break;
                    }
                    case ModalViewFooterContentType.DataAttributeBased: {
                        html += '<div class="' + ModalViewClass.WindowFooterCaption + '"></div>';
                        html += '<button class="' + ModalViewClass.WindowFooterButton + ' btn"></button>';
                        break;
                    }
                }
                html += '</footer>';
            }
            html += '</div></div></div></div>';
            $('body').append(html);
            var $element = $('#' + options.modalViewId);
            // Bind events
            // Cancel
            $element.find('.' + ModalViewClass.WindowHeaderCancel).on(System.Browser.Click, function () {
                ModalView.close($element, options.onClose);
            });
            // Footer button
            if (typeof options.onFooterButtonAction !== "undefined" && options.footer.contentType == ModalViewFooterContentType.Button) {
                $element.find('.' + ModalViewClass.WindowFooter + ' > .' + ModalViewClass.WindowFooterButton).on(System.Browser.Click, function () {
                    options.onFooterButtonAction($element);
                });
            }
            // Click on overlay
            if (options.closeOnOverlayClick) {
                $element
                    .find('.' + ModalViewClass.Overlay)
                    .on(System.Browser.Click, function () {
                    ModalView.close($element, options.onClose);
                });
            }
            // Click on selector to open
            if (typeof options.openOnClickFromSelector !== "undefined") {
                options
                    .openOnClickFromSelector
                    .on(System.Browser.Click, options, function () {
                    // Call onBeforeOpen callback if available
                    if ($.isFunction(options.onBeforeOpen)) {
                        options.onBeforeOpen($element);
                    }
                    ModalView.open($element, options.onOpen);
                });
            }
            // Set properties for data object
            var properties = {
                element: $element,
                open: function () {
                    // Call onBeforeOpen callback if available
                    if ($.isFunction(options.onBeforeOpen)) {
                        options.onBeforeOpen($element);
                    }
                    ModalView.open($element, options.onOpen);
                },
                close: function () {
                    ModalView.close($element, options.onClose);
                },
                refreshFooter: function (dataAttributeValue) {
                    var $sourceElement = $element.find('.' + ModalViewClass.WindowContent).find('[data-modalview-footer="' + dataAttributeValue + '"]').first();
                    // Process button
                    var $destinationElementButton = $element.find('.' + ModalViewClass.WindowFooterButton);
                    if ($sourceElement.data('modalview-footer-button') != undefined) {
                        $destinationElementButton
                            .text($sourceElement.data('modalview-footer-button'))
                            .off()
                            .on(System.Browser.Click, function () {
                            $sourceElement.trigger(System.Browser.Click);
                        });
                        $element.addClass(ModalViewModifiers.HasFooterButton);
                    }
                    else {
                        $element.removeClass(ModalViewModifiers.HasFooterButton);
                        $destinationElementButton.text('');
                    }
                    $destinationElementButton.prop('disabled', false);
                    // Process caption
                    var $destinationElementCaption = $element.find('.' + ModalViewClass.WindowFooterCaption);
                    if ($sourceElement.data('modalview-footer-caption') != undefined) {
                        $destinationElementCaption.text($sourceElement.data('modalview-footer-caption'));
                        $element.addClass(ModalViewModifiers.HasFooterCaption);
                    }
                    else {
                        $element.removeClass(ModalViewModifiers.HasFooterCaption);
                        $destinationElementCaption.text('');
                    }
                    if ($sourceElement != undefined && dataAttributeValue != undefined) {
                        ElementItem.Modifier.ChangeTo($sourceElement, ElementItem.ModifierType.Hidden);
                    }
                },
                getContentElement: function () {
                    return $element.find('.' + ModalViewClass.WindowContent);
                },
                getFooterElement: function () {
                    return $element.find('.' + ModalViewClass.WindowFooter);
                },
                getFooterButtonElement: function () {
                    return $element.find('.' + ModalViewClass.WindowFooterButton);
                },
                options: options
            };
            $element.data('modalView', properties);
            // Visual and interface stuff
            if (options.staticWidth) {
                $element
                    .find('.' + ModalViewClass.Window)
                    .css('width', options.staticWidth);
            }
            if (hasFooter) {
                $element.addClass(ModalViewModifiers.HasFooter);
                switch (options.footer.contentType) {
                    case ModalViewFooterContentType.Button: {
                        $element.addClass(ModalViewModifiers.HasFooterButton);
                        if (options.footer.buttonModifier != undefined) {
                            $element
                                .find('.' + ModalViewClass.WindowFooterButton)
                                .addClass(options.footer.buttonModifier);
                        }
                        break;
                    }
                }
            }
            // Call onCreate callback if available
            if ($.isFunction(options.onCreate)) {
                options.onCreate($element);
            }
        };
        ModalView.open = function ($element, callback) {
            ElementItem.Modifier.ChangeTo($element, ElementItem.ModifierType.Visible);
            var top = -window.pageYOffset;
            $('html')
                .addClass('disable-scroll')
                .addClass('modalview-is-active');
            $('.scroll-wrapper')
                .addClass('content-fixing')
                .css('top', top)
                .css('bottom', 0)
                .css('right', 0)
                .css('left', 0);
            // Call onOpen callback if available
            if ($.isFunction(callback)) {
                callback($element);
            }
        };
        ModalView.close = function ($element, callback) {
            var top = $('.scroll-wrapper').offset().top;
            $('html')
                .removeClass('disable-scroll')
                .removeClass('modalview-is-active');
            $('.scroll-wrapper')
                .removeClass('content-fixing')
                .removeAttr('style');
            window.scroll(0, -top);
            ElementItem.Modifier.ChangeTo($element, ElementItem.ModifierType.Hidden);
            // Call onClose callback if available
            if ($.isFunction(callback)) {
                callback($element);
            }
        };
        return ModalView;
    }());
    UI.ModalView = ModalView;
    // Global Scroller
    var GlobalScroller = (function () {
        function GlobalScroller() {
        }
        GlobalScroller.disable = function () {
            if (System.Browser.IsPhone()) {
                GlobalScroller.scrollTop = $(window).scrollTop();
                $('html').addClass('__disable-global-scroller');
            }
        };
        GlobalScroller.enable = function () {
            if (System.Browser.IsPhone()) {
                $('html').removeClass('__disable-global-scroller');
                $(window).scrollTop(GlobalScroller.scrollTop);
            }
        };
        GlobalScroller.scrollTop = 0;
        return GlobalScroller;
    }());
    UI.GlobalScroller = GlobalScroller;
    var PopOver = (function () {
        function PopOver() {
        }
        PopOver.create = function (options) {
            if (options.useDefaultHtmlStructure) {
                var html = '<div id="' + options.popOverId + '" class="popover __hidden __no-print">';
                html += '<div class="popover_overlay"></div>';
                html += '<div class="popover_pointer"></div>';
                html += '<div class="popover_content">';
                html += '</div>';
                html += '</div>';
                $('body').append(html);
            }
            var element = $('#' + options.popOverId);
            if (!options.useDefaultHtmlStructure) {
                element.appendTo('body');
            }
            // Bind events
            element.find('.popover_overlay').on('click', function () {
                PopOver.close(element, options.onClose);
            });
            // Set properties for data object
            var properties = {
                element: element,
                open: function (sourceElement) {
                    PopOver.open(element, options.onOpen, sourceElement);
                },
                close: function () {
                    PopOver.close(element, options.onClose);
                },
                options: options
            };
            element.data('popOver', properties);
        };
        PopOver.open = function (element, callback, sourceElement) {
            if (sourceElement != undefined) {
                //var arrowx = sourceElement.position().top + sourceElement.outerHeight(true);
                var arrowy = sourceElement.offset().left;
                $('.popover_pointer').css('left', arrowy);
            }
            ElementItem.Modifier.ChangeTo(element, ElementItem.ModifierType.Visible);
            GlobalScroller.disable();
            if (typeof callback !== "undefined") {
                callback(element);
            }
        };
        PopOver.close = function (element, callback) {
            GlobalScroller.enable();
            //redo redo redo
            $('#header_immobox-pager .pager_nav_tab').removeClass('__open');
            ElementItem.Modifier.ChangeTo(element, ElementItem.ModifierType.Hidden);
            if (typeof callback !== "undefined") {
                callback(element);
            }
        };
        return PopOver;
    }());
    UI.PopOver = PopOver;
    function applyNanoScroller() {
        if ($.isFunction($.fn.nanoScroller) && !Modernizr.overflowscrolling) {
            UI.NanoScroller.getNanoScroller().nanoScroller();
        }
    }
    UI.applyNanoScroller = applyNanoScroller;
})(UI || (UI = {}));

/// <reference path="../../typings/jquery/jquery.d.ts" />
/// <reference path="../../typings/jquery.validation/jquery.validation.d.ts" />
/// <reference path="../../typings/modernizr/modernizr.d.ts" />
/// <reference path="../../typings/kendo/kendo.all.d.ts"/>
/// <reference path="../../typings/kendo/kendo.portia.d.ts"/>
/// <reference path="../../typings/portia/main.d.ts" />
/// <reference path="../../typings/URI.js/URI.d.ts" />
/// <reference path="./MyImmoBox.ts" />
/// <reference path="./common.ts" />
/// <reference path="./system.ts" />
/// <reference path="./UI.ts" />
var Alerts;
(function (Alerts) {
    var TrackingName = (function () {
        function TrackingName() {
        }
        TrackingName.NewAlertSearch = "NewAlertSearch";
        TrackingName.NewAlertLatestSearch = "NewAlertLatestSearch";
        return TrackingName;
    }());
    Alerts.TrackingName = TrackingName;
    var Initialize = (function () {
        function Initialize() {
        }
        Initialize.All = function (alertData) {
            PortiaConstants.Values.Alert = alertData;
            Alerts.Initialize.Triggers();
            Alerts.Initialize.ConfirmWindow();
            Alerts.Initialize.ProcessURI();
        };
        Initialize.LoginWindow = function () {
            UI.ModalView.create({
                modalViewId: "alert-modalview",
                title: PortiaConstants.Dicos.Alert.Title,
                staticWidth: 450,
                footer: {
                    contentType: UI.ModalViewFooterContentType.DataAttributeBased
                },
                onOpen: function ($element) {
                    // Apply placeholders where native support is unavailable
                    if (!Modernizr.placeholder) {
                        $('.lead-request :input[placeholder]').placeholder({ width: 252 });
                    }
                },
                onCreate: function ($element) {
                    var returnUrl = new URI();
                    returnUrl.addFragment("returnCallback", "alert");
                    returnUrl.addFragment("alertTrackingName", PortiaConstants.Values.Alert.TrackingName.toString());
                    $element
                        .data('modalView')
                        .getContentElement()
                        .load('/' + System.getLanguage() + '/Account/LogonFrom?returnUrl=' + URI.encode(returnUrl.toString()), function () {
                        $element
                            .data('modalView')
                            .open();
                    });
                },
                onClose: function ($element) {
                    $element.remove();
                    UI.Spin.stopSpinner($('#immobox-container .immobox_create-alert .btn_text'));
                    ElementItem.Modifier.ChangeTo($('#refine-search .search-form_controls_alert'), ElementItem.ModifierType.Default);
                }
            });
        };
        Initialize.ConfirmWindow = function () {
            UI.ModalView.create({
                modalViewId: "alert-confirm-modalview",
                title: PortiaConstants.Dicos.Alert.Title,
                footer: {
                    contentType: UI.ModalViewFooterContentType.Button,
                    buttonText: PortiaConstants.Dicos.Shared.Close,
                    buttonModifier: "__3"
                },
                onClose: function (element) {
                    MyImmoBox.Requests.RemoveSpinner();
                },
                onFooterButtonAction: function (element) {
                    element
                        .data('modalView')
                        .close();
                }
            });
        };
        Initialize.Triggers = function () {
            var alertTriggers = [
                {
                    Parent: '#immobox-container',
                    Child: '.immobox_create-alert'
                },
                {
                    Parent: '#refine-search',
                    Child: '.search-form_controls_alert'
                }
            ];
            $.each(alertTriggers, function () {
                var parent = this.Parent;
                var child = this.Child;
                $(parent)
                    .off(System.Browser.ClickEventName, child)
                    .on(System.Browser.ClickEventName, child, function () {
                    var $element = $(this);
                    if ($element.hasClass('search-form_controls_alert')) {
                        PortiaConstants.Values.Alert.TrackingName = Alerts.TrackingName.NewAlertSearch;
                        ElementItem.Modifier.ChangeTo($element, ElementItem.ModifierType.Process);
                    }
                    if ($element.hasClass('immobox_create-alert')) {
                        PortiaConstants.Values.Alert.TrackingName = Alerts.TrackingName.NewAlertLatestSearch;
                        UI.Spin.showSpinner($element.find('.btn_text'));
                    }
                    var tempAlertData = {
                        SearchCriteriaImmoId: $element.data('search-criteria-id'),
                        Title: $element.data('title'),
                        Price: $element.data('price'),
                        Currency: $element.data('currency')
                    };
                    $.extend(true, PortiaConstants.Values.Alert, tempAlertData);
                    Alerts.Requests.Subscribe(PortiaConstants.Values.Alert);
                });
            });
        };
        Initialize.ProcessURI = function () {
            var uri = new URI();
            if ($.isPlainObject(uri.fragment(true)) && uri.fragment(true)["returnCallback"] == "alert") {
                uri.removeFragment("returnCallback");
                if (uri.fragment(true)["alertTrackingName"] != '') {
                    PortiaConstants.Values.Alert.TrackingName = uri.fragment(true)["alertTrackingName"];
                    uri.removeFragment("alertTrackingName");
                }
                Alerts.Requests.Subscribe(PortiaConstants.Values.Alert);
                if ($.isEmptyObject(uri.fragment(true)) && Modernizr.history) {
                    history.pushState("", document.title, uri.toString());
                }
                else {
                    window.location.hash = uri.fragment();
                }
            }
        };
        return Initialize;
    }());
    Alerts.Initialize = Initialize;
    var Requests = (function () {
        function Requests() {
        }
        Requests.Subscribe = function (ajaxData, $modalViewElement) {
            if (System.getUserAuthenticationType() != System.UserAuthenticationType.FullAuthenticated) {
                Alerts.Initialize.LoginWindow();
            }
            else {
                $.ajax({
                    method: 'POST',
                    url: '/' + System.getLanguage() + "/Account/AlertSubscribe",
                    data: ajaxData,
                    success: function (pResult) {
                        UI.Spin.stopSpinner($('#immobox-container .immobox_create-alert .btn_text'));
                        ElementItem.Modifier.ChangeTo($('#refine-search .search-form_controls_alert'), ElementItem.ModifierType.Default);
                        if ($modalViewElement != undefined) {
                            $modalViewElement
                                .data('modalView')
                                .close();
                        }
                        var modalView = $('#alert-confirm-modalview').data('modalView');
                        modalView
                            .getContentElement()
                            .html(pResult);
                        modalView.open();
                        $.ajax({
                            url: '/' + System.getLanguage() + "/RecentSearch/GetRecentSearchesAndAlerts",
                            success: function (pResult) {
                                MyImmoBox.GetTabsControl().UpdateMenu(MyImmoBox.TabsEnum.RecentSearches);
                            }
                        });
                    }
                });
            }
        };
        return Requests;
    }());
    Alerts.Requests = Requests;
})(Alerts || (Alerts = {}));

/// <reference path="../../typings/portia/main.d.ts" />
/// <reference path="../../typings/jquery/jquery.d.ts" />
/// <reference path="./System.ts" />
var Helpers;
(function (Helpers) {
    var FriendlyUrl = (function () {
        function FriendlyUrl() {
        }
        // used in refine and common search and for main menu links
        FriendlyUrl.GetFriendlyUrlForSearch = function (url, regionOrLocality) {
            regionOrLocality = Helpers.FriendlyUrl.ReplaceNotFriendlyCharacters(RemoveDiacritics(regionOrLocality));
            var hostNameRegExp = new RegExp("^[^#]*?://.*?(/.*)$");
            if (hostNameRegExp.test(url)) {
                var data = hostNameRegExp.exec(url);
                url = data[1];
            }
            var friendlyUrlRegExp = new RegExp("/(.+)/(.+)/search([^/]*)/([A-Za-z0-9_]+)/([A-Za-z0-9_]+)/([A-Za-z0-9_\\-\\s'%20']+)(/([A-Za-z0-9_]+)){0,1}(/([A-Za-z0-9_]+)){0,1}(\\?(.*)){0,1}", 'i');
            var urlRegExp = new RegExp("/(.+)/search([^/]*)/([A-Za-z0-9_]+)/([A-Za-z0-9_]+)/([A-Za-z0-9_\\-\\s'%20']+)(/([A-Za-z0-9_]+)){0,1}(/([A-Za-z0-9_]+)){0,1}(\\?(.*)){0,1}", 'i');
            // auto detect new or old url
            if (friendlyUrlRegExp.test(url)) {
                var data = friendlyUrlRegExp.exec(url);
                if (data.length < 12) {
                    return url;
                }
                return FriendlyUrl.GenerateFriendlySearchLink(data[1], data[4], data[5], data[6], regionOrLocality, data[10], data[12], data[3].toLowerCase() == "mapmode");
            }
            else if (urlRegExp.test(url)) {
                var data = urlRegExp.exec(url);
                if (data.length < 11) {
                    return url;
                }
                return FriendlyUrl.GenerateFriendlySearchLink(data[1], data[3], data[4], data[5], regionOrLocality, data[9], data[11], data[3].toLowerCase() == "mapmode");
            }
            return url;
        };
        // generates friendly url from params
        FriendlyUrl.GenerateFriendlySearchLink = function (lan, transactionType, country, searchConfig, regionOrLocality, sorting, params, mapMode) {
            if (mapMode === void 0) { mapMode = false; }
            var friendlyUrl = "";
            if (!regionOrLocality) {
                friendlyUrl = searchConfig.toLowerCase() + "-" + PortiaConstants.Dicos.Search.SearchTitle.For + "-" + transactionType.toLowerCase() + "-" + PortiaConstants.Dicos.Search.SearchTitle.In + "-" + country.toLowerCase();
            }
            else {
                friendlyUrl = searchConfig.toLowerCase() + "-" + PortiaConstants.Dicos.Search.SearchTitle.For + "-" + transactionType.toLowerCase() + "-" + PortiaConstants.Dicos.Search.SearchTitle.In + "-" + regionOrLocality.toLowerCase() + "-" + country.toLowerCase();
            }
            var controller = mapMode ? "SearchEngineMapMode" : "search";
            return "/" + lan + "/" + friendlyUrl + "/" + controller + "/" + transactionType + "/" + country + "/" + searchConfig + (!sorting ? "" : ("/" + sorting)) + (!params ? "" : "?" + params);
        };
        // generates friendly url for codeid
        FriendlyUrl.GenerateFriendlyCodeIDSearchLink = function (codeID) {
            var noAccentsCodeID = Helpers.FriendlyUrl.ReplaceNotFriendlyCharacters(RemoveDiacritics(codeID));
            var friendlyUrl = $.formatString(PortiaConstants.Dicos.Search.SearchTitle.CodeID, [noAccentsCodeID]);
            return "/" + System.getLanguage() + "/" + friendlyUrl + "/SearchEngine/CodeId/" + encodeURIComponent(codeID);
        };
        FriendlyUrl.ReplaceNotFriendlyCharacters = function (input) {
            if (typeof input != "string") {
                return input;
            }
            input = input.replace(/\/\s*/g, "-");
            input = input.replace(/\\\s*/g, "-");
            input = input.replace(/\?\s*/g, "-");
            input = input.replace(/\:\s*/g, "-");
            input = input.replace(/\.\s*/g, "-");
            input = input.replace(/,\s*/g, "-");
            input = input.replace(/\s+/g, "-");
            input = encodeURIComponent(input);
            return input;
        };
        return FriendlyUrl;
    }());
    Helpers.FriendlyUrl = FriendlyUrl;
    var Common = (function () {
        function Common() {
        }
        Common.GetCurrency = function () {
            var currency = store.getState().profile.CurrencyId;
            if (!currency) {
                currency = store.getState().config.portalConfig.defaultCurrency.currency;
            }
            return currency;
        };
        Common.InitCurrencyInLink = function ($link) {
            var currencyId = Common.GetCurrency();
            $link.attr("href", $link.attr("href").replace("__0__", currencyId));
        };
        Common.ReplaceCurrencyInLink = function ($link, currency) {
            if (currency === void 0) { currency = ""; }
            if ($link.length == 0) {
                return;
            }
            if (!currency) {
                currency = Common.GetCurrency();
            }
            var uri = new URI($link.attr("href"));
            uri.setSearch("CurrencyID", currency);
            $link.attr("href", uri.href());
        };
        return Common;
    }());
    Helpers.Common = Common;
})(Helpers || (Helpers = {}));

/// <reference path="../../typings/jquery/jquery.d.ts" />
/// <reference path="../../typings/jquery.html5placeholder/jquery.html5placeholder.d.ts" />
/// <reference path="../../typings/jquery.validation/jquery.validation.d.ts" />
/// <reference path="../../typings/jquery.validate.unobtrusive.custom/jquery.validate.unobtrusive.custom.d.ts" />
/// <reference path="../../typings/portia/main.d.ts" />
/// <reference path="../../typings/royalslider/royalslider.d.ts" />
/// <reference path="./common.ts" />
/// <reference path="./system.ts" />
/// <reference path="./MyImmoBox.ts" />
/// <reference path="./GenericTracking.ts" />
var ItemDetails;
(function (ItemDetails) {
    var Print = (function () {
        function Print() {
        }
        Print.BeforeEvent = function () {
            if (!$('body').data('prevent-multi-print-events')) {
                var campaignId = $('#campaign').data('campaign-id');
                GenericTracking.Trackers.Instance.TrackEvent("PrintItemDetail", { Value: campaignId, CampaignId: campaignId });
                $('body').data('prevent-multi-print-events', true);
            }
        };
        Print.AfterEvent = function () {
            $('body').data('prevent-multi-print-events', false);
        };
        return Print;
    }());
    ItemDetails.Print = Print;
    var Initialize = (function () {
        function Initialize() {
        }
        Initialize.All = function () {
            ItemDetails.Initialize.Gallery();
            if (PortiaConstants.Values.EnableFullProfile) {
                //ItemDetails.Initialize.SendToFriend();
                ItemDetails.Initialize.Favorites();
            }
            ItemDetails.Initialize.ContactPaneEvents();
            ItemDetails.Initialize.ShowProperties();
        };
        Initialize.Favorites = function () {
            $('#id_favorite').on(System.Browser.ClickEventName, function () {
                var typeOfUpdate = $(this).hasClass('__is-favorite') ? "RemoveFromFavourite" : "AddToFavourite";
                var campaignId = $(this).data('favorite-campaign-id');
                MyImmoBox.UserInfo.UpdateFavourites(campaignId, System.getLanguage(), $(this), typeOfUpdate);
                GenericTracking.Trackers.Instance.TrackEvent(typeOfUpdate, { Value: campaignId });
                return false;
            });
        };
        Initialize.SendToFriend = function () {
            UI.ModalView.create({
                modalViewId: "send-to-friend-modalview",
                getContentFromId: "send-to-friend-modalview-content",
                title: PortiaConstants.Dicos.SendToFriend.Title,
                staticWidth: 700,
                openOnClickFromSelector: $('#campaign_share_send-to-friend'),
                footer: {
                    contentType: UI.ModalViewFooterContentType.DataAttributeBased,
                },
                onCreate: function (element) {
                    $.validator.unobtrusive.parseDynamicContent(element.find('#SendToFriendForm'));
                },
                onBeforeOpen: function (element) {
                    element
                        .data('modalView')
                        .refreshFooter('send-to-friend');
                },
                onOpen: function (element) {
                    // Give footer button default modifier
                    ElementItem.Modifier.ChangeTo(element.find('.modalview_window_footer_button'), ElementItem.ModifierType.Default);
                    // Apply placeholders where native support is unavailable
                    System.Form.InitializePlaceholders(element);
                },
                onClose: function (element) {
                    MyImmoBox.Requests.RemoveSpinner();
                }
            });
        };
        Initialize.ContactPaneEvents = function () {
            //UI.ModalView.create({
            //	modalViewId: "contact-form-modalview",
            //	title: PortiaConstants.Dicos.ContactForm.Title,
            //	staticWidth: 450,
            //	footer: {
            //		contentType: UI.ModalViewFooterContentType.DataAttributeBased,
            //	},
            //	// Events
            //	onBeforeOpen: function (element) {
            //		element
            //			.data('modalView')
            //			.refreshFooter('send-request');
            //	},
            //	onOpen: function (element) {
            //		// Give footer button default modifier
            //		ElementItem.Modifier.ChangeTo(element.find('.modalview_window_footer_button'), ElementItem.ModifierType.Default);
            //		// Apply placeholders where native support is unavailable
            //		System.Form.InitializePlaceholders(element);
            //	},
            //	onClose: function (element) {
            //		MyImmoBox.Requests.RemoveSpinner();
            //	}
            //});
            //$('#id_contact').on('click', function () {
            //	var element = $(this);
            //	var campaignId = $('#campaign').data('campaign-id');
            //	$.ajax({
            //		method: 'POST',
            //		url: '/' + System.getLanguage() + '/Account/SendQuickContactFormRequest',
            //		data: 'campaignId=' + campaignId + '&eventAction=OneClickLeadRequest',
            //		beforeSend: function (xhr, settings) {
            //			MyImmoBox.Requests.SetCurrentButton(element);
            //		},
            //		success: function (result, status, xhr) {
            //			var ct = xhr.getResponseHeader("content-type") || "";
            //			if (ct.indexOf('html') > -1) {
            //				element.replaceWith(result);
            //				GenericTracking.Trackers.Instance.TrackEvent("OneClickLeadRequest", { Value: campaignId });
            //				if (PortiaConstants.Values.EnableFullProfile) {
            //					MyImmoBox.GetTabsControl().UpdateMenu(MyImmoBox.TabsEnum.Requests);
            //				}
            //				ElementItem.Modifier.ChangeTo(element, ElementItem.ModifierType.Success);
            //			}
            //			if (ct.indexOf('json') > -1) {
            //				var contactFormUrl = '/' + System.getLanguage() + '/Account/ItemDetailsContactForm' +
            //					'?campaignId=' + result.campaignId +
            //					'&contactFormPath=' + result.contactFormPath +
            //					'&noNeedToLogon=' + result.noNeedToLogon +
            //					'&hideFilledAndNotMandatoryFields=false';
            //				$('#contact-form-modalview .modalview_window_content').load(contactFormUrl, function () {
            //					ElementItem.Modifier.ChangeTo($('#contact-form-modalview .lead-request-form_submit'), ElementItem.ModifierType.Hidden);
            //					$('#contact-form-modalview')
            //						.data('modalView')
            //						.open();
            //				});
            //			}
            //		}
            //	});
            //});
            $('.id_agency-phone, .id_office-phone').unbind('click').on('click', function () {
                ItemDetails.BusinessUnitDetails.LoadFullPhone(this);
            });
        };
        Initialize.ShowProperties = function () {
            var itemDetailsStripes = {
                propertiesSectionClass: 'id_properties',
                propertiesItemClass: 'id_properties_item',
                evenStripeClass: 'layout_wrapper__1',
                oddStripeClass: 'layout_wrapper__2',
                isOdd: false
            };
            $('.' + itemDetailsStripes.propertiesSectionClass).each(function () {
                var el = $(this);
                if (el.find('.' + itemDetailsStripes.propertiesItemClass).length > 0) {
                    el
                        .removeClass('__hidden')
                        .removeClass('hidden')
                        .removeClass('__no-print');
                }
            });
        };
        Initialize.Gallery = function () {
            if ($('#id_gallery').length > 0) {
                $('#id_gallery').royalSlider({
                    loop: false,
                    navigateByClick: true,
                    numImagesToPreload: 2,
                    arrowsNav: true,
                    arrowsNavAutoHide: false,
                    arrowsNavHideOnTouch: true,
                    keyboardNavEnabled: true,
                    fadeinLoadedSlide: true,
                    globalCaption: true,
                    globalCaptionInside: false,
                    fullscreen: {
                        enabled: true,
                        nativeFS: true
                    },
                    controlNavigation: 'bullets',
                    imageScaleMode: 'none',
                    imgWidth: 640,
                    autoPlay: {
                        enabled: true,
                        pauseOnHover: true,
                        delay: 6666
                    }
                });
                var slider = $(".royalSlider").data('royalSlider');
                // fires when every time when slide content is loaded and added to DOM
                slider.ev.on('rsAfterContentSet', function (e, slideObject) {
                    $(".royalSlider").css('visibility', 'visible');
                    slider.updateSliderSize();
                    $('#id_summary').removeClass('hidden');
                });
                // enter fullscreen mode
                slider.ev.on('rsEnterFullscreen', function () {
                    var campaignId = $('#campaign').data('campaign-id');
                    GenericTracking.Trackers.Instance.TrackEvent("DetailFSGallery", {
                        Value: campaignId,
                        CampaignId: campaignId
                    });
                    // POW-3414
                    $('.immobox').attr('hidden', 'hidden');
                });
                slider.ev.on('rsExitFullscreen', function () {
                    // POW-3414
                    $('.immobox').removeAttr('hidden');
                });
            }
        };
        return Initialize;
    }());
    ItemDetails.Initialize = Initialize;
    var BusinessUnitDetails = (function () {
        function BusinessUnitDetails() {
        }
        BusinessUnitDetails.LoadFullPhone = function (element) {
            var campaignId = $('#campaign').data('campaign-id');
            $.ajax({
                type: 'POST',
                url: "/" + System.getLanguage() + "/ItemDetails/GetFullBuPhone/" + campaignId,
                data: JSON.stringify({
                    phoneType: $(element).data('phone-type')
                }),
                dataType: 'json',
                contentType: 'application/json; charset=utf-8',
                success: function (result) {
                    $(element)
                        .unbind('click')
                        .removeClass('action')
                        .wrap('<a href="tel:' + result.replace(/ /g, '') + '" />')
                        .html(result);
                    GenericTracking.Trackers.Instance.TrackEvent("PhoneDisplay", { Value: campaignId, CampaignId: campaignId });
                    $(element).parent().click(function () {
                        //todo: refnum and organization id must be params not DOM query
                        GenericTracking.Trackers.Instance.TrackEvent($(element).hasClass("id_office-phone") ? "CallOfficePhone" : "CallAgencyPhone", {
                            PropertyRefNumber: [$("#campaign").data("propertyrefnumber")],
                            OrganizationId: [$("#campaign").data("organization-id")]
                        });
                        GenericTracking.Trackers.Instance.TrackEvent("PhoneRequest", { Value: campaignId, CampaignId: campaignId });
                        return true;
                    });
                },
                error: function (pResult) {
                    onWcfCallFailure(pResult);
                }
            });
        };
        return BusinessUnitDetails;
    }());
    ItemDetails.BusinessUnitDetails = BusinessUnitDetails;
})(ItemDetails || (ItemDetails = {}));

var Shared;
(function (Shared) {
    var Header = (function () {
        function Header() {
        }
        Header.Initialize = function (options) {
            $(window).on('scroll', function () {
                if (!$(options.FixedTopSelector).hasClass(options.FixedTopModifier) && $(window).scrollTop() > options.FixedTopPosition) {
                    $(options.FixedTopSelector).addClass(options.FixedTopModifier);
                    $(options.ContentSelector).addClass(options.ContentOffsetModifier);
                }
                else if ($(window).scrollTop() <= options.UnfixedTopPosition) {
                    $(options.FixedTopSelector).removeClass(options.FixedTopModifier);
                    $(options.ContentSelector).removeClass(options.ContentOffsetModifier);
                }
            });
        };
        Header.navEvents = function () {
            var mpMenu = document.getElementById('mp-menu');
            var mpMenuSwitcher = document.getElementById('mp-menu-switcher');
            if (mlPushMenu != undefined && mpMenu != undefined && mpMenuSwitcher != undefined) {
                new mlPushMenu(mpMenu, mpMenuSwitcher, {
                    type: 'cover'
                });
            }
            $('.header_nav-switcher').on(System.Browser.ClickEventName, function (event) {
                $('#off-canvas-nav').addClass('__open');
                $('#layout').addClass('layout__show-mobile-nav');
                event.cancelBubble = true;
                //event.returnValue = false;
                if (event.stopPropagation)
                    event.stopPropagation();
                if (event.preventDefault)
                    event.preventDefault();
                $('.layout__show-mobile-nav').one(System.Browser.ClickEventName, function (e) {
                    if (e.stopPropagation)
                        e.stopPropagation();
                    if (e.preventDefault)
                        e.preventDefault();
                    $('#off-canvas-nav').removeClass('__open');
                    $('#layout').removeClass('layout__show-mobile-nav');
                });
            });
        };
        Header.SecondaryNav = function (options) {
            var secondaryNav = $(options.Selector), secondaryNavTopPosition = secondaryNav.offset().top, contentSections = $(options.NavContentSectionsSelector);
            $('.' + options.NavItemClass).first().addClass('__active');
            $(window).on('scroll', function () {
                var secondaryNavTopPositionOffset = 0;
                if (options.SpyOnFixedHeaderSelector != undefined && $(options.SpyOnFixedHeaderSelector).length > 0) {
                    secondaryNavTopPositionOffset = $(options.SpyOnFixedHeaderSelector).height();
                }
                // Set secondary navigation fixed
                if ($(window).scrollTop() > secondaryNavTopPosition - secondaryNavTopPositionOffset) {
                    secondaryNav.addClass(options.FixedNavModifier);
                    secondaryNav.css('top', secondaryNavTopPositionOffset);
                    $(options.ContentSelector).addClass(options.ContentOffsetModifier);
                }
                else {
                    secondaryNav.removeClass(options.FixedNavModifier);
                    // secondaryNav.css('top', 'auto');
                    $(options.ContentSelector).removeClass(options.ContentOffsetModifier);
                }
                Shared.Header.UpdateSecondaryNavigation(contentSections, secondaryNav);
            });
            secondaryNav.find($('.' + options.NavItemClass)).on('click', function (event) {
                event.preventDefault();
                var target = $(decodeURIComponent(this.hash));
                $('body,html').animate({
                    'scrollTop': target.offset().top - secondaryNav.height() + 1
                }, 400);
            });
        };
        Header.UpdateSecondaryNavigation = function (contentSections, secondaryNav) {
            var firstActualAnchor = secondaryNav.find('a[href="#' + contentSections.first().find(".continent-anchor").attr('id') + '"]'), lastActualAnchor = secondaryNav.find('a[href="#' + contentSections.last().find(".continent-anchor").attr('id') + '"]');
            contentSections.each(function () {
                var actual = $(this), actualHeight = actual.outerHeight(true), actualAnchor = secondaryNav.find('a[href="#' + actual.find(".continent-anchor").attr('id') + '"]'), anchor = actual.find(".continent-anchor"), anchorTop = anchor.offset().top, offset = anchorTop < actual.offset().top ? actual.offset().top - anchorTop : 0;
                actualAnchor.removeClass('__active');
                if ($(window).scrollTop() >= 0 && $(window).scrollTop() < contentSections.first().offset().top) {
                    firstActualAnchor.addClass('__active');
                }
                else if ($(window).scrollTop() > contentSections.last().offset().top + contentSections.last().height() - secondaryNav.height()) {
                    lastActualAnchor.addClass('__active');
                }
                else if ($(window).scrollTop() + $(window).height() == $(document).height()) {
                    lastActualAnchor.addClass('__active');
                }
                else if ((actual.offset().top - secondaryNav.height() - offset <= $(window).scrollTop())
                    && (actual.offset().top + actualHeight - secondaryNav.height() - offset > $(window).scrollTop())) {
                    actualAnchor.addClass('__active');
                }
            });
        };
        return Header;
    }());
    Shared.Header = Header;
    var Utilities = (function () {
        function Utilities() {
        }
        Utilities.BindDropdownToHaveColoredPlaceholder = function (id) {
            this.SetColorOfDropDown($(id));
            $(id).addClass("dropdown-first-option-colored");
            $(id).change(function (e) {
                var th = $(this);
                Utilities.SetColorOfDropDown(th);
            });
        };
        Utilities.SetColorOfDropDown = function (dropdown) {
            if (dropdown[0].selectedIndex == 0) {
                if (!dropdown.hasClass("dropdown-option-colored")) {
                    dropdown.addClass("dropdown-option-colored");
                }
            }
            else {
                dropdown.removeClass("dropdown-option-colored");
            }
        };
        Utilities.SetInputType = function (selector, type) {
            if (Modernizr.touch && $(selector).length > 0) {
                $(selector).prop("type", type);
            }
        };
        Utilities.SetInputTypeByElement = function (elem, type) {
            if (Modernizr.touch && elem.length > 0) {
                elem.prop("type", type);
            }
        };
        Utilities.Guid = function () {
            function s4() {
                return Math.floor((1 + Math.random()) * 0x10000)
                    .toString(16)
                    .substring(1);
            }
            return (s4() + s4()) + "-" + s4() + "-" + s4() + "-" + s4() + "-" + (s4() + s4() + s4());
        };
        return Utilities;
    }());
    Shared.Utilities = Utilities;
    $(function () {
        Header.navEvents();
        if (!Modernizr.overflowscrolling) {
            UI.applyNanoScroller();
        }
    });
})(Shared || (Shared = {}));

/// <reference path="../../typings/jquery/jquery.d.ts" />
var HomePage;
(function (HomePage) {
    var TopCountries = (function () {
        function TopCountries() {
        }
        TopCountries.Initialize = function () {
            $(".countries-list-wrapper a").each(function () {
                var $country = $(this);
                Helpers.Common.InitCurrencyInLink($country);
            });
        };
        TopCountries.UpdateCurrency = function (currency) {
            if (currency === void 0) { currency = ""; }
            $(".countries-list-wrapper a").each(function () {
                var $country = $(this);
                Helpers.Common.ReplaceCurrencyInLink($country, currency);
            });
        };
        TopCountries.UpdateCurrencyForCountryPage = function (currency) {
            if (currency === void 0) { currency = ""; }
            $("#country-page a").each(function () {
                var search = $(this);
                var uri = new URI(search.attr("href"));
                if (uri.search("searchGroupName") && uri.search("searchConfigName")) {
                    Helpers.Common.ReplaceCurrencyInLink(search, currency);
                }
            });
        };
        return TopCountries;
    }());
    HomePage.TopCountries = TopCountries;
})(HomePage || (HomePage = {}));

